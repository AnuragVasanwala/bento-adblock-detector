{
  "version": 3,
  "sources": ["../../src/core/mode/prod.js", "../../src/core/mode/test.js", "../../src/core/mode/local-dev.js", "../../src/core/mode/minified.js", "../../src/core/mode/version.js", "../../src/core/mode/esm.js", "../../src/core/types/array.js", "../../src/core/types/string/index.js", "../../src/core/types/object/index.js", "../../src/core/types/index.js", "../../src/core/error/message-helpers.js", "../../src/core/assert/base.js", "../../src/core/assert/dev.js", "../../src/core/assert/user.js", "../../src/core/dom/layout/index.js", "../../extensions/amp-bind/0.1/amp-bind-macro.js", "../../src/core/data-structures/promise.js", "../../src/core/constants/action-constants.js", "../../src/core/types/object/json.js", "../../src/core/window/index.js", "../../third_party/css-escape/css-escape.js", "../../src/core/dom/css-selectors.js", "../../src/core/dom/query.js", "../../src/core/dom/index.js", "../../src/core/error/index.js", "../../src/core/dom/style.js", "../../src/config.js", "../../src/core/types/string/url.js", "../../src/mode.js", "../../src/service/extension-script.js", "../../src/core/types/function/index.js", "../../src/utils/log.js", "../../src/service-helpers.js", "../../src/element-service.js", "../../src/service/index.js", "../../src/utils/event-helper.js", "../../src/core/data-structures/lru-cache.js", "../../src/url.js", "../../src/batched-json.js", "../../extensions/amp-bind/0.1/amp-state.js", "../../src/core/constants/amp-events.js", "../../src/core/data-structures/signals.js", "../../src/core/document/format.js", "../../src/core/dom/amp-element-helpers.js", "../../extensions/amp-bind/0.1/bind-events.js", "../../src/core/dom/srcset.js", "../../extensions/amp-bind/0.1/bind-validator.js", "../../src/core/data-structures/priority-queue.js", "../../src/style-installer.js", "../../src/chunk.js", "../../src/core/types/function/exponential-backoff.js", "../../src/experiments/index.js", "../../src/error-reporting.js", "../../src/url-rewrite.js", "../../src/web-worker/amp-worker.js", "../../extensions/amp-bind/0.1/bind-impl.js", "../../extensions/amp-bind/0.1/amp-bind.js"],
  "sourcesContent": ["/**\n * Returns true when the build is meant for distribution.\n * This means `amp dist` was called _without_ the --fortesting flag.\n *\n * This is a magic constant replaced by babel.\n *\n * Calls are DCE'd when compiled.\n * @return {boolean}\n */\nexport function isProd() {\n  return IS_PROD;\n}\n", "import {isProd} from './prod';\n\n/**\n * Returns true if executing in a testing environment. Calls may be DCE'd when\n * compiled based on isForDistribution.\n * @param {!Window=} opt_win\n * @return {boolean}\n */\nexport function isTest(opt_win) {\n  if (isProd()) {\n    return false;\n  }\n  const win = opt_win || self;\n  return !!(win.AMP_CONFIG?.test || win.__AMP_TEST || win['__karma__']);\n}\n", "import {isProd} from './prod';\nimport {isTest} from './test';\n\n/**\n * Returns true if executing in a local development or testing environment.\n * Calls may be DCE'd when compiled based on isForDistribution and isTest.\n *\n * @param {!Window=} opt_win\n * @return {boolean}\n */\nexport function isLocalDev(opt_win) {\n  if (isProd()) {\n    return false;\n  }\n\n  return !!self.AMP_CONFIG?.localDev || isTest(opt_win);\n}\n", "/**\n * Returns true whenever closure compiler is used.\n * This is a magic constant that is replaced by babel.\n *\n * @return {boolean}\n */\nexport function isMinified() {\n  return IS_MINIFIED;\n}\n", "/**\n * Returns the internal AMP runtime version. Note that this is not the RTV,\n * which is a prefix and the runtime version.\n *\n * The call sites for this function are replaced with a compile time constant\n * string.\n *\n * @return {string}\n */\nexport function version() {\n  return INTERNAL_RUNTIME_VERSION;\n}\n", "/**\n * Copyright 2021 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {isProd} from './prod';\n\n/**\n * Returns true when compiling an esm binary.\n * This is a magic constant that is replaced by babel.\n *\n * @return {boolean}\n */\nexport function isEsm() {\n  if (isProd()) {\n    return IS_ESM;\n  }\n\n  return self?.__AMP_MODE?.esm ?? IS_ESM;\n}\n", "/**\n * Converts an array-like object to an array.\n * @param {?IArrayLike<T>|string} arrayLike\n * @return {!Array<T>}\n * @template T\n */\nexport function toArray(arrayLike) {\n  return arrayLike ? Array.prototype.slice.call(arrayLike) : [];\n}\n\n/**\n * Determines if value is actually an Array.\n * @param {*} value\n * @return {boolean}\n */\nexport const {isArray} = Array;\n\n/**\n * If the specified argument is an array, it's returned as is. If it's a\n * single item, the array containing this item is created and returned.\n *\n * The double-template pattern here solves a bug where CC can be passed a value\n * with declared type {string|!Array<string>} and return a value with a type of\n * {!Array<string|Array<string>>}.\n *\n * @param {!Array<T>|S} arrayOrSingleItem\n * @return {!Array<T>|!Array<S>}\n * @template S\n * @template T\n */\nexport function arrayOrSingleItemToArray(arrayOrSingleItem) {\n  return isArray(arrayOrSingleItem)\n    ? /** @type {!Array<T>} */ (arrayOrSingleItem)\n    : [/** @type {!S} */ (arrayOrSingleItem)];\n}\n\n/**\n * Compares if two arrays contains exactly same elements of same number\n * of same order. Note that it does NOT handle NaN case as expected.\n *\n * @param {!Array<T>} arr1\n * @param {!Array<T>} arr2\n * @return {boolean}\n * @template T\n */\nexport function areEqualOrdered(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Removes elements that shouldRemove returns true for from the array.\n *\n * @param {!Array<T>} array\n * @param {function(T, number, !Array<T>):boolean} shouldRemove\n * @return {!Array<T>}\n * @template T\n */\nexport function remove(array, shouldRemove) {\n  const removed = [];\n  let index = 0;\n  for (let i = 0; i < array.length; i++) {\n    const item = array[i];\n    if (shouldRemove(item, i, array)) {\n      removed.push(item);\n    } else {\n      if (index < i) {\n        array[index] = item;\n      }\n      index++;\n    }\n  }\n  if (index < array.length) {\n    array.length = index;\n  }\n  return removed;\n}\n\n/**\n * Returns the index of the first element matching the predicate.\n * Like Array#findIndex.\n *\n * @param {!Array<T>} array\n * @param {function(T, number, !Array<T>):boolean} predicate\n * @return {number}\n * @template T\n */\nexport function findIndex(array, predicate) {\n  for (let i = 0; i < array.length; i++) {\n    if (predicate(array[i], i, array)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Converts the given iterator to an array.\n *\n * @param {!Iterator<T>} iterator\n * @return {Array<T>}\n * @template T\n */\nexport function fromIterator(iterator) {\n  const array = [];\n  for (let e = iterator.next(); !e.done; e = iterator.next()) {\n    array.push(e.value);\n  }\n  return array;\n}\n\n/**\n * Adds item to array if it is not already present.\n *\n * @param {Array<T>} array\n * @param {T} item\n * @return {boolean}\n * @template T\n */\nexport function pushIfNotExist(array, item) {\n  if (array.indexOf(item) < 0) {\n    array.push(item);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes the first matching item in the array. Returns `true` if the array\n * has changed.\n *\n * @param {!Array<T>} array\n * @param {T} item\n * @return {boolean}\n * @template T\n */\nexport function removeItem(array, item) {\n  const index = array.indexOf(item);\n  if (index == -1) {\n    return false;\n  }\n  array.splice(index, 1);\n  return true;\n}\n\n/**\n * Returns the last item in an array.\n *\n * @param {Array<T>} array\n * @template T\n * @return {?T}\n */\nexport function lastItem(array) {\n  return array[array.length - 1];\n}\n", "/**\n * @param {string} _match\n * @param {string} character\n * @return {string}\n */\nfunction toUpperCase(_match, character) {\n  return character.toUpperCase();\n}\n\n/**\n * @param {string} match\n * @return {string}\n */\nfunction prependDashAndToLowerCase(match) {\n  return '-' + match.toLowerCase();\n}\n\n/**\n * @param {string} name Attribute name containing dashes.\n * @return {string} Dashes removed and successive character sent to upper case.\n * visibleForTesting\n */\nexport function dashToCamelCase(name) {\n  return name.replace(/-([a-z])/g, toUpperCase);\n}\n\n/**\n * Converts a string that is in camelCase to one that is in dash-case.\n *\n * @param {string} string The string to convert.\n * @return {string} The string in dash-case.\n */\nexport function camelCaseToDash(string) {\n  return string.replace(/(?!^)[A-Z]/g, prependDashAndToLowerCase);\n}\n\n/**\n * @param {string} name Attribute name with dashes\n * @return {string} Dashes replaced by underlines.\n */\nexport function dashToUnderline(name) {\n  return name.replace('-', '_');\n}\n\n/**\n * Polyfill for String.prototype.endsWith.\n * @param {string} string\n * @param {string} suffix\n * @return {boolean}\n */\nexport function endsWith(string, suffix) {\n  const index = string.length - suffix.length;\n  return index >= 0 && string.indexOf(suffix, index) == index;\n}\n\n/**\n * Polyfill for String.prototype.includes.\n * @param {string} string\n * @param {string} substring\n * @param {number=} start\n * @return {boolean}\n */\nexport function includes(string, substring, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n  if (start + substring.length > string.length) {\n    return false;\n  }\n  return string.indexOf(substring, start) !== -1;\n}\n\n/**\n * Expands placeholders in a given template string with values.\n *\n * Placeholders use ${key-name} syntax and are replaced with the value\n * returned from the given getter function.\n *\n * @param {string} template The template string to expand.\n * @param {function(string):*} getter Function used to retrieve a value for a\n *   placeholder. Returns values will be coerced into strings.\n * @param {number=} opt_maxIterations Number of times to expand the template.\n *   Defaults to 1, but should be set to a larger value your placeholder tokens\n *   can be expanded to other placeholder tokens. Take caution with large values\n *   as recursively expanding a string can be exponentially expensive.\n * @return {string}\n */\nexport function expandTemplate(template, getter, opt_maxIterations) {\n  const maxIterations = opt_maxIterations || 1;\n  for (let i = 0; i < maxIterations; i++) {\n    let matches = 0;\n    template = template.replace(/\\${([^}]*)}/g, (_a, b) => {\n      matches++;\n      return getter(b);\n    });\n    if (!matches) {\n      break;\n    }\n  }\n  return template;\n}\n\n/**\n * Hash function djb2a\n * This is intended to be a simple, fast hashing function using minimal code.\n * It does *not* have good cryptographic properties.\n * @param {string} str\n * @return {string} 32-bit unsigned hash of the string\n */\nexport function stringHash32(str) {\n  const {length} = str;\n  let hash = 5381;\n  for (let i = 0; i < length; i++) {\n    hash = (hash * 33) ^ str.charCodeAt(i);\n  }\n  // Convert from 32-bit signed to unsigned.\n  return String(hash >>> 0);\n}\n\n/**\n * Trims a string on the end, removing whitespace characters.\n * @param {string} str  A string to trim.\n * @return {string} The string, with trailing whitespace removed.\n */\nexport function trimEnd(str) {\n  // TODO(sparhami) Does this get inlined for an ES2019 build?\n  if (str.trimEnd) {\n    return str.trimEnd();\n  }\n\n  return ('_' + str).trim().slice(1);\n}\n\n/**\n * Trims any leading whitespace from a string.\n * @param {string} str  A string to trim.\n * @return {string} The string, with leading whitespace removed.\n */\nexport function trimStart(str) {\n  if (str.trimStart) {\n    return str.trimStart();\n  }\n\n  return (str + '_').trim().slice(0, -1);\n}\n\n/**\n * Wrapper around String.replace that handles asynchronous resolution.\n * @param {string} str\n * @param {RegExp} regex\n * @param {Function|string} replacer\n * @return {!Promise<string>}\n */\nexport function asyncStringReplace(str, regex, replacer) {\n  if (isString(replacer)) {\n    return Promise.resolve(str.replace(regex, replacer));\n  }\n  const stringBuilder = [];\n  let lastIndex = 0;\n\n  str.replace(regex, function (match) {\n    // String.prototype.replace will pass 3 to n number of arguments to the\n    // callback function based on how many capture groups the regex may or may\n    // not contain. We know that the match will always be first, and the\n    // index will always be second to last.\n    const matchIndex = arguments[arguments.length - 2];\n    stringBuilder.push(str.slice(lastIndex, matchIndex));\n    lastIndex = matchIndex + match.length;\n\n    // Store the promise in it's eventual string position.\n    const replacementPromise = replacer.apply(null, arguments);\n    stringBuilder.push(replacementPromise);\n  });\n  stringBuilder.push(str.slice(lastIndex));\n\n  return Promise.all(stringBuilder).then((resolved) => resolved.join(''));\n}\n\n/**\n * Pads the beginning of a string with a substring to a target length.\n * @param {string} s\n * @param {number} targetLength\n * @param {string} padString\n * @return {string}\n */\nexport function padStart(s, targetLength, padString) {\n  if (s.length >= targetLength) {\n    return s;\n  }\n  targetLength = targetLength - s.length;\n  let padding = padString;\n  while (targetLength > padding.length) {\n    padding += padString;\n  }\n  return padding.slice(0, targetLength) + s;\n}\n\n/**\n * Tests if a value is a string.\n * @param {?} s\n * @return {boolean}\n */\nexport function isString(s) {\n  return typeof s == 'string';\n}\n", "/* @const */\nconst {hasOwnProperty: hasOwn_, toString: toString_} = Object.prototype;\n\n/**\n * Determines if value is actually an Object.\n * @param {*} value\n * @return {boolean}\n */\nexport function isObject(value) {\n  return toString_.call(value) === '[object Object]';\n}\n\n/**\n * Returns a map-like object.\n * If opt_initial is provided, copies its own properties into the\n * newly created object.\n * @param {T=} opt_initial This should typically be an object literal.\n * @return {T}\n * @template T\n */\nexport function map(opt_initial) {\n  const obj = Object.create(null);\n  if (opt_initial) {\n    Object.assign(obj, opt_initial);\n  }\n  return obj;\n}\n\n/**\n * Return an empty JsonObject or makes the passed in object literal\n * an JsonObject.\n * The JsonObject type is just a simple object that is at-dict.\n * See\n * https://github.com/google/closure-compiler/wiki/@struct-and-@dict-Annotations\n * for what a dict is type-wise.\n * The linter enforces that the argument is, in fact, at-dict like.\n * @param {!Object=} opt_initial\n * @return {!JsonObject}\n */\nexport function dict(opt_initial) {\n  // We do not copy. The linter enforces that the passed in object is a literal\n  // and thus the caller cannot have a reference to it.\n  return /** @type {!JsonObject} */ (opt_initial || {});\n}\n\n/**\n * Checks if the given key is a property in the map.\n *\n * @param {T}  obj a map like property.\n * @param {string}  key\n * @return {boolean}\n * @template T\n */\nexport function hasOwn(obj, key) {\n  return hasOwn_.call(obj, key);\n}\n\n/**\n * Returns obj[key] iff key is obj's own property (is not inherited).\n * Otherwise, returns undefined.\n *\n * @param {Object} obj\n * @param {string} key\n * @return {*}\n */\nexport function ownProperty(obj, key) {\n  if (hasOwn(obj, key)) {\n    return obj[key];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Deep merges source into target.\n *\n * @param {!Object} target\n * @param {!Object} source\n * @param {number} depth The maximum merge depth. If exceeded, Object.assign\n *                       will be used instead.\n * @return {!Object}\n * @throws {Error} If source contains a circular reference.\n * Note: Only nested objects are deep-merged, primitives and arrays are not.\n */\nexport function deepMerge(target, source, depth = 10) {\n  // Keep track of seen objects to detect recursive references.\n  const seen = [];\n\n  /** @type {!Array<{t: !Object, s: !Object, d: number}>} */\n  const queue = [];\n  queue.push({t: target, s: source, d: 0});\n\n  // BFS to ensure objects don't have recursive references at shallower depths.\n  while (queue.length > 0) {\n    const {d, s, t} = queue.shift();\n    if (seen.includes(s)) {\n      throw new Error('Source object has a circular reference.');\n    }\n    seen.push(s);\n    if (t === s) {\n      continue;\n    }\n    if (d > depth) {\n      Object.assign(t, s);\n      continue;\n    }\n    for (const key of Object.keys(s)) {\n      const newValue = s[key];\n      // Perform a deep merge IFF both target and source have the same key\n      // whose corresponding values are objects.\n      if (hasOwn(t, key)) {\n        const oldValue = t[key];\n        if (isObject(newValue) && isObject(oldValue)) {\n          queue.push({t: oldValue, s: newValue, d: d + 1});\n          continue;\n        }\n      }\n      t[key] = newValue;\n    }\n  }\n  return target;\n}\n\n/**\n * @param {!Object} o An object to remove properties from\n * @param {!Array<string>} props A list of properties to remove from the Object\n * @return {!Object} An object with the given properties removed\n */\nexport function omit(o, props) {\n  return Object.keys(o).reduce((acc, key) => {\n    if (!props.includes(key)) {\n      acc[key] = o[key];\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * @param {!Object|null|undefined} o1\n * @param {!Object|null|undefined} o2\n * @return {boolean}\n */\nexport function objectsEqualShallow(o1, o2) {\n  if (o1 == null || o2 == null) {\n    // Null is only equal to null, and undefined to undefined.\n    return o1 === o2;\n  }\n\n  for (const k in o1) {\n    if (o1[k] !== o2[k]) {\n      return false;\n    }\n  }\n  for (const k in o2) {\n    if (o2[k] !== o1[k]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @param {T} obj\n * @param {string} prop\n * @param {function(T, string):R} factory\n * @return {R}\n * @template T,R\n */\nexport function memo(obj, prop, factory) {\n  let result = /** @type {?R} */ (obj[prop]);\n  if (result === undefined) {\n    result = factory(obj, prop);\n    obj[prop] = result;\n  }\n  return result;\n}\n\n/**\n * Recreates objects with prototype-less copies.\n * @param {!JsonObject} obj\n * @return {!JsonObject}\n */\nexport function recreateNonProtoObject(obj) {\n  const copy = map();\n  for (const k in obj) {\n    if (!hasOwn(obj, k)) {\n      continue;\n    }\n    const v = obj[k];\n    copy[k] = isObject(v) ? recreateNonProtoObject(v) : v;\n  }\n  return /** @type {!JsonObject} */ (copy);\n}\n\n/**\n * Returns a value from an object for a field-based expression. The expression\n * is a simple nested dot-notation of fields, such as `field1.field2`. If any\n * field in a chain does not exist or is not an object or array, the returned\n * value will be `undefined`.\n *\n * @param {!JsonObject} obj\n * @param {string} expr\n * @return {*}\n */\nexport function getValueForExpr(obj, expr) {\n  // The `.` indicates \"the object itself\".\n  if (expr == '.') {\n    return obj;\n  }\n  // Otherwise, navigate via properties.\n  const parts = expr.split('.');\n  let value = obj;\n  for (const part of parts) {\n    if (\n      part &&\n      value &&\n      value[part] !== undefined &&\n      typeof value == 'object' &&\n      hasOwn(value, part)\n    ) {\n      value = value[part];\n      continue;\n    }\n    value = undefined;\n    break;\n  }\n  return value;\n}\n", "// Export all type-checking helpers for convenience\nexport {isArray} from './array';\nexport {isEnumValue} from './enum';\nexport {isString} from './string';\nexport {isObject} from './object';\n\n/**\n * Determines if value is an ELement\n * @param {*} value\n * @return {boolean}\n */\nexport function isElement(value) {\n  return value?.nodeType == /* Node.ELEMENT_NODE */ 1;\n}\n\n/**\n * Determines if value is of number type and finite.\n * NaN and Infinity are not considered a finite number.\n * String numbers are not considered numbers.\n * @param {*} value\n * @return {boolean}\n */\nexport function isFiniteNumber(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n", "import {isElement} from '#core/types';\n\n/**\n * Triple zero width space.\n *\n * This is added to user error messages, so that we can later identify\n * them, when the only thing that we have is the message. This is the\n * case in many browsers when the global exception handler is invoked.\n *\n * @const {string}\n */\nexport const USER_ERROR_SENTINEL = '\\u200B\\u200B\\u200B';\n/**\n * Four zero width space.\n *\n * @const {string}\n */\nexport const USER_ERROR_EMBED_SENTINEL = '\\u200B\\u200B\\u200B\\u200B';\n\n/**\n * Converts an element to a readable string; all other types are unchanged.\n * TODO(rcebulko): Unify with log.js\n * @param {*} val\n * @return {*}\n */\nexport function elementStringOrPassThru(val) {\n  // Do check equivalent to `val instanceof Element` without cross-window bug\n  if (isElement(val)) {\n    val = /** @type {Element} */ (val);\n    return val.tagName.toLowerCase() + (val.id ? `#${val.id}` : '');\n  }\n  return val;\n}\n\n/**\n * Tests if an error message contains the user sentinel.\n * @param {string} message\n * @return {boolean} Whether this message was a user error.\n */\nexport function isUserErrorMessage(message) {\n  return message.indexOf(USER_ERROR_SENTINEL) >= 0;\n}\n\n/**\n * @param {string} message\n * @return {boolean} Whether this message was a a user error from an iframe embed.\n */\nexport function isUserErrorEmbedMessage(message) {\n  return message.indexOf(USER_ERROR_EMBED_SENTINEL) >= 0;\n}\n\n/**\n * Strips the user error sentinel from an error message.\n * @param {string} message\n * @return {string} The new message without USER_ERROR_SENTINEL\n */\nexport function stripUserError(message) {\n  return message.replace(USER_ERROR_SENTINEL, '');\n}\n", "import {elementStringOrPassThru} from '#core/error/message-helpers';\nimport {isArray, isElement, isString} from '#core/types';\nimport {remove} from '#core/types/array';\n\n/**\n * @fileoverview This file provides the base implementation for assertion\n * functions. Most files should never import from this; instead, import from\n * `dev` or `user`. It is also used by the Log class for its assertions.\n */\n\n/**\n * A base assertion function, provided to various assertion helpers.\n * @typedef {function(?, string=, ...*):?|function(?, !Array<*>)}\n */\nexport let AssertionFunctionDef;\n\n/**\n * Throws an error if the second argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n * @param {?string} sentinel\n * @param {T} shouldBeTruthy\n * @param {string} opt_message\n * @param {...*} var_args Arguments substituted into %s in the message\n * @return {T}\n * @template T\n * @throws {Error} when shouldBeTruthy is not truthy.\n */\nexport function assert(\n  sentinel,\n  shouldBeTruthy,\n  opt_message = 'Assertion failed',\n  var_args\n) {\n  if (shouldBeTruthy) {\n    return shouldBeTruthy;\n  }\n\n  // Include the sentinel string if provided and not already present\n  if (sentinel && opt_message.indexOf(sentinel) == -1) {\n    opt_message += sentinel;\n  }\n\n  // Skip the first 3 arguments to isolate format params\n  // const messageArgs = Array.prototype.slice.call(arguments, 3);\n  // Index at which message args start\n  let i = 3;\n\n  // Substitute provided values into format string in message\n  const splitMessage = opt_message.split('%s');\n  let message = splitMessage.shift();\n  const messageArray = [message];\n\n  while (splitMessage.length) {\n    const subValue = arguments[i++];\n    const nextConstant = splitMessage.shift();\n\n    message += elementStringOrPassThru(subValue) + nextConstant;\n    messageArray.push(subValue, nextConstant.trim());\n  }\n\n  const error = new Error(message);\n  error.messageArray = remove(messageArray, (x) => x !== '');\n  // __AMP_REPORT_ERROR is installed globally per window in the entry point in\n  // AMP documents. It may not be present for Bento/Preact elements on non-AMP\n  // pages.\n  self.__AMP_REPORT_ERROR?.(error);\n  throw error;\n}\n\n/**\n * Asserts types, backbone of `assertNumber`, `assertString`, etc.\n *\n * It understands array-based \"id\"-contracted messages.\n *\n * Otherwise creates a sprintf syntax string containing the optional message or the\n * default. The `subject` of the assertion is added at the end.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {T} subject\n * @param {*} shouldBeTruthy\n * @param {string} defaultMessage\n * @param {!Array<*>|string=} opt_message\n * @return {T}\n * @template T\n * @private\n */\nfunction assertType_(\n  assertFn,\n  subject,\n  shouldBeTruthy,\n  defaultMessage,\n  opt_message\n) {\n  if (isArray(opt_message)) {\n    assertFn(\n      shouldBeTruthy,\n      /** @type {!Array} */ (opt_message).concat([subject])\n    );\n  } else {\n    assertFn(shouldBeTruthy, `${opt_message || defaultMessage}: %s`, subject);\n  }\n\n  return subject;\n}\n\n/**\n * Throws an error if the first argument isn't an Element.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeElement\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Element} The value of shouldBeTrueish.\n * @throws {Error} when shouldBeElement is not an Element\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertElement(assertFn, shouldBeElement, opt_message) {\n  return /** @type {!Element} */ (\n    assertType_(\n      assertFn,\n      shouldBeElement,\n      isElement(shouldBeElement),\n      'Element expected',\n      opt_message\n    )\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a string. The string can\n * be empty.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeString\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {string} The string value. Can be an empty string.\n * @throws {Error} when shouldBeString is not an String\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertString(assertFn, shouldBeString, opt_message) {\n  return /** @type {string} */ (\n    assertType_(\n      assertFn,\n      shouldBeString,\n      isString(shouldBeString),\n      'String expected',\n      opt_message\n    )\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a number. The allowed values\n * include `0` and `NaN`.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeNumber\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {number} The number value. The allowed values include `0`\n *   and `NaN`.\n * @throws {Error} when shouldBeNumber is not an Number\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertNumber(assertFn, shouldBeNumber, opt_message) {\n  return /** @type {number} */ (\n    assertType_(\n      assertFn,\n      shouldBeNumber,\n      typeof shouldBeNumber == 'number',\n      'Number expected',\n      opt_message\n    )\n  );\n}\n\n/**\n * Throws an error if the first argument is not an array.\n * The array can be empty.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeArray\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Array} The array value\n * @throws {Error} when shouldBeArray is not an Array\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertArray(assertFn, shouldBeArray, opt_message) {\n  return /** @type {!Array} */ (\n    assertType_(\n      assertFn,\n      shouldBeArray,\n      isArray(shouldBeArray),\n      'Array expected',\n      opt_message\n    )\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a boolean.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeBoolean\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {boolean} The boolean value.\n * @throws {Error} when shouldBeBoolean is not an Boolean\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertBoolean(assertFn, shouldBeBoolean, opt_message) {\n  return /** @type {boolean} */ (\n    assertType_(\n      assertFn,\n      shouldBeBoolean,\n      !!shouldBeBoolean === shouldBeBoolean,\n      'Boolean expected',\n      opt_message\n    )\n  );\n}\n", "import * as mode from '#core/mode';\n\nimport * as assertions from './base';\n\n/**\n * @fileoverview This file provides the entrypoint for dev assertions. It's\n * designed so all functions are pure function calls to improve inlining. All\n * functions in this file get DCE'd away during compilation.\n */\n\n/**\n * This will never execute regardless, but will be included on unminified builds\n * builds. It will be DCE'd away from minified builds, and so can be used to\n * validate that Babel is properly removing dev assertions in minified builds.\n */\nfunction devAssertDceCheck() {\n  if (self.__AMP_ASSERTION_CHECK) {\n    console /*OK*/\n      .log('__devAssert_sentinel__');\n  }\n}\n\n/**\n * Throws an error if the first argument isn't trueish. Mirrors devAssert in\n * src/log.js.\n * @param {T} shouldBeTruthy\n * @param {string=} opt_message\n * @param {*=} opt_1 Optional argument (var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {T}\n * @template T\n * @throws {Error} when shouldBeTruthy is not truthy.\n * @closurePrimitive {asserts.truthy}\n */\nexport function devAssert(\n  shouldBeTruthy,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  if (mode.isMinified()) {\n    return shouldBeTruthy;\n  }\n  devAssertDceCheck();\n\n  return assertions.assert(\n    '',\n    shouldBeTruthy,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n\n/**\n * Throws an error if the first argument isn't an Element.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeElement\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Element} The value of shouldBeTrueish.\n * @throws {Error} when shouldBeElement is not an Element\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertElement(shouldBeElement, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {!Element} */ (shouldBeElement);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertElement(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeElement,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a string. The string can\n * be empty.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeString\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {string} The string value. Can be an empty string.\n * @throws {Error} when shouldBeString is not an String\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertString(shouldBeString, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {string} */ (shouldBeString);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertString(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeString,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a number. The allowed values\n * include `0` and `NaN`.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeNumber\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {number} The number value. The allowed values include `0`\n *   and `NaN`.\n * @throws {Error} when shouldBeNumber is not an Number\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertNumber(shouldBeNumber, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {number} */ (shouldBeNumber);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertNumber(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeNumber,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument is not an array.\n * The array can be empty.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeArray\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Array} The array value\n * @throws {Error} when shouldBeArray is not an Array\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertArray(shouldBeArray, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {!Array} */ (shouldBeArray);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertArray(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeArray,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a boolean.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeBoolean\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {boolean} The boolean value.\n * @throws {Error} when shouldBeBoolean is not an Boolean\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertBoolean(shouldBeBoolean, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {boolean} */ (shouldBeBoolean);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertBoolean(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeBoolean,\n    opt_message\n  );\n}\n", "import {USER_ERROR_SENTINEL} from '#core/error/message-helpers';\n\nimport * as assertions from './base';\n\n/**\n * @fileoverview This file provides the entrypoint for user assertions. It's\n * designed so all functions are pure function calls to improve inlining.\n */\n\n/**\n * Throws a user error if the first argument isn't trueish. Mirrors userAssert\n * in src/log.js.\n * @param {T} shouldBeTruthy\n * @param {string} opt_message\n * @param {*=} opt_1 Optional argument (var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {T}\n * @template T\n * @throws {UserError} when shouldBeTruthy is not truthy.\n * @closurePrimitive {asserts.truthy}\n */\nexport function userAssert(\n  shouldBeTruthy,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  return assertions.assert(\n    USER_ERROR_SENTINEL,\n    shouldBeTruthy,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n\n/**\n * Throws an error if the first argument isn't an Element.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeElement\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Element} The value of shouldBeTrueish.\n * @throws {Error} when shouldBeElement is not an Element\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function userAssertElement(shouldBeElement, opt_message) {\n  return assertions.assertElement(\n    /** @type {!assertions.AssertionFunctionDef} */ (userAssert),\n    shouldBeElement,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a string. The string can\n * be empty.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeString\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {string} The string value. Can be an empty string.\n * @throws {Error} when shouldBeString is not an String\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function userAssertString(shouldBeString, opt_message) {\n  return assertions.assertString(\n    /** @type {!assertions.AssertionFunctionDef} */ (userAssert),\n    shouldBeString,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a number. The allowed values\n * include `0` and `NaN`.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeNumber\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {number} The number value. The allowed values include `0`\n *   and `NaN`.\n * @throws {Error} when shouldBeNumber is not an Number\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function userAssertNumber(shouldBeNumber, opt_message) {\n  return assertions.assertNumber(\n    /** @type {!assertions.AssertionFunctionDef} */ (userAssert),\n    shouldBeNumber,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument is not an array.\n * The array can be empty.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeArray\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Array} The array value\n * @throws {Error} when shouldBeArray is not an Array\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function userAssertArray(shouldBeArray, opt_message) {\n  return assertions.assertArray(\n    /** @type {!assertions.AssertionFunctionDef} */ (userAssert),\n    shouldBeArray,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a boolean.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeBoolean\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {boolean} The boolean value.\n * @throws {Error} when shouldBeBoolean is not an Boolean\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function userAssertBoolean(shouldBeBoolean, opt_message) {\n  return assertions.assertBoolean(\n    /** @type {!assertions.AssertionFunctionDef} */ (userAssert),\n    shouldBeBoolean,\n    opt_message\n  );\n}\n", "/**\n * @fileoverview Implements element layout. See https://goo.gl/9avXuT for\n * details.\n */\n\nimport {userAssert} from '#core/assert';\nimport {isFiniteNumber} from '#core/types';\n\n/**\n * @enum {string}\n */\nexport const Layout = {\n  NODISPLAY: 'nodisplay',\n  FIXED: 'fixed',\n  FIXED_HEIGHT: 'fixed-height',\n  RESPONSIVE: 'responsive',\n  CONTAINER: 'container',\n  FILL: 'fill',\n  FLEX_ITEM: 'flex-item',\n  FLUID: 'fluid',\n  INTRINSIC: 'intrinsic',\n};\n\n/**\n * Layout priorities to use with BaseElement#getLayoutPriority() and\n * BaseElement#updateLayoutPriority().\n * @enum {number}\n */\nexport const LayoutPriority = {\n  CONTENT: 0,\n  METADATA: 1,\n  ADS: 2,\n  BACKGROUND: 3,\n};\n\n/**\n * CSS Length type. E.g. \"1px\" or \"20vh\".\n * @typedef {string}\n */\nexport let LengthDef;\n\n/**\n * @typedef {{\n *   width: string,\n *   height: string\n * }}\n */\nexport let DimensionsDef;\n\n/**\n * Elements that the progress can be shown for. This set has to be externalized\n * since the element's implementation may not be downloaded yet.\n * This list does not include video players which are found via regex later.\n * @enum {boolean}\n * @private  Visible for testing only!\n */\nexport const LOADING_ELEMENTS_ = {\n  'AMP-AD': true,\n  'AMP-ANIM': true,\n  'AMP-EMBED': true,\n  'AMP-FACEBOOK': true,\n  'AMP-FACEBOOK-COMMENTS': true,\n  'AMP-FACEBOOK-PAGE': true,\n  'AMP-GOOGLE-DOCUMENT-EMBED': true,\n  'AMP-IFRAME': true,\n  'AMP-IMG': true,\n  'AMP-INSTAGRAM': true,\n  'AMP-LIST': true,\n  'AMP-PINTEREST': true,\n  'AMP-PLAYBUZZ': true,\n  'AMP-RENDER': true,\n  'AMP-TIKTOK': true,\n  'AMP-TWITTER': true,\n};\n/**\n * All video player components must either have a) \"video\" or b) \"player\" in\n * their name. A few components don't follow this convention for historical\n * reasons, so they are listed individually.\n * @private @const {!RegExp}\n */\nconst videoPlayerTagNameRe =\n  /^amp\\-(video|.+player)|AMP-BRIGHTCOVE|AMP-DAILYMOTION|AMP-YOUTUBE|AMP-VIMEO|AMP-IMA-VIDEO/i;\n\n/**\n * @param {string} s\n * @return {!Layout|undefined} Returns undefined in case of failure to parse\n *   the layout string.\n */\nexport function parseLayout(s) {\n  for (const k in Layout) {\n    if (Layout[k] == s) {\n      return Layout[k];\n    }\n  }\n  return undefined;\n}\n\n/**\n * @param {!Layout} layout\n * @return {string}\n */\nexport function getLayoutClass(layout) {\n  return 'i-amphtml-layout-' + layout;\n}\n\n/**\n * Whether an element with this layout inherently defines the size.\n * @param {!Layout} layout\n * @return {boolean}\n */\nexport function isLayoutSizeDefined(layout) {\n  return (\n    layout == Layout.FIXED ||\n    layout == Layout.FIXED_HEIGHT ||\n    layout == Layout.RESPONSIVE ||\n    layout == Layout.FILL ||\n    layout == Layout.FLEX_ITEM ||\n    layout == Layout.FLUID ||\n    layout == Layout.INTRINSIC\n  );\n}\n\n/**\n * Whether an element with this layout has a fixed dimension.\n * @param {!Layout} layout\n * @return {boolean}\n */\nexport function isLayoutSizeFixed(layout) {\n  return layout == Layout.FIXED || layout == Layout.FIXED_HEIGHT;\n}\n\n/**\n * Parses the CSS length value. If no units specified, the assumed value is\n * \"px\". Returns undefined in case of parsing error.\n * @param {string|undefined|null} s\n * @return {!LengthDef|undefined}\n */\nexport function parseLength(s) {\n  if (typeof s == 'number') {\n    return s + 'px';\n  }\n  if (!s) {\n    return undefined;\n  }\n  if (!/^\\d+(\\.\\d+)?(px|em|rem|vh|vw|vmin|vmax|cm|mm|q|in|pc|pt)?$/.test(s)) {\n    return undefined;\n  }\n  if (/^\\d+(\\.\\d+)?$/.test(s)) {\n    return s + 'px';\n  }\n  return s;\n}\n\n/**\n * Asserts that the supplied value is a non-percent CSS Length value.\n * @param {!LengthDef|string|null|undefined} length\n * @return {!LengthDef}\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertLength(length) {\n  userAssert(\n    /^\\d+(\\.\\d+)?(px|em|rem|vh|vw|vmin|vmax|cm|mm|q|in|pc|pt)$/.test(length),\n    'Invalid length value: %s',\n    length\n  );\n  return /** @type {!LengthDef} */ (length);\n}\n\n/**\n * Asserts that the supplied value is a CSS Length value\n * (including percent unit).\n * @param {!LengthDef|string} length\n * @return {!LengthDef}\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertLengthOrPercent(length) {\n  userAssert(\n    /^\\d+(\\.\\d+)?(px|em|rem|vh|vw|vmin|vmax|%)$/.test(length),\n    'Invalid length or percent value: %s',\n    length\n  );\n  return length;\n}\n\n/**\n * Returns units from the CSS length value.\n * @param {!LengthDef|string|null|undefined} length\n * @return {string}\n */\nexport function getLengthUnits(length) {\n  assertLength(length);\n  const m = userAssert(\n    /[a-z]+/i.exec(length),\n    'Failed to read units from %s',\n    length\n  );\n  return m[0];\n}\n\n/**\n * Returns the numeric value of a CSS length value.\n * @param {!LengthDef|string|null|undefined|number} length\n * @return {number|undefined}\n */\nexport function getLengthNumeral(length) {\n  const res = parseFloat(length);\n  return isFiniteNumber(res) ? res : undefined;\n}\n\n/**\n * Whether the loading can be shown for the specified element. This set has\n * to be externalized since the element's implementation may not be\n * downloaded yet.\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isLoadingAllowed(element) {\n  const tagName = element.tagName.toUpperCase();\n  return LOADING_ELEMENTS_[tagName] || isIframeVideoPlayerComponent(tagName);\n}\n\n/**\n * All video player components must either have a) \"video\" or b) \"player\" in\n * their name. A few components don't follow this convention for historical\n * reasons, so they're present in the LOADING_ELEMENTS_ allowlist.\n * @param {string} tagName\n * @return {boolean}\n */\nexport function isIframeVideoPlayerComponent(tagName) {\n  if (tagName == 'AMP-VIDEO') {\n    return false;\n  }\n  return videoPlayerTagNameRe.test(tagName);\n}\n\n/**\n * Configures the supplied element to have a \"fill content\" layout. The\n * exact interpretation of \"fill content\" depends on the element's layout.\n *\n * If `opt_replacedContent` is specified, it indicates whether the \"replaced\n * content\" styling should be applied. Replaced content is not allowed to\n * have its own paddings or border.\n *\n * @param {!Element} element\n * @param {boolean=} opt_replacedContent\n */\nexport function applyFillContent(element, opt_replacedContent) {\n  element.classList.add('i-amphtml-fill-content');\n  if (opt_replacedContent) {\n    element.classList.add('i-amphtml-replaced-content');\n  }\n}\n", "import {LayoutPriority} from '#core/dom/layout';\n\n/**\n * The <amp-bind-macro> element is used to define an expression macro that can\n * be called from other amp-bind expressions within the document.\n */\nexport class AmpBindMacro extends AMP.BaseElement {\n  /** @override */\n  getLayoutPriority() {\n    // Loads after other content.\n    return LayoutPriority.METADATA;\n  }\n\n  /** @override */\n  isAlwaysFixed() {\n    return true;\n  }\n\n  /** @override */\n  isLayoutSupported(unusedLayout) {\n    return true;\n  }\n\n  /** @override */\n  renderOutsideViewport() {\n    // We want the macro to be available wherever it is in the document.\n    return true;\n  }\n\n  /**\n   * @return {string} Returns a string to identify this tag. May not be unique\n   *     if the element name is not unique.\n   * @protected\n   */\n  getName_() {\n    return (\n      '<amp-bind-macro> ' + (this.element.getAttribute('id') || '<unknown id>')\n    );\n  }\n}\n", "let resolved;\n\n/**\n * Returns a cached resolved promise.\n * Babel converts direct calls to Promise.resolve() (with no arguments) into\n * calls to this.\n *\n * @return {!Promise<undefined>}\n */\nexport function resolvedPromise() {\n  if (resolved) {\n    return resolved;\n  }\n\n  // It's important that we call with `undefined` here, to prevent a transform\n  // recursion. If we didn't pass an arg, then the transformer would replace\n  // this callsite with a call to `resolvedPromise()`.\n  resolved = Promise.resolve(undefined);\n  return resolved;\n}\n\n/**\n * Returns a Deferred struct, which holds a pending promise and its associated\n * resolve and reject functions.\n *\n * This is preferred instead of creating a Promise instance to extract the\n * resolve/reject functions yourself:\n *\n * ```\n * // Avoid doing\n * let resolve;\n * const promise = new Promise(res => {\n *   resolve = res;\n * });\n *\n * // Good\n * const deferred = new Deferred();\n * const { promise, resolve } = deferred;\n * ```\n *\n * @template T\n */\nexport class Deferred {\n  /** Constructor. */\n  constructor() {\n    /** @const {!Promise<T>} */\n    this.promise = new /*OK*/ Promise((res, rej) => {\n      /** @const {function(T=)} */\n      this.resolve = res;\n      /** @const {function(*=)} */\n      this.reject = rej;\n    });\n  }\n}\n\n/**\n * Creates a promise resolved to the return value of fn.\n * If fn sync throws, it will cause the promise to reject.\n *\n * @param {function():T} fn\n * @return {!Promise<T>}\n * @template T\n */\nexport function tryResolve(fn) {\n  return new Promise((resolve) => {\n    resolve(fn());\n  });\n}\n\n/**\n * Resolves with the result of the last promise added.\n * @implements {IThenable}\n */\nexport class LastAddedResolver {\n  /**\n   * @param {!Array<!IThenable>=} opt_promises\n   */\n  constructor(opt_promises) {\n    /** @private @const {!Deferred} */\n    this.deferred_ = new Deferred();\n\n    /** @private */\n    this.count_ = 0;\n\n    if (opt_promises) {\n      for (const promise of opt_promises) {\n        this.add(promise);\n      }\n    }\n  }\n\n  /**\n   * Add a promise to possibly be resolved.\n   * @param {!IThenable} promise\n   * @return {!Promise}\n   */\n  add(promise) {\n    const countAtAdd = ++this.count_;\n    promise.then(\n      (result) => {\n        if (this.count_ === countAtAdd) {\n          this.deferred_.resolve(result);\n        }\n      },\n      (error) => {\n        // Don't follow behavior of Promise.all and Promise.race error so that\n        // this will only reject when most recently added promise fails.\n        if (this.count_ === countAtAdd) {\n          this.deferred_.reject(error);\n        }\n      }\n    );\n    return this.deferred_.promise;\n  }\n\n  /** @override */\n  then(opt_resolve, opt_reject) {\n    return this.deferred_.promise.then(opt_resolve, opt_reject);\n  }\n}\n", "import {devAssert} from '#core/assert';\n\n/**\n * Key string in an action arguments map for an unparsed object literal string.\n *\n * E.g. for the action in <p on=\"tap:AMP.setState({foo: 'bar'})\",\n * then `args[RAW_OBJECT_ARGS_KEY]` is the string \"{foo: 'bar'}\".\n *\n * The action service delegates parsing of object literals to the corresponding\n * extension (in the example above, amp-bind).\n *\n * @see ./service/action-impl.ActionInfoDef\n * @const {string}\n */\nexport const RAW_OBJECT_ARGS_KEY = '__AMP_OBJECT_STRING__';\n\n/**\n * Identifier for an element's default action.\n *\n * @const {string}\n */\nexport const DEFAULT_ACTION = 'activate';\n\n/**\n * Corresponds to degree of user intent, i.e. events triggered with strong\n * user intent have high trust.\n *\n * @enum {number}\n */\nexport const ActionTrust = {\n  /**\n   * Events that are triggered without a user gesture, or triggered by a user\n   * gesture with weak intent (e.g. scroll) are \"low trust\".\n   *\n   * Actions that have low impact on the page's visual state should require\n   * \"low trust\" (e.g. pausing a video).\n   */\n  LOW: 1,\n  /**\n   * Events that are triggered nearly immediately (up to a few seconds) after\n   * a user gesture with strong intent (e.g. tap or swipe) are \"default trust\".\n   *\n   * Actions that can modify the page's visual state (e.g. content jumping)\n   * should require \"default trust\". This is the default required trust level\n   * for actions.\n   */\n  DEFAULT: 2,\n  /**\n   * Events that are triggered immediately after a user gesture with\n   * strong intent (e.g. tap or swipe) are \"high trust\".\n   *\n   * There are no actions yet that require high trust.\n   */\n  HIGH: 3,\n};\n\n/**\n * @param {!ActionTrust} actionTrust\n * @return {string}\n */\nexport function actionTrustToString(actionTrust) {\n  switch (actionTrust) {\n    case ActionTrust.LOW:\n      return 'low';\n    case ActionTrust.HIGH:\n      return 'high';\n    default:\n      devAssert(actionTrust === ActionTrust.DEFAULT);\n      return 'default';\n  }\n}\n", "import {isArray} from '#core/types/array';\n\n/**\n * @fileoverview This module declares JSON types as defined in the\n * {@link http://json.org/}.\n */\n\n// NOTE Type are changed to {*} because of\n// https://github.com/google/closure-compiler/issues/1999\n\n/**\n * JSON scalar. It's either string, number or boolean.\n * @typedef {string|number|boolean|null}\n */\nlet JSONScalarDef;\n\n/**\n * JSON object. It's a map with string keys and JSON values.\n * @typedef {!Object<string, ?*>} (* should be JSONValueDef)\n */\nlet JSONObjectDef;\n\n/**\n * JSON array. It's an array with JSON values.\n * @typedef {!Array<?*>} (* should be JSONValueDef)\n */\nlet JSONArrayDef;\n\n/**\n * JSON value. It's either a scalar, an object or an array.\n * @typedef {!JSONScalarDef|!JSONObjectDef|!JSONArrayDef}\n */\nlet JSONValueDef;\n\n/**\n * @typedef {{\n *   YOU_MUST_USE: string,\n *   jsonLiteral: function(),\n *   TO_MAKE_THIS_TYPE: string,\n * }}\n */\nlet InternalJsonLiteralTypeDef;\n\n/**\n * Simple wrapper around JSON.parse that casts the return value\n * to JsonObject.\n * Create a new wrapper if an array return value is desired.\n * @param {string} json JSON string to parse\n * @return {?JsonObject} May be extend to parse arrays.\n */\nexport function parseJson(json) {\n  return /** @type {?JsonObject} */ (JSON.parse(json));\n}\n\n/**\n * Parses the given `json` string without throwing an exception if not valid.\n * Returns `undefined` if parsing fails.\n * Returns the `Object` corresponding to the JSON string when parsing succeeds.\n * @param {string} json JSON string to parse\n * @param {function(!Error)=} opt_onFailed Optional function that will be called\n *     with the error if parsing fails.\n * @return {?JsonObject} May be extend to parse arrays.\n */\nexport function tryParseJson(json, opt_onFailed) {\n  try {\n    return parseJson(json);\n  } catch (e) {\n    opt_onFailed?.(e);\n    return null;\n  }\n}\n\n/**\n * Deeply checks strict equality of items in nested arrays and objects.\n *\n * @param {JSONValueDef} a\n * @param {JSONValueDef} b\n * @param {number} depth The maximum depth. Must be finite.\n * @return {boolean}\n * @throws {Error} If depth argument is not finite.\n */\nexport function deepEquals(a, b, depth = 5) {\n  if (!isFinite(depth) || depth < 0) {\n    throw new Error('Invalid depth: ' + depth);\n  }\n  if (a === b) {\n    return true;\n  }\n  /** @type {!Array<{a: JSONValueDef, b: JSONValueDef, depth: number}>} */\n  const queue = [{a, b, depth}];\n  while (queue.length > 0) {\n    const {a, b, depth} = queue.shift();\n    // Only check deep equality if depth > 0.\n    if (depth > 0) {\n      if (typeof a !== typeof b) {\n        return false;\n      } else if (isArray(a) && isArray(b)) {\n        if (a.length !== b.length) {\n          return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n          queue.push({a: a[i], b: b[i], depth: depth - 1});\n        }\n        continue;\n      } else if (a && b && typeof a === 'object' && typeof b === 'object') {\n        const keysA = Object.keys(a);\n        const keysB = Object.keys(b);\n        if (keysA.length !== keysB.length) {\n          return false;\n        }\n        for (const k of keysA) {\n          queue.push({a: a[k], b: b[k], depth: depth - 1});\n        }\n        continue;\n      }\n    }\n    // If we get here, then depth == 0 or (a, b) are primitives.\n    if (a !== b) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * This helper function handles configurations specified in a JSON format.\n *\n * It allows the configuration is to be written in plain JS (which has better\n * dev ergonomics like comments and trailing commas), and allows the\n * configuration to be transformed into an efficient JSON-parsed representation\n * in the dist build. See https://v8.dev/blog/cost-of-javascript-2019#json\n *\n * @param {!Object} obj\n * @return {!JsonObject}\n */\nexport function jsonConfiguration(obj) {\n  return /** @type {!JsonObject} */ (obj);\n}\n\n/**\n * This converts an Object into a suitable type to be used in `includeJsonLiteral`.\n * This doesn't actually do any conversion, it only changes the closure type.\n *\n * @param {?JSONValueDef} value\n * @return {!InternalJsonLiteralTypeDef}\n */\nexport function jsonLiteral(value) {\n  return /** @type {!InternalJsonLiteralTypeDef} */ (value);\n}\n\n/**\n * Allows inclusion of a variable (that's wrapped in a jsonLiteral\n * call) to be included inside a jsonConfiguration.\n *\n * @param {!InternalJsonLiteralTypeDef} value\n * @return {*}\n */\nexport function includeJsonLiteral(value) {\n  return value;\n}\n", "/**\n * Externs declare that access `defaultView` from `document` or\n * `ownerDocument` is of type `(Window|null)` but most of our parameter types\n * assume that it is never null. This is OK in practice as we ever only get\n * null on disconnected documents or old IE.\n * This helper function casts it into just a simple Window return type.\n *\n * @param {?Window} winOrNull\n * @return {!Window}\n */\nexport function toWin(winOrNull) {\n  return /** @type {!Window} */ (winOrNull);\n}\n\n/**\n * Returns the associated Window for a node.\n *\n * @param {!Node} node\n * @return {!Window}\n */\nexport function getWin(node) {\n  return toWin(\n    (node.ownerDocument || /** @type {!Document} */ (node)).defaultView\n  );\n}\n", "/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */\n\n\n/**\n * This regex consists of 4 matching capture groups and one (non-matching) fallback:\n *\n * - (\\0), catch the null terminator character so it may be replaced by UTF\n *   Replacement Char\n * - ^(-)$, catch a solitary dash char, so that it may be backslash escaped.\n *   This is a separate capture group so that the legal-chars (group 4) doesn't\n *   capture it first, since that group doesn't need to escape its dash.\n * - ([\\x01-\\x1f\\x7f]|^-?[0-9]), catch a UTF control char, or any leading\n *   number (with an optional leading dash). The control or the number (but not\n *   the leading dash) must be hex-escaped,.\n * - ([\\x80-\\uffff0-9a-zA-Z_-]+), catch legal-chars, with the exception of a\n *   solitary dash, which will already have matched in group 1.\n * - [^], finally, a catch-all that allows us to backslash escape the char.\n *\n * Together, this matches everything necessary for CSS.escape.\n */\nvar regex = /(\\0)|^(-)$|([\\x01-\\x1f\\x7f]|^-?[0-9])|([\\x80-\\uffff0-9a-zA-Z_-]+)|[^]/g;\n\nfunction escaper(match, nil, dash, hexEscape, chars) {\n  // Chars is the legal-chars (group 4) capture\n  if (chars) {\n    return chars;\n  }\n  // Nil is the null terminator (group 1) capture\n  if (nil) {\n    return '\\uFFFD';\n  }\n  // Both UTF control chars, and leading numbers (with optional leading dash)\n  // (group 3) must be backslash escaped with a trailing space.  Funnily, the\n  // leading dash must not be escaped, but the number. :shrug:\n  if (hexEscape) {\n    return match.slice(0, -1) + '\\\\' + match.slice(-1).charCodeAt(0).toString(16) + ' '\n  }\n  // Finally, the solitary dash and the catch-all chars require backslash\n  // escaping.\n  return '\\\\' + match;\n}\n\n/**\n * https://drafts.csswg.org/cssom/#serialize-an-identifier\n * @param {string} value\n * @return {string}\n */\nexport function cssEscape(value) {\n  return String(value).replace(regex, escaper);\n}\n", "import {devAssert} from '#core/assert';\nimport * as mode from '#core/mode';\n\nimport {cssEscape} from '#third_party/css-escape/css-escape';\n\n/**\n * @type {boolean|undefined}\n */\nlet scopeSelectorSupported;\n\n/**\n * @param {boolean|undefined} val\n * @visibleForTesting\n */\nexport function setScopeSelectorSupportedForTesting(val) {\n  scopeSelectorSupported = val;\n}\n\n/**\n * Test that the :scope selector is supported and behaves correctly.\n * @param {!Element|!ShadowRoot} el\n * @return {boolean}\n */\nexport function isScopeSelectorSupported(el) {\n  if (scopeSelectorSupported !== undefined) {\n    return scopeSelectorSupported;\n  }\n\n  return (scopeSelectorSupported = testScopeSelector(el));\n}\n\n/**\n * Test that the :scope selector is supported and behaves correctly.\n * @param {!Element|!ShadowRoot} el\n * @return {boolean}\n */\nfunction testScopeSelector(el) {\n  try {\n    const doc = el.ownerDocument;\n    const testElement = doc.createElement('div');\n    const testChild = doc.createElement('div');\n    testElement.appendChild(testChild);\n    // NOTE(cvializ, #12383): Firefox's implementation is incomplete,\n    // therefore we test actual functionality of`:scope` as well.\n    return testElement./*OK*/ querySelector(':scope div') === testChild;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Prefixes a selector for ancestor selection. Splits in subselectors and\n * applies prefix to each.\n *\n * e.g.\n * ```\n *   prependSelectorsWith('div', '.i-amphtml-scoped');\n *   // => '.i-amphtml-scoped div'\n *   prependSelectorsWith('div, ul', ':scope');\n *   // => ':scope div, :scope ul'\n *   prependSelectorsWith('div, ul', 'article >');\n *   // => 'article > div, article > ul'\n * ```\n *\n * @param {string} selector\n * @param {string} distribute\n * @return {string}\n */\nexport function prependSelectorsWith(selector, distribute) {\n  return selector.replace(/^|,/g, `$&${distribute} `);\n}\n\n/**\n * Escapes an ident (ID or a class name) to be used as a CSS selector.\n *\n * See https://drafts.csswg.org/cssom/#serialize-an-identifier.\n *\n * @param {string} ident\n * @return {string}\n * @suppress {uselessCode}\n */\nexport function escapeCssSelectorIdent(ident) {\n  // This gets rewritten to true/false during compilation. It will trigger an\n  // JSC_UNREACHABLE_CODE warning, but that's intentional for DCE.\n  if (mode.isEsm()) {\n    return CSS.escape(ident);\n  }\n  return cssEscape(ident);\n}\n\n/**\n * Escapes an ident in a way that can be used by :nth-child() psuedo-class.\n *\n * See https://github.com/w3c/csswg-drafts/issues/2306.\n *\n * @param {string|number} ident\n * @return {string}\n */\nexport function escapeCssSelectorNth(ident) {\n  const escaped = String(ident);\n  // Ensure it doesn't close the nth-child psuedo class.\n  devAssert(escaped.indexOf(')') === -1);\n  return escaped;\n}\n", "import {devAssert, devAssertElement} from '#core/assert';\nimport * as mode from '#core/mode';\n\nimport {isScopeSelectorSupported, prependSelectorsWith} from './css-selectors';\n\n/** @fileoverview Helper functions for DOM queries. */\n\n/**\n * Asserts that name is just an alphanumeric word, and does not contain\n * advanced CSS selector features like attributes, psuedo-classes, class names,\n * nor ids.\n * @param {string} name\n */\nfunction assertIsName(name) {\n  devAssert(\n    /^[\\w-]+$/.test(name),\n    `Expected \"${name}\" to be a CSS name composed of alphanumerics and hyphens.`\n  );\n}\n\n/**\n * Finds all elements that matche `selector`, scoped inside `root`\n * for user-agents that do not support native scoping.\n *\n * This method isn't required for modern builds, can be removed.\n *\n * @param {!Element|!ShadowRoot} root\n * @param {string} selector\n * @return {!NodeList<!Element>}\n */\nfunction scopedQuerySelectionFallback(root, selector) {\n  const unique = 'i-amphtml-scoped';\n  root.classList.add(unique);\n  const scopedSelector = prependSelectorsWith(selector, `.${unique}`);\n  const elements = root./*OK*/ querySelectorAll(scopedSelector);\n  root.classList.remove(unique);\n  return elements;\n}\n\n/**\n * Finds the first element that matches `selector`, scoped inside `root`.\n * Note: in IE, this causes a quick mutation of the element's class list.\n * @param {!Element|!ShadowRoot} root\n * @param {string} selector\n * @return {?Element}\n *\n * @suppress {suspiciousCode}\n */\nexport function scopedQuerySelector(root, selector) {\n  if (mode.isEsm() || isScopeSelectorSupported(root)) {\n    return root./*OK*/ querySelector(prependSelectorsWith(selector, ':scope'));\n  }\n\n  // Only IE.\n  const fallbackResult = scopedQuerySelectionFallback(root, selector);\n  return fallbackResult[0] === undefined ? null : fallbackResult[0];\n}\n\n/**\n * Finds every element that matches `selector`, scoped inside `root`.\n * Note: in IE, this causes a quick mutation of the element's class list.\n * @param {!Element|!ShadowRoot} root\n * @param {string} selector\n * @return {!NodeList<!Element>}\n *\n * @suppress {suspiciousCode}\n */\nexport function scopedQuerySelectorAll(root, selector) {\n  if (mode.isEsm() || isScopeSelectorSupported(root)) {\n    return root./*OK*/ querySelectorAll(\n      prependSelectorsWith(selector, ':scope')\n    );\n  }\n\n  // Only IE.\n  return scopedQuerySelectionFallback(root, selector);\n}\n\n/**\n * Checks if the given element matches the selector\n * @param  {!Element} el The element to verify\n * @param  {string} selector The selector to check against\n * @return {boolean} True if the element matched the selector. False otherwise.\n */\nexport function matches(el, selector) {\n  const matcher =\n    el.matches ||\n    el.webkitMatchesSelector ||\n    el.mozMatchesSelector ||\n    el.msMatchesSelector ||\n    el.oMatchesSelector;\n  if (matcher) {\n    return matcher.call(el, selector);\n  }\n  return false; // IE8 always returns false.\n}\n\n/**\n * Finds the closest element that satisfies the callback from this element\n * up the DOM subtree.\n * @param {!Element} element\n * @param {function(!Element):boolean} callback\n * @param {Element=} opt_stopAt optional elemnt to stop the search at.\n * @return {?Element}\n */\nexport function closest(element, callback, opt_stopAt) {\n  for (let el = element; el && el !== opt_stopAt; el = el.parentElement) {\n    if (callback(el)) {\n      return el;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds the closest node that satisfies the callback from this node\n * up the DOM subtree.\n * @param {!Node} node\n * @param {function(!Node):boolean} callback\n * @return {?Node}\n */\nexport function closestNode(node, callback) {\n  for (let n = node; n; n = n.parentNode) {\n    if (callback(n)) {\n      return n;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds the closest ancestor element with the specified selector from this\n * element.\n * @param {!Element} element\n * @param {string} selector\n * @return {?Element} closest ancestor if found.\n */\nexport function closestAncestorElementBySelector(element, selector) {\n  return element.closest\n    ? element.closest(selector)\n    : closest(element, (el) => matches(el, selector));\n}\n\n/**\n * Finds all ancestor elements that satisfy predicate.\n * @param {!Element} child\n * @param {function(!Element):boolean} predicate\n * @return {!Array<!Element>}\n */\nexport function ancestorElements(child, predicate) {\n  const ancestors = [];\n  for (\n    let ancestor = child.parentElement;\n    ancestor;\n    ancestor = ancestor.parentElement\n  ) {\n    if (predicate(ancestor)) {\n      ancestors.push(ancestor);\n    }\n  }\n  return ancestors;\n}\n\n/**\n * Finds all ancestor elements that has the specified tag name.\n * @param {!Element} child\n * @param {string} tagName\n * @return {!Array<!Element>}\n */\nexport function ancestorElementsByTag(child, tagName) {\n  assertIsName(tagName);\n  tagName = tagName.toUpperCase();\n  return ancestorElements(child, (el) => el.tagName == tagName);\n}\n\n/**\n * Finds the first child element that satisfies the callback.\n * TODO(rcebulko): Can we start using generators in childElements and defer to\n * that here?\n * @param {!Element} parent\n * @param {function(!Element):boolean} callback\n * @return {?Element}\n */\nexport function childElement(parent, callback) {\n  for (\n    let child = parent.firstElementChild;\n    child;\n    child = child.nextElementSibling\n  ) {\n    if (callback(child)) {\n      return child;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds the last child element that satisfies the callback.\n * @param {!Element} parent\n * @param {function(!Element):boolean} callback\n * @return {?Element}\n */\nexport function lastChildElement(parent, callback) {\n  for (\n    let child = parent.lastElementChild;\n    child;\n    child = child.previousElementSibling\n  ) {\n    if (callback(child)) {\n      return child;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds all child elements that satisfy the callback.\n * @param {!Element} parent\n * @param {function(!Element):boolean} callback\n * @return {!Array<!Element>}\n */\nexport function childElements(parent, callback) {\n  const children = [];\n  for (\n    let child = parent.firstElementChild;\n    child;\n    child = child.nextElementSibling\n  ) {\n    if (callback(child)) {\n      children.push(child);\n    }\n  }\n  return children;\n}\n\n/**\n * Finds all child nodes that satisfy the callback.\n * These nodes can include Text, Comment and other child nodes.\n * @param {!Node} parent\n * @param {function(!Node):boolean} callback\n * @return {!Array<!Node>}\n */\nexport function childNodes(parent, callback) {\n  const nodes = [];\n  for (let child = parent.firstChild; child; child = child.nextSibling) {\n    if (callback(child)) {\n      nodes.push(child);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Finds the first child element that has the specified attribute.\n * @param {!Element|!ShadowRoot} parent\n * @param {string} attr\n * @return {?Element}\n */\nexport function childElementByAttr(parent, attr) {\n  assertIsName(attr);\n  return /*OK*/ scopedQuerySelector(parent, `> [${attr}]`);\n}\n\n/**\n * Finds the last child element that has the specified attribute.\n * @param {!Element} parent\n * @param {string} attr\n * @return {?Element}\n */\nexport function lastChildElementByAttr(parent, attr) {\n  assertIsName(attr);\n  return lastChildElement(parent, (el) => {\n    return el.hasAttribute(attr);\n  });\n}\n\n/**\n * Finds all child elements that has the specified attribute.\n * @param {!Element|!ShadowRoot} parent\n * @param {string} attr\n * @return {!NodeList<!Element>}\n */\nexport function childElementsByAttr(parent, attr) {\n  assertIsName(attr);\n  return /*OK*/ scopedQuerySelectorAll(parent, `> [${attr}]`);\n}\n\n/**\n * Finds the first child element that has the specified tag name.\n * @param {!Element|!ShadowRoot} parent\n * @param {string} tagName\n * @return {?Element}\n */\nexport function childElementByTag(parent, tagName) {\n  assertIsName(tagName);\n  return /*OK*/ scopedQuerySelector(parent, `> ${tagName}`);\n}\n\n/**\n * Finds all child elements with the specified tag name.\n * @param {!Element|!ShadowRoot} parent\n * @param {string} tagName\n * @return {!NodeList<!Element>}\n */\nexport function childElementsByTag(parent, tagName) {\n  assertIsName(tagName);\n  return /*OK*/ scopedQuerySelectorAll(parent, `> ${tagName}`);\n}\n\n/**\n * Finds the first descendant element with the specified name.\n * @param {!Element|!Document|!ShadowRoot} element\n * @param {string} tagName\n * @return {?Element}\n */\nexport function elementByTag(element, tagName) {\n  assertIsName(tagName);\n  return element./*OK*/ querySelector(tagName);\n}\n\n/**\n * Returns the original nodes of the custom element without any service\n * nodes that could have been added for markup. These nodes can include\n * Text, Comment and other child nodes.\n *\n * @param {!Node} element\n * @return {!Array<!Node>}\n */\nexport function realChildNodes(element) {\n  return childNodes(element, (node) => !isInternalOrServiceNode(node));\n}\n\n/**\n * Returns the original children of the custom element without any service\n * nodes that could have been added for markup.\n *\n * @param {!Element} element\n * @return {!Array<!Element>}\n */\nexport function realChildElements(element) {\n  return childElements(element, (element) => !isInternalOrServiceNode(element));\n}\n\n/**\n * Returns \"true\" for internal AMP nodes or for placeholder elements.\n * @param {!Node} node\n * @return {boolean}\n */\nexport function isInternalOrServiceNode(node) {\n  if (isInternalElement(node)) {\n    return true;\n  }\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return false;\n  }\n  devAssertElement(node);\n\n  return (\n    node.hasAttribute('placeholder') ||\n    node.hasAttribute('fallback') ||\n    node.hasAttribute('overflow')\n  );\n}\n\n/**\n * Whether the tag is an internal (service) AMP tag.\n * @param {!Node|string} nodeOrTagName\n * @return {boolean}\n */\nfunction isInternalElement(nodeOrTagName) {\n  /** @type string */\n  let tagName;\n  if (typeof nodeOrTagName == 'string') {\n    tagName = nodeOrTagName;\n  } else if (nodeOrTagName.nodeType === Node.ELEMENT_NODE) {\n    tagName = devAssertElement(nodeOrTagName).tagName;\n  }\n\n  return !!tagName && tagName.toLowerCase().startsWith('i-');\n}\n", "import * as mode from '#core/mode';\nimport {dict} from '#core/types/object';\nimport {parseJson} from '#core/types/object/json';\nimport {getWin} from '#core/window';\n\nimport {childElementsByTag, matches} from './query';\n\nconst HTML_ESCAPE_CHARS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '`': '&#x60;',\n};\nconst HTML_ESCAPE_REGEX = /(&|<|>|\"|'|`)/g;\n\n/**\n * @typedef {{\n *   bubbles: (boolean|undefined),\n *   cancelable: (boolean|undefined),\n * }}\n */\nexport let CustomEventOptionsDef;\n\n/** @const {!CustomEventOptionsDef} */\nconst DEFAULT_CUSTOM_EVENT_OPTIONS = {bubbles: true, cancelable: true};\n\n/**\n * Waits until the child element is constructed. Once the child is found, the\n * callback is executed.\n * @param {!Element} parent\n * @param {function(!Element):boolean} checkFunc\n * @param {function()} callback\n */\nexport function waitForChild(parent, checkFunc, callback) {\n  if (checkFunc(parent)) {\n    callback();\n    return;\n  }\n  const win = getWin(parent);\n  if (mode.isEsm() || win.MutationObserver) {\n    const observer = new win.MutationObserver(() => {\n      if (checkFunc(parent)) {\n        observer.disconnect();\n        callback();\n      }\n    });\n    observer.observe(parent, {childList: true});\n  } else {\n    const interval = win.setInterval(() => {\n      if (checkFunc(parent)) {\n        win.clearInterval(interval);\n        callback();\n      }\n    }, /* milliseconds */ 5);\n  }\n}\n\n/**\n * Waits until the child element is constructed. Once the child is found, the\n * promise is resolved.\n * @param {!Element} parent\n * @param {function(!Element):boolean} checkFunc\n * @return {!Promise}\n */\nexport function waitForChildPromise(parent, checkFunc) {\n  return new Promise((resolve) => {\n    waitForChild(parent, checkFunc, resolve);\n  });\n}\n\n/**\n * Waits for document's body to be available and ready.\n * @param {!Document} doc\n * @param {function()} callback\n */\nexport function waitForBodyOpen(doc, callback) {\n  waitForChild(doc.documentElement, () => !!doc.body, callback);\n}\n\n/**\n * Waits for document's body to be available.\n * @param {!Document} doc\n * @return {!Promise}\n */\nexport function waitForBodyOpenPromise(doc) {\n  return new Promise((resolve) => waitForBodyOpen(doc, resolve));\n}\n\n/**\n * Removes the element.\n * @param {!Element} element\n */\nexport function removeElement(element) {\n  element.parentElement?.removeChild(element);\n}\n\n/**\n * Removes all child nodes of the specified element.\n * @param {!Element|!DocumentFragment} parent\n */\nexport function removeChildren(parent) {\n  while (parent.firstChild) {\n    parent.removeChild(parent.firstChild);\n  }\n}\n\n/**\n * Copies all children nodes of element \"from\" to element \"to\". Child nodes\n * are deeply cloned. Notice, that this method should be used with care and\n * preferably on smaller subtrees.\n * @param {!Element} from\n * @param {!Element|!DocumentFragment} to\n */\nexport function copyChildren(from, to) {\n  const frag = to.ownerDocument.createDocumentFragment();\n  for (let n = from.firstChild; n; n = n.nextSibling) {\n    frag.appendChild(n.cloneNode(true));\n  }\n  to.appendChild(frag);\n}\n\n/**\n * Insert the element in the root after the element named after or\n * if that is null at the beginning.\n * @param {!Element|!ShadowRoot} root\n * @param {!Element} element\n * @param {?Node=} after\n */\nexport function insertAfterOrAtStart(root, element, after = null) {\n  if (!after) {\n    insertAtStart(root, element);\n    return;\n  }\n  const before = after.nextSibling;\n  root.insertBefore(element, before);\n}\n\n/**\n * Insert the element in the root after the element named after or\n * if that is null at the beginning.\n * @param {!Element|!ShadowRoot} root\n * @param {!Element} element\n */\nexport function insertAtStart(root, element) {\n  root.insertBefore(element, root.firstChild);\n}\n\n/**\n * Add attributes to an element.\n * @param {!Element} element\n * @param {!JsonObject<string, string>} attributes\n * @return {!Element} created element\n */\nexport function addAttributesToElement(element, attributes) {\n  for (const attr in attributes) {\n    element.setAttribute(attr, attributes[attr]);\n  }\n  return element;\n}\n\n/**\n * Create a new element on document with specified tagName and attributes.\n * @param {!Document} doc\n * @param {string} tagName\n * @param {!JsonObject<string, string>} attributes\n * @return {!Element} created element\n */\nexport function createElementWithAttributes(doc, tagName, attributes) {\n  const element = doc.createElement(tagName);\n  return addAttributesToElement(element, attributes);\n}\n\n/**\n * Returns true if node is connected (attached).\n * @param {!Node} node\n * @return {boolean}\n * @see https://dom.spec.whatwg.org/#connected\n */\nexport function isConnectedNode(node) {\n  const connected = node.isConnected;\n  if (connected !== undefined) {\n    return connected;\n  }\n\n  // \"An element is connected if its shadow-including root is a document.\"\n  let n = node;\n  do {\n    n = rootNodeFor(n);\n    if (n.host) {\n      n = n.host;\n    } else {\n      break;\n    }\n  } while (true);\n  return n.nodeType === Node.DOCUMENT_NODE;\n}\n\n/**\n * Returns the root for a given node. Does not cross shadow DOM boundary.\n * @param {!Node} node\n * @return {!Node}\n */\nexport function rootNodeFor(node) {\n  if (Node.prototype.getRootNode) {\n    // Type checker says `getRootNode` may return null.\n    return node.getRootNode() || node;\n  }\n  let n;\n  // Check isShadowRoot() is only needed for the polyfill case.\n  for (\n    n = node;\n    !!n.parentNode && !isShadowRoot(/** @type {HTMLElement} */ (n));\n    n = n.parentNode\n  ) {}\n  return n;\n}\n\n/**\n * Determines if value is actually a `ShadowRoot` node.\n * @param {?HTMLElement} value\n * @return {boolean}\n */\nexport function isShadowRoot(value) {\n  if (!value) {\n    return false;\n  }\n  // Node.nodeType == DOCUMENT_FRAGMENT to speed up the tests. Unfortunately,\n  // nodeType of DOCUMENT_FRAGMENT is used currently for ShadowRoot nodes.\n  if (value.tagName == 'I-AMPHTML-SHADOW-ROOT') {\n    return true;\n  }\n  return (\n    value.nodeType == /* DOCUMENT_FRAGMENT */ 11 &&\n    Object.prototype.toString.call(value) === '[object ShadowRoot]'\n  );\n}\n\n/**\n * Returns element data-param- attributes as url parameters key-value pairs.\n * e.g. data-param-some-attr=value -> {someAttr: value}.\n * @param {!HTMLElement} element\n * @param {function(string):string=} opt_computeParamNameFunc to compute the\n *    parameter name, get passed the camel-case parameter name.\n * @param {!RegExp=} opt_paramPattern Regex pattern to match data attributes.\n * @return {!JsonObject}\n */\nexport function getDataParamsFromAttributes(\n  element,\n  opt_computeParamNameFunc,\n  opt_paramPattern\n) {\n  const computeParamNameFunc = opt_computeParamNameFunc || ((key) => key);\n  const {dataset} = element;\n  const params = dict();\n  const paramPattern = opt_paramPattern || /^param(.+)/;\n  for (const key in dataset) {\n    const matches = key.match(paramPattern);\n    if (matches) {\n      const param = matches[1][0].toLowerCase() + matches[1].substr(1);\n      params[computeParamNameFunc(param)] = dataset[key];\n    }\n  }\n  return params;\n}\n\n/**\n * Whether the element have a next node in the document order.\n * This means either:\n *  a. The element itself has a nextSibling.\n *  b. Any of the element ancestors has a nextSibling.\n * @param {!Element} element\n * @param {?Node} opt_stopNode\n * @return {boolean}\n */\nexport function hasNextNodeInDocumentOrder(element, opt_stopNode) {\n  let currentElement = element;\n  do {\n    if (currentElement.nextSibling) {\n      return true;\n    }\n  } while (\n    (currentElement = currentElement.parentNode) &&\n    currentElement != opt_stopNode\n  );\n  return false;\n}\n\n/**\n * Returns a clone of the content of a template element.\n *\n * Polyfill to replace .content access for browsers that do not support\n * HTMLTemplateElements natively.\n *\n * @param {!HTMLTemplateElement|!Element} template\n * @return {!DocumentFragment}\n */\nexport function templateContentClone(template) {\n  if ('content' in template) {\n    return template.content.cloneNode(true);\n  } else {\n    const content = template.ownerDocument.createDocumentFragment();\n    copyChildren(template, content);\n    return content;\n  }\n}\n\n/**\n * Iterate over an array-like.\n * Test cases: https://jsbench.github.io/#f638cacc866a1b2d6e517e6cfa900d6b\n * @param {!IArrayLike<T>} iterable\n * @param {function(T, number)} cb\n * @template T\n */\nexport function iterateCursor(iterable, cb) {\n  const {length} = iterable;\n  for (let i = 0; i < length; i++) {\n    cb(iterable[i], i);\n  }\n}\n\n/**\n * Whether the element is a script tag with application/json type.\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isJsonScriptTag(element) {\n  return (\n    element.tagName == 'SCRIPT' &&\n    element.getAttribute('type')?.toUpperCase() == 'APPLICATION/JSON'\n  );\n}\n\n/**\n * Whether the element is a script tag with application/json type.\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isJsonLdScriptTag(element) {\n  return (\n    element.tagName == 'SCRIPT' &&\n    element.getAttribute('type')?.toUpperCase() == 'APPLICATION/LD+JSON'\n  );\n}\n\n/**\n * Whether the page's direction is right to left or not.\n * @param {!Document} doc\n * @return {boolean}\n */\nexport function isRTL(doc) {\n  const dir =\n    doc.body.getAttribute('dir') ||\n    doc.documentElement.getAttribute('dir') ||\n    'ltr';\n  return dir == 'rtl';\n}\n\n/**\n * Escapes `<`, `>` and other HTML charcaters with their escaped forms.\n * @param {string} text\n * @return {string}\n */\nexport function escapeHtml(text) {\n  if (!text) {\n    return text;\n  }\n  return text.replace(HTML_ESCAPE_REGEX, escapeHtmlChar);\n}\n\n/**\n * @param {string} c\n * @return {string}\n */\nfunction escapeHtmlChar(c) {\n  return HTML_ESCAPE_CHARS[c];\n}\n\n/**\n * Tries to focus on the given element; fails silently if browser throws an\n * exception.\n * @param {!Element} element\n */\nexport function tryFocus(element) {\n  try {\n    element./*OK*/ focus();\n  } catch (e) {\n    // IE <= 7 may throw exceptions when focusing on hidden items.\n  }\n}\n\n/**\n * Whether the given window is in an iframe or not.\n * @param {!Window} win\n * @return {boolean}\n */\nexport function isIframed(win) {\n  return win.parent && win.parent != win;\n}\n\n/**\n * Returns true if node is not disabled.\n *\n * IE8 can return false positives, see {@link matches}.\n * @param {!HTMLInputElement} element\n * @return {boolean}\n * @see https://www.w3.org/TR/html5/forms.html#concept-fe-disabled\n */\nexport function isEnabled(element) {\n  return !(element.disabled || matches(element, ':disabled'));\n}\n\n/**\n * A sorting comparator that sorts elements in DOM tree order.\n * A first sibling is sorted to be before its nextSibling.\n * A parent node is sorted to be before a child.\n * See https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {!Element} element1\n * @param {!Element} element2\n * @return {number}\n */\nexport function domOrderComparator(element1, element2) {\n  if (element1 === element2) {\n    return 0;\n  }\n\n  const pos = element1.compareDocumentPosition(element2);\n  const precedingOrContains =\n    Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS;\n\n  // if fe2 is preceding or contains fe1 then, fe1 is after fe2\n  if (pos & precedingOrContains) {\n    return 1;\n  }\n\n  // if fe2 is following or contained by fe1, then fe1 is before fe2\n  return -1;\n}\n\n/**\n * Like `Element.prototype.toggleAttribute`. This either toggles an attribute\n * on by adding an attribute with an empty value, or toggles it off by removing\n * the attribute. This does not mutate the element if the new state matches\n * the existing state.\n * @param {!Element} element An element to toggle the attribute for.\n * @param {string} name The name of the attribute.\n * @param {boolean=} forced Whether the attribute should be forced on/off. If\n *    not specified, it will be toggled from the current state.\n * @return {boolean} Whether or not the element now has the attribute.\n */\nexport function toggleAttribute(element, name, forced) {\n  const hasAttribute = element.hasAttribute(name);\n  const enabled = forced !== undefined ? forced : !hasAttribute;\n\n  if (enabled !== hasAttribute) {\n    if (enabled) {\n      element.setAttribute(name, '');\n    } else {\n      element.removeAttribute(name);\n    }\n  }\n\n  return enabled;\n}\n\n/**\n * Parses a string as a boolean value using the expanded rules for DOM boolean\n * attributes:\n * - a `null` or `undefined` returns `null`;\n * - an empty string returns `true`;\n * - a \"false\" string returns `false`;\n * - otherwise, `true` is returned.\n *\n * @param {?string|undefined} s\n * @return {boolean|undefined}\n */\nexport function parseBooleanAttribute(s) {\n  return s == null ? undefined : s !== 'false';\n}\n\n/**\n * @param {!Window} win\n * @return {number} The width of the vertical scrollbar, in pixels.\n */\nexport function getVerticalScrollbarWidth(win) {\n  const {documentElement} = win.document;\n  const windowWidth = win./*OK*/ innerWidth;\n  const documentWidth = documentElement./*OK*/ clientWidth;\n  return windowWidth - documentWidth;\n}\n\n/**\n * Dispatches a custom event.\n *\n * @param {!Node} node\n * @param {string} name\n * @param {!Object=} opt_data Event data.\n * @param {!CustomEventOptionsDef=} opt_options\n */\nexport function dispatchCustomEvent(node, name, opt_data, opt_options) {\n  const data = opt_data || {};\n  // Constructors of events need to come from the correct window. Sigh.\n  const event = node.ownerDocument.createEvent('Event');\n\n  // Technically .data is not a property of Event.\n  event.data = data;\n\n  const {bubbles, cancelable} = opt_options || DEFAULT_CUSTOM_EVENT_OPTIONS;\n  event.initEvent(name, bubbles, cancelable);\n  node.dispatchEvent(event);\n}\n\n/**\n * Ensures the child is contained by the parent, but not the parent itself.\n *\n * @param {!Node} parent\n * @param {!Node} child\n * @return {boolean}\n */\nexport function containsNotSelf(parent, child) {\n  return child !== parent && parent.contains(child);\n}\n\n/**\n * Helper method to get the json config from an element <script> tag\n * @param {!Element} element\n * @return {?JsonObject}\n * @throws {!Error} If element does not have exactly one <script> child\n * with type=\"application/json\", or if the <script> contents are not valid JSON.\n */\nexport function getChildJsonConfig(element) {\n  const scripts = childElementsByTag(element, 'script');\n  const {length} = scripts;\n  if (length !== 1) {\n    throw new Error(`Found ${length} <script> children. Expected 1.`);\n  }\n\n  const script = scripts[0];\n  if (!isJsonScriptTag(script)) {\n    throw new Error('<script> child must have type=\"application/json\"');\n  }\n\n  try {\n    return parseJson(script.textContent);\n  } catch {\n    throw new Error('Failed to parse <script> contents. Is it valid JSON?');\n  }\n}\n", "/**\n * Some exceptions (DOMException, namely) have read-only message.\n * @param {!Error} error\n * @return {!Error}\n */\nexport function duplicateErrorIfNecessary(error) {\n  const messageProperty = Object.getOwnPropertyDescriptor(error, 'message');\n  if (messageProperty?.writable) {\n    return error;\n  }\n\n  const {message, stack} = error;\n  const e = new Error(message);\n  // Copy all the extraneous things we attach.\n  for (const prop in error) {\n    e[prop] = error[prop];\n  }\n  // Ensure these are copied.\n  e.stack = stack;\n  return e;\n}\n\n/**\n * Creates an error object.\n * @param {...*} var_args\n * @return {!Error}\n */\nexport function createError(var_args) {\n  let error = null;\n  let message = '';\n  for (const arg of arguments) {\n    if (arg instanceof Error && !error) {\n      error = duplicateErrorIfNecessary(arg);\n    } else {\n      if (message) {\n        message += ' ';\n      }\n      message += arg;\n    }\n  }\n\n  if (!error) {\n    error = new Error(message);\n  } else if (message) {\n    error.message = message + ': ' + error.message;\n  }\n  return error;\n}\n\n/**\n * Reports an error, if the global error reporting function is defined.\n * @param {!Error} error\n */\nfunction maybeReportError(error) {\n  self.__AMP_REPORT_ERROR?.(error);\n}\n\n/**\n * Constructs and throws an error without terminating the current context. This\n * preserves whether the original error designation is a user error or a dev\n * error.\n * @param {...*} var_args\n */\nexport function rethrowAsync(var_args) {\n  const error = createError.apply(null, arguments);\n  setTimeout(() => {\n    // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n    // It may not exist for Bento components without the runtime.\n    maybeReportError(error);\n    throw error;\n  });\n}\n\n/**\n * Executes the provided callback in a try/catch and rethrows any errors\n * asynchronously.\n *\n * @param {function(S):T} callback\n * @param {S} args\n * @return {T}\n * @template T\n * @template S\n */\nexport function tryCallback(callback, ...args) {\n  try {\n    return callback.apply(null, args);\n  } catch (e) {\n    rethrowAsync(e);\n  }\n}\n\n/**\n * Creates an error object with its expected property set to true.\n * @param {...*} var_args\n * @return {!Error}\n */\nexport function createExpectedError(var_args) {\n  const error = createError.apply(null, arguments);\n  error.expected = true;\n  return error;\n}\n\n/**\n * Reports an error message.\n * @param {string} tag\n * @param {...*} args\n */\nexport function devError(tag, ...args) {\n  const error = createError.apply(null, args);\n  // TODO(rcebulko): Determine if/how this Error#name property is used.\n  error.name = tag || error.name;\n  maybeReportError(error);\n}\n\n/**\n * Reports an error message and marks with an expected property. If the\n * logging is disabled, the error is rethrown asynchronously.\n * @param {string} unusedTag\n * @param {...*} args\n */\nexport function devExpectedError(unusedTag, ...args) {\n  maybeReportError(createExpectedError.apply(null, args));\n}\n", "// Note: loaded by 3p system. Cannot rely on babel polyfills.\nimport {devAssert} from '#core/assert';\nimport {devError} from '#core/error';\nimport {map} from '#core/types/object';\n\n/** @type {Object<string, string>} */\nlet propertyNameCache;\n\n/** @const {!Array<string>} */\nconst vendorPrefixes = ['Webkit', 'webkit', 'Moz', 'moz', 'ms', 'O', 'o'];\n\nconst DISPLAY_STYLE_MESSAGE =\n  '`display` style detected. You must use toggle instead.';\n\nconst EMPTY_CSS_DECLARATION = /** @type {!CSSStyleDeclaration} */ ({\n  'getPropertyPriority': () => '',\n  'getPropertyValue': () => '',\n});\n\n/**\n * @param {string} camelCase camel cased string\n * @return {string} title cased string\n */\nexport function camelCaseToTitleCase(camelCase) {\n  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n}\n\n/**\n  Checks the style if a prefixed version of a property exists and returns\n * it or returns an empty string.\n * @private\n * @param {!Object} style\n * @param {string} titleCase the title case version of a css property name\n * @return {string} the prefixed property name or null.\n */\nfunction getVendorJsPropertyName_(style, titleCase) {\n  for (let i = 0; i < vendorPrefixes.length; i++) {\n    const propertyName = vendorPrefixes[i] + titleCase;\n    if (style[propertyName] !== undefined) {\n      return propertyName;\n    }\n  }\n  return '';\n}\n\n/**\n * Returns the possibly prefixed JavaScript property name of a style property\n * (ex. WebkitTransitionDuration) given a camelCase'd version of the property\n * (ex. transitionDuration).\n * @param {!Object} style\n * @param {string} camelCase the camel cased version of a css property name\n * @param {boolean=} opt_bypassCache bypass the memoized cache of property\n *   mapping\n * @return {string}\n */\nexport function getVendorJsPropertyName(style, camelCase, opt_bypassCache) {\n  if (isVar(camelCase)) {\n    // CSS vars are returned as is.\n    return camelCase;\n  }\n  if (!propertyNameCache) {\n    propertyNameCache = map();\n  }\n  let propertyName = propertyNameCache[camelCase];\n  if (!propertyName || opt_bypassCache) {\n    propertyName = camelCase;\n    if (style[camelCase] === undefined) {\n      const titleCase = camelCaseToTitleCase(camelCase);\n      const prefixedPropertyName = getVendorJsPropertyName_(style, titleCase);\n\n      if (style[prefixedPropertyName] !== undefined) {\n        propertyName = prefixedPropertyName;\n      }\n    }\n    if (!opt_bypassCache) {\n      propertyNameCache[camelCase] = propertyName;\n    }\n  }\n  return propertyName;\n}\n\n/**\n * Sets the CSS styles of the specified element with !important. The styles\n * are specified as a map from CSS property names to their values.\n * @param {!Element} element\n * @param {!Object<string, *>} styles\n */\nexport function setImportantStyles(element, styles) {\n  const {style} = element;\n  for (const k in styles) {\n    style.setProperty(\n      getVendorJsPropertyName(style, k),\n      String(styles[k]),\n      'important'\n    );\n  }\n}\n\n/**\n * Sets the CSS style of the specified element with optional units, e.g. \"px\".\n * @param {?Element} element\n * @param {string} property\n * @param {*} value\n * @param {string=} opt_units\n * @param {boolean=} opt_bypassCache\n */\nexport function setStyle(element, property, value, opt_units, opt_bypassCache) {\n  const propertyName = getVendorJsPropertyName(\n    element.style,\n    property,\n    opt_bypassCache\n  );\n  if (!propertyName) {\n    return;\n  }\n  const styleValue = /** @type {string} */ (\n    opt_units ? value + opt_units : value\n  );\n  if (isVar(propertyName)) {\n    element.style.setProperty(propertyName, styleValue);\n  } else {\n    element.style[propertyName] = styleValue;\n  }\n}\n\n/**\n * Returns the value of the CSS style of the specified element.\n * @param {!Element} element\n * @param {string} property\n * @param {boolean=} opt_bypassCache\n * @return {*}\n */\nexport function getStyle(element, property, opt_bypassCache) {\n  const propertyName = getVendorJsPropertyName(\n    element.style,\n    property,\n    opt_bypassCache\n  );\n  if (!propertyName) {\n    return undefined;\n  }\n  if (isVar(propertyName)) {\n    return element.style.getPropertyValue(propertyName);\n  }\n  return element.style[propertyName];\n}\n\n/**\n * Sets the CSS styles of the specified element. The styles\n * a specified as a map from CSS property names to their values.\n * @param {!Element} element\n * @param {!Object<string, *>} styles\n */\nexport function setStyles(element, styles) {\n  for (const k in styles) {\n    setStyle(element, k, styles[k]);\n  }\n}\n\n/**\n * Sets the initial display style of an element. This is a last resort. If you\n * can set the initial display using CSS, YOU MUST.\n * DO NOT USE THIS TO ARBITRARILY SET THE DISPLAY STYLE AFTER INITIAL SETUP.\n *\n * @param {!Element} el\n * @param {string} value\n */\nexport function setInitialDisplay(el, value) {\n  const {style} = el;\n  devAssert(\n    value !== '' && value !== 'none',\n    'Initial display value must not be \"none\". Use toggle instead.'\n  );\n  devAssert(\n    !style['display'],\n    'setInitialDisplay MUST NOT be used for ' +\n      'resetting the display style. If you are looking for display:none ' +\n      'toggling, use toggle instead.'\n  );\n  style['display'] = value;\n}\n\n/**\n * Shows or hides the specified element.\n * @param {!Element} element\n * @param {boolean=} opt_display\n */\nexport function toggle(element, opt_display) {\n  if (opt_display === undefined) {\n    opt_display = element.hasAttribute('hidden');\n  }\n  if (opt_display) {\n    element.removeAttribute('hidden');\n  } else {\n    element.setAttribute('hidden', '');\n  }\n}\n\n/**\n * Returns a pixel value.\n * @param {number} value\n * @return {string}\n */\nexport function px(value) {\n  return `${value}px`;\n}\n\n/**\n * Returns a degree value.\n * @param {number} value\n * @return {string}\n */\nexport function deg(value) {\n  return `${value}deg`;\n}\n\n/**\n * Coerces a number into a string with units.\n * @param {number|string} value\n * @param {function(number):string} fn\n * @return {string}\n */\nfunction units(value, fn) {\n  return typeof value == 'number' ? fn(value) : value;\n}\n\n/**\n * Returns a \"translateX\" for CSS \"transform\" property.\n * @param {number|string} value\n * @return {string}\n */\nexport function translateX(value) {\n  return `translateX(${units(value, px)})`;\n}\n\n/**\n * Returns a \"translateX\" for CSS \"transform\" property.\n * @param {number|string} x\n * @param {(number|string|null)=} opt_y\n * @return {string}\n */\nexport function translate(x, opt_y) {\n  return opt_y === undefined || opt_y === null\n    ? `translate(${units(x, px)})`\n    : `translate(${units(x, px)}, ${units(opt_y, px)})`;\n}\n\n/**\n * Returns a \"scale\" for CSS \"transform\" property.\n * @param {number|string} value\n * @return {string}\n */\nexport function scale(value) {\n  return `scale(${value})`;\n}\n\n/**\n * Returns a \"rotate\" for CSS \"transform\" property.\n * @param {number|string} value\n * @return {string}\n */\nexport function rotate(value) {\n  return `rotate(${units(value, deg)})`;\n}\n\n/**\n * Remove alpha value from a rgba color value.\n * Return the new color property with alpha equals if has the alpha value.\n * Caller needs to make sure the input color value is a valid rgba/rgb value\n * @param {string} rgbaColor\n * @return {string}\n */\nexport function removeAlphaFromColor(rgbaColor) {\n  return rgbaColor.replace(\n    /\\(([^,]+),([^,]+),([^,)]+),[^)]+\\)/g,\n    '($1,$2,$3, 1)'\n  );\n}\n\n/**\n * Gets the computed style of the element. The helper is necessary to enforce\n * the possible `null` value returned by a buggy Firefox.\n *\n * @param {!Window} win\n * @param {!Element} el\n * @return {!CSSStyleDeclaration}\n */\nexport function computedStyle(win, el) {\n  const style = /** @type {?CSSStyleDeclaration} */ (win.getComputedStyle(el));\n  return style || EMPTY_CSS_DECLARATION;\n}\n\n/**\n * Resets styles that were set dynamically (i.e. inline)\n * @param {!Element} element\n * @param {!Array<string>} properties\n */\nexport function resetStyles(element, properties) {\n  for (let i = 0; i < properties.length; i++) {\n    setStyle(element, properties[i], null);\n  }\n}\n\n/**\n * Propagates the object-fit/position element attributes as styles.\n * @param {!Element} fromEl ie: amp-img\n * @param {!Element} toEl ie: the img within amp-img\n */\nexport function propagateObjectFitStyles(fromEl, toEl) {\n  if (fromEl.hasAttribute('object-fit')) {\n    setStyle(toEl, 'object-fit', fromEl.getAttribute('object-fit'));\n  }\n\n  if (fromEl.hasAttribute('object-position')) {\n    setStyle(toEl, 'object-position', fromEl.getAttribute('object-position'));\n  }\n}\n\n/**\n * @param {string} property\n * @return {boolean}\n */\nfunction isVar(property) {\n  return property.startsWith('--');\n}\n\n/**\n * Asserts that the style is not the `display` style.\n * This is the only possible way to pass a dynamic style to setStyle.\n *\n * If you wish to set `display`, use the `toggle` helper instead. This is so\n * changes to display can trigger necessary updates. See #17475.\n *\n * @param {string} style\n * @return {string}\n */\nexport function assertNotDisplay(style) {\n  // TODO(rcebulko): This calls itself an assert, but doesn't throw an error.\n  // Should it throw sync? If so, this/below can reduce to\n  // `return devAssert(style == 'display', DISPLAY_STYLE_MESSAGE);`\n  if (style === 'display') {\n    devError('STYLE', DISPLAY_STYLE_MESSAGE);\n  }\n  return style;\n}\n\n/**\n * Asserts that the styles does not contain the `display` style.\n * This is the only possible way to pass a dynamic styles object to setStyles\n * and setImportantStyles.\n *\n * If you wish to set `display`, use the `toggle` helper instead. This is so\n * changes to display can trigger necessary updates. See #17475.\n *\n * @param {!Object<string, *>} styles\n * @return {!Object<string, *>}\n */\nexport function assertDoesNotContainDisplay(styles) {\n  if ('display' in styles) {\n    devError('STYLE', DISPLAY_STYLE_MESSAGE);\n  }\n  return styles;\n}\n", "/**\n * Allows for runtime configuration. Internally, the runtime should\n * use the src/config.js module for various constants. We can use the\n * AMP_CONFIG global to translate user-defined configurations to this\n * module.\n * @type {!Object<string, string>}\n */\nconst env = self.AMP_CONFIG || {};\n\nconst thirdPartyFrameRegex =\n  (typeof env['thirdPartyFrameRegex'] == 'string'\n    ? new RegExp(env['thirdPartyFrameRegex'])\n    : env['thirdPartyFrameRegex']) || /^d-\\d+\\.ampproject\\.net$/;\n\nconst cdnProxyRegex =\n  (typeof env['cdnProxyRegex'] == 'string'\n    ? new RegExp(env['cdnProxyRegex'])\n    : env['cdnProxyRegex']) ||\n  /^https:\\/\\/([a-zA-Z0-9_-]+\\.)?cdn\\.ampproject\\.org$/;\n\n/**\n * Check for a custom URL definition in special <meta> tags. Note that this does\n * not allow for distinct custom URLs in AmpDocShadow instances. The shell is\n * allowed to define one set of custom URLs via AMP_CONFIG (recommended) or by\n * including <meta> tags in the shell <head>. Those custom URLs then apply to\n * all AMP documents loaded in the shell.\n * @param {string} name\n * @return {?string}\n * @private\n */\nfunction getMetaUrl(name) {\n  // Avoid exceptions in unit tests\n  if (!self.document || !self.document.head) {\n    return null;\n  }\n\n  // Disallow on proxy origins\n  if (self.location && cdnProxyRegex.test(self.location.origin)) {\n    return null;\n  }\n\n  const metaEl = self.document.head./*OK*/ querySelector(\n    `meta[name=\"${name}\"]`\n  );\n  return (metaEl && metaEl.getAttribute('content')) || null;\n}\n\n/**\n * @typedef {{\n *   thirdParty: string,\n *   thirdPartyFrameHost: string,\n *   thirdPartyFrameRegex: !RegExp,\n *   cdn: string,\n *   cdnProxyRegex: !RegExp,\n *   localhostRegex: !RegExp,\n *   errorReporting: string,\n *   betaErrorReporting: string,\n *   localDev: boolean,\n *   trustedViewerHosts: !Array<!RegExp>,\n *   geoApi: ?string,\n * }}\n */\nexport const urls = {\n  thirdParty: env['thirdPartyUrl'] || 'https://3p.ampproject.net',\n  thirdPartyFrameHost: env['thirdPartyFrameHost'] || 'ampproject.net',\n  thirdPartyFrameRegex,\n  cdn:\n    env['cdnUrl'] || getMetaUrl('runtime-host') || 'https://cdn.ampproject.org',\n  /* Note that cdnProxyRegex is only ever checked against origins\n   * (proto://host[:port]) so does not need to consider path\n   */\n  cdnProxyRegex,\n  localhostRegex: /^https?:\\/\\/localhost(:\\d+)?$/,\n  errorReporting:\n    env['errorReportingUrl'] ||\n    'https://us-central1-amp-error-reporting.cloudfunctions.net/r',\n  betaErrorReporting:\n    env['betaErrorReportingUrl'] ||\n    'https://us-central1-amp-error-reporting.cloudfunctions.net/r-beta',\n  localDev: env['localDev'] || false,\n  /**\n   * These domains are trusted with more sensitive viewer operations such as\n   * propagating the referrer. If you believe your domain should be here,\n   * file the issue on GitHub to discuss. The process will be similar\n   * (but somewhat more stringent) to the one described in the [3p/README.md](\n   * https://github.com/ampproject/amphtml/blob/main/3p/README.md)\n   *\n   * {!Array<!RegExp>}\n   */\n  trustedViewerHosts: [\n    /(^|\\.)google\\.(com?|[a-z]{2}|com?\\.[a-z]{2}|cat)$/,\n    /(^|\\.)gmail\\.(com|dev)$/,\n  ],\n  // Optional fallback API if amp-geo is left unpatched\n  geoApi: env['geoApiUrl'] || getMetaUrl('amp-geo-api'),\n};\n\nexport const config = {\n  urls,\n};\n", "import {map} from '#core/types/object';\n\nconst QUERY_STRING_REGEX = /(?:^[#?]?|&)([^=&]+)(?:=([^&]*))?/g;\n\n/**\n * Tries to decode a URI component, falling back to opt_fallback (or an empty\n * string)\n *\n * @param {string} component\n * @param {string=} fallback\n * @return {string}\n */\nexport function tryDecodeUriComponent(component, fallback = '') {\n  try {\n    return decodeURIComponent(component);\n  } catch (e) {\n    return fallback;\n  }\n}\n\n/**\n * Parses the query string of an URL. This method returns a simple key/value\n * map. If there are duplicate keys the latest value is returned.\n *\n * @param {string} queryString\n * @return {!JsonObject}\n */\nexport function parseQueryString(queryString) {\n  const params = map();\n  if (!queryString) {\n    return params;\n  }\n\n  let match;\n  while ((match = QUERY_STRING_REGEX.exec(queryString))) {\n    const name = tryDecodeUriComponent(match[1], match[1]);\n    const value = match[2]\n      ? tryDecodeUriComponent(match[2].replace(/\\+/g, ' '), match[2])\n      : '';\n    params[name] = value;\n  }\n  return params;\n}\n\n/**\n * Parses the query # params.\n * @param {!Window=} opt_win\n * @return {!JsonObject}\n */\nexport function getHashParams(opt_win) {\n  const {location} = opt_win || self;\n  // location.originalHash is set by the viewer when it removes the fragment\n  // from the URL.\n  return parseQueryString(location['originalHash'] || location.hash);\n}\n", "import * as coreMode from '#core/mode';\nimport {getHashParams} from '#core/types/string/url';\n\n/**\n * @typedef {{\n *   localDev: boolean,\n *   development: boolean,\n *   esm: boolean,\n *   test: boolean,\n *   rtvVersion: string,\n *   runtime: (null|string|undefined),\n *   a4aId: (null|string|undefined)\n * }}\n */\nexport let ModeDef;\n\n/**\n * `rtvVersion` is the prefixed version we serve off of the cdn.\n * The prefix denotes canary(00) or prod(01) or an experiment version ( > 01).\n * @type {string}\n */\nlet rtvVersion = '';\n\n/**\n * Provides info about the current app.\n * @param {?Window=} opt_win\n * @return {!ModeDef}\n */\nexport function getMode(opt_win) {\n  const win = opt_win || self;\n  if (win.__AMP_MODE) {\n    return win.__AMP_MODE;\n  }\n  return (win.__AMP_MODE = getMode_(win));\n}\n\n/**\n * Provides info about the current app.\n * @param {!Window} win\n * @return {!ModeDef}\n */\nfunction getMode_(win) {\n  const hashParams = getHashParams(win);\n\n  // The `minified`, `test` and `localDev` properties are replaced\n  // as boolean literals when we run `amp dist` without the `--fortesting`\n  // flags. This improved DCE on the production file we deploy as the code\n  // paths for localhost/testing/development are eliminated.\n  return {\n    localDev: coreMode.isLocalDev(win),\n    development: isModeDevelopment(win, hashParams),\n    esm: coreMode.isEsm(),\n    test: coreMode.isTest(win),\n    rtvVersion: getRtvVersion(win),\n  };\n}\n\n/**\n * Retrieve the `rtvVersion` which will have a numeric prefix\n * denoting canary/prod/experiment (unless `isLocalDev` is true).\n *\n * @param {!Window} win\n * @return {string}\n */\nfunction getRtvVersion(win) {\n  // Ignore memoized copy during testing to allow override.\n  if (!rtvVersion || coreMode.isTest(win)) {\n    // Currently `internalRuntimeVersion` and thus `mode.version` contain only\n    // major version. The full version however must also carry the minor version.\n    // We will default to production default `01` minor version for now.\n    // TODO(erwinmombay): decide whether internalRuntimeVersion should contain\n    // minor version.\n    rtvVersion = win.AMP_CONFIG?.v || `01${coreMode.version()}`;\n  }\n  return rtvVersion;\n}\n\n/**\n * Triggers validation or enable pub level logging. Validation can be\n * bypassed via #validate=0.\n * Note that AMP_DEV_MODE flag is used for testing purposes.\n * @param {!Window} win\n * @param {!JsonObject=} opt_hashParams\n * @return {boolean}\n */\nexport function isModeDevelopment(win, opt_hashParams) {\n  const devModes = ['1', 'actions', 'amp', 'amp4ads', 'amp4email'];\n  const devParam = opt_hashParams || getHashParams(win);\n  return devModes.includes(devParam['development']) || !!win.AMP_DEV_MODE;\n}\n\n/**\n * @param {!Window} win\n * @return {string}\n * @visibleForTesting\n */\nexport function getRtvVersionForTesting(win) {\n  return getRtvVersion(win);\n}\n\n/** @visibleForTesting */\nexport function resetRtvVersionForTesting() {\n  rtvVersion = '';\n}\n", "import * as mode from '#core/mode';\n\nimport {urls} from '../config';\nimport {getMode} from '../mode';\n\nconst CUSTOM_TEMPLATES = ['amp-mustache'];\nconst LATEST_VERSION = 'latest';\n\n/**\n * Calculate the base url for any scripts.\n * @param {!Location} location The window's location\n * @param {boolean=} opt_isLocalDev\n * @return {string}\n */\nexport function calculateScriptBaseUrl(location, opt_isLocalDev) {\n  if (opt_isLocalDev) {\n    let prefix = `${location.protocol}//${location.host}`;\n    if (\n      location.protocol == 'about:' ||\n      location.protocol == 'blob:' ||\n      location.protocol == 'data:'\n    ) {\n      prefix = '';\n    }\n    return `${prefix}/dist`;\n  }\n  return urls.cdn;\n}\n\n/**\n * Calculate script url for an extension.\n * @param {!Location} location The window's location\n * @param {string} extensionId\n * @param {string} version\n * @param {boolean=} opt_isLocalDev\n * @return {string}\n */\nexport function calculateExtensionScriptUrl(\n  location,\n  extensionId,\n  version,\n  opt_isLocalDev\n) {\n  const fileExtension = mode.isEsm() ? '.mjs' : '.js';\n  const base = calculateScriptBaseUrl(location, opt_isLocalDev);\n  const rtv = getMode().rtvVersion;\n  const extensionVersion = version ? '-' + version : '';\n  return `${base}/rtv/${rtv}/v0/${extensionId}${extensionVersion}${fileExtension}`;\n}\n\n/**\n * Calculate script url for an entry point.\n * If `opt_rtv` is true, returns the URL matching the current RTV.\n * @param {!Location} location The window's location\n * @param {string} entryPoint\n * @param {boolean=} isLocalDev\n * @param {boolean=} opt_rtv\n * @return {string}\n */\nexport function calculateEntryPointScriptUrl(\n  location,\n  entryPoint,\n  isLocalDev,\n  opt_rtv\n) {\n  const fileExtension = mode.isEsm() ? '.mjs' : '.js';\n  const base = calculateScriptBaseUrl(location, isLocalDev);\n  if (isLocalDev) {\n    return `${base}/${entryPoint}${fileExtension}`;\n  }\n  if (opt_rtv) {\n    return `${base}/rtv/${getMode().rtvVersion}/${entryPoint}${fileExtension}`;\n  }\n  return `${base}/${entryPoint}${fileExtension}`;\n}\n\n/**\n * Parse the extension version from a given script URL.\n * @param {string} scriptUrl\n * @return {?{extensionId: string, extensionVersion: string}}\n */\nexport function parseExtensionUrl(scriptUrl) {\n  if (!scriptUrl) {\n    return null;\n  }\n  // Note that the \"(\\.max)?\" group only applies to local dev.\n  const matches = scriptUrl.match(\n    /^(.*)\\/(.*)-([0-9.]+|latest)(\\.max)?\\.(?:js|mjs)$/i\n  );\n  const extensionId = matches ? matches[2] : undefined;\n  const extensionVersion = matches ? matches[3] : undefined;\n  if (!extensionId || !extensionVersion) {\n    return null;\n  }\n  return {extensionId, extensionVersion};\n}\n\n/**\n * Create the missing amp extension HTML script element.\n * @param {!Window} win\n * @param {string} extensionId\n * @param {string} version\n * @return {!Element} Script object\n */\nexport function createExtensionScript(win, extensionId, version) {\n  const scriptElement = win.document.createElement('script');\n  scriptElement.async = true;\n  if (isIntermediateExtension(extensionId)) {\n    version = '';\n  } else {\n    scriptElement.setAttribute(\n      CUSTOM_TEMPLATES.indexOf(extensionId) >= 0\n        ? 'custom-template'\n        : 'custom-element',\n      extensionId\n    );\n  }\n  scriptElement.setAttribute('data-script', extensionId);\n  scriptElement.setAttribute('i-amphtml-inserted', '');\n  if (mode.isEsm()) {\n    scriptElement.setAttribute('type', 'module');\n  }\n\n  // Propagate nonce to all generated script tags.\n  const currentScript = win.document.head.querySelector('script[nonce]');\n  if (currentScript) {\n    scriptElement.setAttribute('nonce', currentScript.getAttribute('nonce'));\n  }\n\n  // Allow error information to be collected\n  // https://github.com/ampproject/amphtml/issues/7353\n  scriptElement.setAttribute('crossorigin', 'anonymous');\n  let loc = win.location;\n  if (getMode(win).test && win.testLocation) {\n    loc = win.testLocation;\n  }\n  const scriptSrc = calculateExtensionScriptUrl(\n    loc,\n    extensionId,\n    version,\n    getMode(win).localDev\n  );\n  scriptElement.src = scriptSrc;\n  return scriptElement;\n}\n\n/**\n * Returns the extension <script> element and attribute for the given\n * extension ID, if it exists. Otherwise, returns null.\n * @param {!Window} win\n * @param {string} extensionId\n * @param {string} version\n * @param {boolean} latest\n * @param {boolean=} includeInserted If true, includes script elements that\n *   are inserted by the runtime dynamically. Default is true.\n * @return {!Array<!Element>}\n */\nexport function getExtensionScripts(\n  win,\n  extensionId,\n  version,\n  latest,\n  includeInserted = true\n) {\n  // Always ignore <script> elements that have a mismatched RTV.\n  const modifier =\n    ':not([i-amphtml-loaded-new-version])' +\n    (includeInserted ? '' : ':not([i-amphtml-inserted])');\n  // We have to match against \"src\" because a few extensions, such as\n  // \"amp-viewer-integration\", do not have \"custom-element\" attribute.\n  const matches = win.document.head./*OK*/ querySelectorAll(\n    `script[src*=\"/${extensionId}-\"]${modifier}`\n  );\n  const filtered = [];\n  for (let i = 0; i < matches.length; i++) {\n    const match = matches[i];\n    const urlParts = parseExtensionUrl(match.src);\n    if (!urlParts) {\n      continue;\n    }\n    const {\n      extensionId: scriptExtensionId,\n      extensionVersion: scriptExtensionVersion,\n    } = urlParts;\n    if (\n      scriptExtensionId == extensionId &&\n      (isIntermediateExtension(extensionId) ||\n        scriptExtensionVersion == version ||\n        (scriptExtensionVersion == LATEST_VERSION && latest))\n    ) {\n      filtered.push(match);\n    }\n  }\n  return filtered;\n}\n\n/**\n * Get list of all the extension JS files.\n * @param {HTMLHeadElement|Element|ShadowRoot|Document} head\n * @return {!Array<{script: HTMLScriptElement, extensionId: string, extensionVersion: string}>}\n */\nexport function extensionScriptsInNode(head) {\n  // ampdoc.getHeadNode() can return null.\n  if (!head) {\n    return [];\n  }\n  // Note: Some extensions don't have [custom-element] or [custom-template]\n  // e.g. amp-viewer-integration.\n  const list = head.querySelectorAll(\n    'script[custom-element],script[custom-template]'\n  );\n  const scripts = [];\n  for (let i = 0; i < list.length; i++) {\n    const script = list[i];\n    const extensionId =\n      script.getAttribute('custom-element') ||\n      script.getAttribute('custom-template');\n    const urlParts = parseExtensionUrl(script.src);\n    if (extensionId && urlParts) {\n      scripts.push({\n        script,\n        extensionId,\n        extensionVersion: urlParts.extensionVersion,\n      });\n    }\n  }\n  return scripts;\n}\n\n/**\n * Verifies that an extension script is present in head for\n * installation.\n * @param {!Window} win\n * @param {string} id\n * @param {string} version\n * @return {boolean}\n */\nexport function extensionScriptInNode(win, id, version) {\n  return extensionScriptsInNode(win.document.head).some(\n    ({extensionId, extensionVersion}) =>\n      id == extensionId && version == extensionVersion\n  );\n}\n\n/**\n * @param {string} extensionId\n * @return {boolean}\n */\nfunction isIntermediateExtension(extensionId) {\n  return extensionId.startsWith('_');\n}\n", "/** @fileoverview Helpers to wrap functions. */\n\n/**\n * Creates a function that is evaluated only once and returns the cached result\n * subsequently.\n *\n * Please note that `once` only takes the function definition into account,\n * so it will return the same cached value even when the arguments are\n * different.\n *\n * @param {function(...):T} fn\n * @return {function(...):T}\n * @template T\n */\nexport function once(fn) {\n  let evaluated = false;\n  let retValue = null;\n  let callback = fn;\n  return (...args) => {\n    if (!evaluated) {\n      retValue = callback.apply(self, args);\n      evaluated = true;\n      callback = null; // GC\n    }\n    return retValue;\n  };\n}\n\n/**\n * Wraps a given callback and applies a rate limit.\n * It throttles the calls so that no consequent calls have time interval\n * smaller than the given minimal interval.\n *\n * @param {!Window} win\n * @param {function(...T):R} callback\n * @param {number} minInterval the minimum time interval in millisecond\n * @return {function(...T)}\n * @template T\n * @template R\n */\nexport function throttle(win, callback, minInterval) {\n  let locker = 0;\n  let nextCallArgs = null;\n\n  /**\n   * @param {!Object} args\n   */\n  function fire(args) {\n    nextCallArgs = null;\n    // Lock the fire for minInterval milliseconds\n    locker = win.setTimeout(waiter, minInterval);\n\n    callback.apply(null, args);\n  }\n\n  /**\n   * Waiter function\n   */\n  function waiter() {\n    locker = 0;\n    // If during the period there're invocations queued up, fire once.\n    if (nextCallArgs) {\n      fire(nextCallArgs);\n    }\n  }\n\n  return function (...args) {\n    if (locker) {\n      nextCallArgs = args;\n    } else {\n      fire(args);\n    }\n  };\n}\n\n/**\n * Wraps a given callback and applies a wait timer, so that minInterval\n * milliseconds must pass since the last call before the callback is actually\n * invoked.\n *\n * @param {!Window} win\n * @param {function(...T):R} callback\n * @param {number} minInterval the minimum time interval in millisecond\n * @return {function(...T)}\n * @template T\n * @template R\n */\nexport function debounce(win, callback, minInterval) {\n  let locker = 0;\n  let timestamp = 0;\n  let nextCallArgs = null;\n\n  /**\n   * @param {?Array} args\n   */\n  function fire(args) {\n    nextCallArgs = null;\n    callback.apply(null, args);\n  }\n\n  /**\n   * Wait function for debounce\n   */\n  function waiter() {\n    locker = 0;\n    const remaining = minInterval - (win.Date.now() - timestamp);\n    if (remaining > 0) {\n      locker = win.setTimeout(waiter, remaining);\n    } else {\n      fire(nextCallArgs);\n    }\n  }\n\n  return function (...args) {\n    timestamp = win.Date.now();\n    nextCallArgs = args;\n    if (!locker) {\n      locker = win.setTimeout(waiter, minInterval);\n    }\n  };\n}\n", "import * as assertions from '#core/assert/base';\nimport {\n  createError,\n  createExpectedError,\n  duplicateErrorIfNecessary,\n} from '#core/error';\nimport {\n  USER_ERROR_EMBED_SENTINEL,\n  USER_ERROR_SENTINEL,\n  elementStringOrPassThru,\n  isUserErrorMessage,\n  stripUserError,\n} from '#core/error/message-helpers';\nimport * as mode from '#core/mode';\nimport {isArray, isString} from '#core/types';\nimport {once} from '#core/types/function';\nimport {getHashParams} from '#core/types/string/url';\n\nimport {urls} from '../config';\nimport {getMode} from '../mode';\n\nconst noop = () => {};\n\n// These are exported here despite being defined elswhere to avoid updating\n// imports across many files for now.\nexport {USER_ERROR_SENTINEL, isUserErrorMessage};\n\n/**\n * Sets reportError function. Called from error-reporting.js to break cyclic\n * dependency.\n * @param {function(this:Window, Error, (?Element)=): ?|undefined} fn\n */\nexport function setReportError(fn) {\n  self.__AMP_REPORT_ERROR = fn;\n}\n\n/**\n * @enum {number}\n */\nexport const LogLevel = {\n  OFF: 0,\n  ERROR: 1,\n  WARN: 2,\n  INFO: 3,\n  FINE: 4,\n};\n\n/**\n * @type {!LogLevel|undefined}\n * @private\n */\nlet levelOverride_ = undefined;\n\n/**\n * @param {!LogLevel} level\n */\nexport function overrideLogLevel(level) {\n  levelOverride_ = level;\n}\n\n/**\n * Prefixes `internalRuntimeVersion` with the `01` channel signifier (for prod.) for\n * extracted message URLs.\n * (Specific channel is irrelevant: message tables are invariant on internal version.)\n * @return {string}\n */\nconst messageUrlRtv = () => `01${mode.version()}`;\n\n/**\n * Gets a URL to display a message on amp.dev.\n * @param {string} id\n * @param {!Array} interpolatedParts\n * @return {string}\n */\nconst externalMessageUrl = (id, interpolatedParts) =>\n  interpolatedParts.reduce(\n    (prefix, arg) => `${prefix}&s[]=${messageArgToEncodedComponent(arg)}`,\n    `https://log.amp.dev/?v=${messageUrlRtv()}&id=${encodeURIComponent(id)}`\n  );\n\n/**\n * URL to simple log messages table JSON file, which contains an Object<string, string>\n * which maps message id to full message template.\n * @return {string}\n */\nconst externalMessagesSimpleTableUrl = () =>\n  `${urls.cdn}/rtv/${messageUrlRtv()}/log-messages.simple.json`;\n\n/**\n * @param {*} arg\n * @return {string}\n */\nconst messageArgToEncodedComponent = (arg) =>\n  encodeURIComponent(String(elementStringOrPassThru(arg)));\n\n/**\n * @param {!Window=} opt_win\n * @return {number}\n */\nexport const logHashParam = (opt_win) =>\n  parseInt(getHashParams(opt_win)['log'], 10);\n\n/**\n * Logging class. Use of sentinel string instead of a boolean to check user/dev\n * errors because errors could be rethrown by some native code as a new error,\n * and only a message would survive. Also, some browser don\u2019t support a 5th\n * error object argument in window.onerror. List of supporting browser can be\n * found here:\n * https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html\n * @final\n * @private Visible for testing only.\n */\nexport class Log {\n  /**\n   * opt_suffix will be appended to error message to identify the type of the\n   * error message. We can't rely on the error object to pass along the type\n   * because some browsers do not have this param in its window.onerror API.\n   * See:\n   * https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html\n   *\n   * @param {!Window} win\n   * @param {function(number, boolean):!LogLevel} levelFunc\n   * @param {string=} opt_suffix\n   */\n  constructor(win, levelFunc, opt_suffix = '') {\n    /**\n     * In tests we use the main test window instead of the iframe where\n     * the tests runs because only the former is relayed to the console.\n     * @const {!Window}\n     */\n    this.win = getMode().test && win.__AMP_TEST_IFRAME ? win.parent : win;\n\n    /** @private @const {function(number, boolean):!LogLevel} */\n    this.levelFunc_ = levelFunc;\n\n    /** @private @const {!LogLevel} */\n    this.level_ = this.defaultLevel_();\n\n    /** @private @const {string} */\n    this.suffix_ = opt_suffix;\n\n    /** @private {?JsonObject} */\n    this.messages_ = null;\n\n    this.fetchExternalMessagesOnce_ = once(() => {\n      win\n        .fetch(externalMessagesSimpleTableUrl())\n        .then((response) => response.json(), noop)\n        .then((opt_messages) => {\n          if (opt_messages) {\n            this.messages_ = /** @type {!JsonObject} */ (opt_messages);\n          }\n        });\n    });\n\n    // This bound assertion function is capable of handling the format used when\n    // error/assertion messages are extracted. This logic hasn't yet been\n    // migrated to an AMP-independent form for use in core. This binding allows\n    // Log assertion helpers to maintain message-extraction capabilities until\n    // that logic can be moved to core.\n    this.boundAssertFn_ = /** @type {!assertions.AssertionFunctionDef} */ (\n      this.assert.bind(this)\n    );\n  }\n\n  /**\n   * @return {!LogLevel}\n   * @private\n   */\n  defaultLevel_() {\n    const {win} = this;\n    // No console - can't enable logging.\n    if (\n      !win.console?.log ||\n      // Logging has been explicitly disabled.\n      logHashParam(win) == 0\n    ) {\n      return LogLevel.OFF;\n    }\n\n    // Logging is enabled for tests directly.\n    if (getMode().test && win.ENABLE_LOG) {\n      return LogLevel.FINE;\n    }\n\n    // LocalDev by default allows INFO level, unless overriden by `#log`.\n    if (getMode().localDev) {\n      return LogLevel.INFO;\n    }\n\n    return this.defaultLevelWithFunc_();\n  }\n\n  /**\n   * @param {!Window=} opt_win provided for testing\n   * @return {!LogLevel}\n   * @private\n   */\n  defaultLevelWithFunc_(opt_win) {\n    // Delegate to the specific resolver.\n    return this.levelFunc_(logHashParam(opt_win), getMode().development);\n  }\n\n  /**\n   * @param {string} tag\n   * @param {!LogLevel} level\n   * @param {!Array} messages\n   * @return {boolean} true if a the message was logged\n   */\n  msg_(tag, level, messages) {\n    if (level > (levelOverride_ ?? this.level_)) {\n      return false;\n    }\n\n    const cs = this.win.console;\n    const fn =\n      {\n        [LogLevel.ERROR]: cs.error,\n        [LogLevel.INFO]: cs.info,\n        [LogLevel.WARN]: cs.warn,\n      }[level] ?? cs.log;\n\n    const args = this.maybeExpandMessageArgs_(messages);\n    // Prefix console message with \"[tag]\".\n    const prefix = `[${tag}]`;\n    if (isString(args[0])) {\n      // Prepend string to avoid breaking string substitutions e.g. %s.\n      args[0] = prefix + ' ' + args[0];\n    } else {\n      args.unshift(prefix);\n    }\n    fn.apply(cs, args);\n\n    return true;\n  }\n\n  /**\n   * Reports a fine-grained message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  fine(tag, ...args) {\n    this.msg_(tag, LogLevel.FINE, args);\n  }\n\n  /**\n   * Reports a informational message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  info(tag, ...args) {\n    this.msg_(tag, LogLevel.INFO, args);\n  }\n\n  /**\n   * Reports a warning message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  warn(tag, ...args) {\n    this.msg_(tag, LogLevel.WARN, args);\n  }\n\n  /**\n   * Reports an error message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  error(tag, ...args) {\n    if (!this.msg_(tag, LogLevel.ERROR, args)) {\n      const error = this.createError.apply(this, args);\n      error.name = tag || error.name;\n      self.__AMP_REPORT_ERROR?.(error);\n    }\n  }\n\n  /**\n   * Reports an error message and marks with an expected property. If the\n   * logging is disabled, the error is rethrown asynchronously.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  expectedError(tag, ...args) {\n    if (!this.msg_(tag, LogLevel.ERROR, args)) {\n      self.__AMP_REPORT_ERROR?.(this.createExpectedError.apply(this, args));\n    }\n  }\n\n  /**\n   * Creates an error object.\n   * @param {...*} var_args\n   * @return {!Error}\n   */\n  createError(var_args) {\n    return this.setErrorSuffix_(createError.apply(null, arguments));\n  }\n\n  /**\n   * Creates an error object with its expected property set to true.\n   * @param {...*} var_args\n   * @return {!Error}\n   */\n  createExpectedError(var_args) {\n    return this.setErrorSuffix_(createExpectedError.apply(null, arguments));\n  }\n\n  /**\n   * @param {!Error} error\n   * @return {!Error}\n   * @private\n   */\n  setErrorSuffix_(error) {\n    error = duplicateErrorIfNecessary(error);\n\n    if (this.suffix_) {\n      if (!error.message) {\n        error.message = this.suffix_;\n      } else if (error.message.indexOf(this.suffix_) == -1) {\n        error.message += this.suffix_;\n      }\n    } else if (isUserErrorMessage(error.message)) {\n      error.message = stripUserError(error.message);\n    }\n\n    return error;\n  }\n\n  /**\n   * @param {!Array} args\n   * @return {!Array}\n   * @private\n   */\n  maybeExpandMessageArgs_(args) {\n    return isArray(args[0])\n      ? this.expandMessageArgs_(/** @type {!Array} */ (args[0]))\n      : args;\n  }\n\n  /**\n   * Either redirects a pair of (errorId, ...args) to a URL where the full\n   * message is displayed, or displays it from a fetched table.\n   *\n   * This method is used by the output of the `transform-log-methods` babel\n   * plugin. It should not be used directly. Use the (*error|assert*|info|warn)\n   * methods instead.\n   *\n   * @param {!Array} parts\n   * @return {!Array}\n   * @private\n   */\n  expandMessageArgs_(parts) {\n    // First value should exist.\n    const id = parts.shift();\n    // Best effort fetch of message template table.\n    // Since this is async, the first few logs might be indirected to a URL even\n    // if in development mode. Message table is ~small so this should be a short\n    // gap.\n    if (getMode(this.win).development) {\n      this.fetchExternalMessagesOnce_();\n    }\n\n    return this.messages_?.[id]\n      ? [this.messages_[id]].concat(parts)\n      : [`More info at ${externalMessageUrl(id, parts)}`];\n  }\n\n  /**\n   * Throws an error if the first argument isn't trueish.\n   *\n   * Supports argument substitution into the message via %s placeholders.\n   *\n   * Throws an error object that has two extra properties:\n   * - associatedElement: This is the first element provided in the var args.\n   *   It can be used for improved display of error messages.\n   * - messageArray: The elements of the substituted message as non-stringified\n   *   elements in an array. When e.g. passed to console.error this yields\n   *   native displays of things like HTML elements.\n   *\n   * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n   *     not evaluate to true.\n   * @param {!Array|string=} opt_message The assertion message\n   * @param {...*} var_args Arguments substituted into %s in the message.\n   * @return {T} The value of shouldBeTrueish.\n   * @throws {!Error} When `value` is falsey.\n   * @template T\n   * @closurePrimitive {asserts.truthy}\n   */\n  assert(shouldBeTrueish, opt_message, var_args) {\n    if (isArray(opt_message)) {\n      return this.assert.apply(\n        this,\n        [shouldBeTrueish].concat(\n          this.expandMessageArgs_(/** @type {!Array} */ (opt_message))\n        )\n      );\n    }\n\n    return assertions.assert.apply(\n      null,\n      [this.suffix_].concat(Array.prototype.slice.call(arguments))\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't an Element\n   *\n   * Otherwise see `assert` for usage\n   *\n   * @param {*} shouldBeElement\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {!Element} The value of shouldBeTrueish.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertElement(shouldBeElement, opt_message) {\n    return assertions.assertElement(\n      this.boundAssertFn_,\n      shouldBeElement,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't a string. The string can\n   * be empty.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeString\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {string} The string value. Can be an empty string.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertString(shouldBeString, opt_message) {\n    return assertions.assertString(\n      this.boundAssertFn_,\n      shouldBeString,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't a number. The allowed values\n   * include `0` and `NaN`.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeNumber\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {number} The number value. The allowed values include `0`\n   *   and `NaN`.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertNumber(shouldBeNumber, opt_message) {\n    return assertions.assertNumber(\n      this.boundAssertFn_,\n      shouldBeNumber,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument is not an array.\n   * The array can be empty.\n   *\n   * @param {*} shouldBeArray\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {!Array} The array value\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertArray(shouldBeArray, opt_message) {\n    return assertions.assertArray(\n      this.boundAssertFn_,\n      shouldBeArray,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't a boolean.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeBoolean\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {boolean} The boolean value.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertBoolean(shouldBeBoolean, opt_message) {\n    return assertions.assertBoolean(\n      this.boundAssertFn_,\n      shouldBeBoolean,\n      opt_message\n    );\n  }\n}\n\n/**\n * Cache for logs. We do not use a Service since the service module depends\n * on Log and closure literally can't even.\n * @type {{user: ?Log, dev: ?Log, userForEmbed: ?Log}}\n */\nself.__AMP_LOG = self.__AMP_LOG || {\n  user: null,\n  dev: null,\n  userForEmbed: null,\n};\n\nconst logs = self.__AMP_LOG;\n\n/**\n * Eventually holds a constructor for Log objects. Lazily initialized, so we\n * can avoid ever referencing the real constructor except in JS binaries\n * that actually want to include the implementation.\n * @type {?typeof Log}\n */\nlet logConstructor = null;\n\n/**\n * Initializes log constructor.\n */\nexport function initLogConstructor() {\n  logConstructor = Log;\n  // Initialize instances for use. If a binary (an extension for example) that\n  // does not call `initLogConstructor` invokes `dev()` or `user()` earlier than\n  // the binary that does call `initLogConstructor` (amp.js), the extension will\n  // throw an error as that extension will never be able to initialize the log\n  // instances and we also don't want it to call `initLogConstructor` either\n  // (since that will cause the Log implementation to be bundled into that\n  // binary). So we must initialize the instances eagerly so that they are ready\n  // for use (stored globally) after the main binary calls `initLogConstructor`.\n  dev();\n  user();\n}\n\n/**\n * Resets log constructor for testing.\n */\nexport function resetLogConstructorForTesting() {\n  logConstructor = null;\n}\n\n/**\n * Calls the log constructor with a given level function and suffix.\n * @param {function(number, boolean):!LogLevel} levelFunc\n * @param {string=} opt_suffix\n * @return {!Log}\n */\nfunction callLogConstructor(levelFunc, opt_suffix) {\n  if (!logConstructor) {\n    throw new Error('failed to call initLogConstructor');\n  }\n  return new logConstructor(self, levelFunc, opt_suffix);\n}\n\n/**\n * Publisher level log.\n *\n * Enabled in the following conditions:\n *  1. Not disabled using `#log=0`.\n *  2. Development mode is enabled via `#development=1` or logging is explicitly\n *     enabled via `#log=D` where D >= 1.\n *  3. AMP.setLogLevel(D) is called, where D >= 1.\n *\n * @param {!Element=} opt_element\n * @return {!Log}\n */\nexport function user(opt_element) {\n  // logs.user must exist first to perform the logs.user.win check below\n  if (!logs.user) {\n    logs.user = getUserLogger(USER_ERROR_SENTINEL);\n  }\n\n  if (isFromEmbed(logs.user.win, opt_element)) {\n    return (\n      logs.userForEmbed ||\n      (logs.userForEmbed = getUserLogger(USER_ERROR_EMBED_SENTINEL))\n    );\n  }\n  return logs.user;\n}\n\n/**\n * Getter for user logger\n * @param {string=} suffix\n * @return {!Log}\n */\nfunction getUserLogger(suffix) {\n  return callLogConstructor(\n    (logNum, development) =>\n      development || logNum >= 1 ? LogLevel.FINE : LogLevel.WARN,\n    suffix\n  );\n}\n\n/**\n * AMP development log. Calls to `devLog().assert` and `dev.fine` are stripped\n * in the PROD binary. However, `devLog().assert` result is preserved in either\n * case.\n *\n * Enabled in the following conditions:\n *  1. Not disabled using `#log=0`.\n *  2. Logging is explicitly enabled via `#log=D`, where D >= 2.\n *  3. AMP.setLogLevel(D) is called, where D >= 2.\n *\n * @return {!Log}\n */\nexport function dev() {\n  return (\n    logs.dev ||\n    (logs.dev = callLogConstructor((logNum) =>\n      logNum >= 3 ? LogLevel.FINE : logNum >= 2 ? LogLevel.INFO : LogLevel.OFF\n    ))\n  );\n}\n\n/**\n * @param {!Window} win\n * @param {!Element=} opt_element\n * @return {boolean} isEmbed\n */\nfunction isFromEmbed(win, opt_element) {\n  return opt_element && opt_element.ownerDocument.defaultView != win;\n}\n\n/**\n * Throws an error if the first argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - associatedElement: This is the first element provided in the var args.\n *   It can be used for improved display of error messages.\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n *\n * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n *     not evaluate to true.\n * @param {!Array|string=} opt_message The assertion message\n * @param {*=} opt_1 Optional argument (Var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {T} The value of shouldBeTrueish.\n * @throws {!Error} When `shouldBeTrueish` is falsey.\n * @template T\n * @closurePrimitive {asserts.truthy}\n */\nexport function devAssert(\n  shouldBeTrueish,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  if (mode.isMinified()) {\n    return shouldBeTrueish;\n  }\n  if (self.__AMP_ASSERTION_CHECK) {\n    // This will never execute regardless, but will be included on unminified\n    // builds. It will be DCE'd away from minified builds, and so can be used to\n    // validate that Babel is properly removing dev assertions in minified\n    // builds.\n    console /*OK*/\n      .log('__devAssert_sentinel__');\n  }\n\n  return dev()./*Orig call*/ assert(\n    shouldBeTrueish,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n\n/**\n * Throws an error if the first argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - associatedElement: This is the first element provided in the var args.\n *   It can be used for improved display of error messages.\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n *\n * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n *     not evaluate to true.\n * @param {!Array|string=} opt_message The assertion message\n * @param {*=} opt_1 Optional argument (Var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {T} The value of shouldBeTrueish.\n * @throws {!Error} When `shouldBeTrueish` is falsey.\n * @template T\n * @closurePrimitive {asserts.truthy}\n */\nexport function userAssert(\n  shouldBeTrueish,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  return user()./*Orig call*/ assert(\n    shouldBeTrueish,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n", "/**\n * @fileoverview Registration and getter functions for AMP services.\n *\n * Invariant: Service getters never return null for registered services.\n */\n\nimport {Deferred} from '#core/data-structures/promise';\nimport {getWin} from '#core/window';\n\nimport {dev, devAssert} from '#utils/log';\n\n/**\n * Holds info about a service.\n * - obj: Actual service implementation when available.\n * - promise: Promise for the obj.\n * - resolve: Function to resolve the promise with the object.\n * - context: Argument for ctor, either a window or an ampdoc.\n * - ctor: Function that constructs and returns the service.\n * @typedef {{\n *   obj: (?Object),\n *   promise: (?Promise),\n *   resolve: (?function(!Object)),\n *   reject: (?function((*))),\n *   context: (?Window|?./service/ampdoc-impl.AmpDoc),\n *   ctor: (function(new:Object, !Window)|\n *          function(new:Object, !./service/ampdoc-impl.AmpDoc)),\n * }}\n */\nlet ServiceHolderDef;\n\n/**\n * This interface provides a `dispose` method that will be called by\n * runtime when a service needs to be disposed of.\n * @interface\n */\nexport class Disposable {\n  /**\n   * Instructs the service to release any resources it might be holding. Can\n   * be called only once in the lifecycle of a service.\n   */\n  dispose() {}\n}\n\n/**\n * Installs a service override on amp-doc level.\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {string} id\n * @param {!Object} service The service.\n */\nexport function installServiceInEmbedDoc(ampdoc, id, service) {\n  registerServiceInternal(\n    getAmpdocServiceHolder(ampdoc),\n    ampdoc,\n    id,\n    function () {\n      return service;\n    },\n    /* override */ true\n  );\n}\n\n/**\n * Installs a service override in the scope of an embedded window.\n * @param {!Window} embedWin\n * @param {string} id\n * @param {function(new:Object, !Window)} constructor\n */\nexport function registerServiceBuilderInEmbedWin(embedWin, id, constructor) {\n  registerServiceInternal(\n    embedWin,\n    embedWin,\n    id,\n    constructor,\n    /* override */ true\n  );\n}\n\n/**\n * Registers a service given a class to be used as implementation.\n * @param {!Window} win\n * @param {string} id of the service.\n * @param {function(new:Object, !Window)} constructor\n * @param {boolean=} opt_instantiate Whether to immediately create the service\n */\nexport function registerServiceBuilder(win, id, constructor, opt_instantiate) {\n  win = getTopWindow(win);\n  registerServiceInternal(win, win, id, constructor);\n  if (opt_instantiate) {\n    getServiceInternal(win, id);\n  }\n}\n\n/**\n * Returns a service and registers it given a class to be used as\n * implementation.\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @param {string} id of the service.\n * @param {function(new:Object, !./service/ampdoc-impl.AmpDoc)} constructor\n * @param {boolean=} opt_instantiate Whether to immediately create the service\n */\nexport function registerServiceBuilderForDoc(\n  nodeOrDoc,\n  id,\n  constructor,\n  opt_instantiate\n) {\n  const ampdoc = getAmpdoc(nodeOrDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  registerServiceInternal(holder, ampdoc, id, constructor);\n  if (opt_instantiate) {\n    getServiceInternal(holder, id);\n  }\n}\n\n/**\n * Reject a service promise.\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @param {string} id\n * @param {*} error\n */\nexport function rejectServicePromiseForDoc(nodeOrDoc, id, error) {\n  const ampdoc = getAmpdoc(nodeOrDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  rejectServicePromiseInternal(holder, id, error);\n}\n\n/**\n * Returns a service for the given id and window (a per-window singleton). Users\n * should typically wrap this as a special purpose function (e.g.\n * `Services.vsyncFor(win)`) for type safety and because the factory should not\n * be passed around.\n * @param {!Window} win\n * @param {string} id of the service.\n * @template T\n * @return {T}\n */\nexport function getService(win, id) {\n  win = getTopWindow(win);\n  return getServiceInternal(win, id);\n}\n\n/**\n * Returns a service for the given id and window (a per-window singleton). But\n * it looks in the immediate window scope, not the top-level window.\n * @param {!Window} win\n * @param {string} id of the service.\n * @template T\n * @return {T}\n */\nexport function getServiceInEmbedWin(win, id) {\n  return getServiceInternal(win, id);\n}\n\n/**\n * Returns a promise for a service for the given id and window. Also expects an\n * element that has the actual implementation. The promise resolves when the\n * implementation loaded. Users should typically wrap this as a special purpose\n * function (e.g. `Services.vsyncFor(win)`) for type safety and because the\n * factory should not be passed around.\n * @param {!Window} win\n * @param {string} id of the service.\n * @return {!Promise<!Object>}\n */\nexport function getServicePromise(win, id) {\n  return getServicePromiseInternal(win, id);\n}\n\n/**\n * Returns a service or null with the given id.\n * @param {!Window} win\n * @param {string} id\n * @return {?Object} The service.\n */\nexport function getExistingServiceOrNull(win, id) {\n  win = getTopWindow(win);\n  if (isServiceRegistered(win, id)) {\n    return getServiceInternal(win, id);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Like getServicePromise but returns null if the service was never registered.\n * @param {!Window} win\n * @param {string} id\n * @return {?Promise<!Object>}\n */\nexport function getServicePromiseOrNull(win, id) {\n  return getServicePromiseOrNullInternal(win, id);\n}\n\n/**\n * Returns a service for the given id and ampdoc (a per-ampdoc singleton).\n * Expects service `id` to be registered.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {T}\n * @template T\n */\nexport function getServiceForDoc(elementOrAmpDoc, id) {\n  const ampdoc = getAmpdoc(elementOrAmpDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  return getServiceInternal(holder, id);\n}\n\n/**\n * Returns a service for the given id and ampdoc (a per-ampdoc singleton).\n * If service `id` is not registered, returns null.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {?Object}\n */\nexport function getServiceForDocOrNull(elementOrAmpDoc, id) {\n  const ampdoc = getAmpdoc(elementOrAmpDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  if (isServiceRegistered(holder, id)) {\n    return getServiceInternal(holder, id);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Returns a promise for a service for the given id and ampdoc. Also expects\n * a service that has the actual implementation. The promise resolves when\n * the implementation loaded.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {!Promise<!Object>}\n */\nexport function getServicePromiseForDoc(elementOrAmpDoc, id) {\n  return getServicePromiseInternal(getAmpdocServiceHolder(elementOrAmpDoc), id);\n}\n\n/**\n * Like getServicePromiseForDoc but returns null if the service was never\n * registered for this ampdoc.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {?Promise<!Object>}\n */\nexport function getServicePromiseOrNullForDoc(elementOrAmpDoc, id) {\n  return getServicePromiseOrNullInternal(\n    getAmpdocServiceHolder(elementOrAmpDoc),\n    id\n  );\n}\n\n/**\n * Set the parent and top windows on a child window (friendly iframe).\n * @param {!Window} win\n * @param {!Window} parentWin\n */\nexport function setParentWindow(win, parentWin) {\n  win.__AMP_PARENT = parentWin;\n  win.__AMP_TOP = getTopWindow(parentWin);\n}\n\n/**\n * Returns the parent window for a child window (friendly iframe).\n * @param {!Window} win\n * @return {!Window}\n */\nexport function getParentWindow(win) {\n  return win.__AMP_PARENT || win;\n}\n\n/**\n * Returns the top window where AMP Runtime is installed for a child window\n * (friendly iframe).\n * @param {!Window} win\n * @return {!Window}\n */\nexport function getTopWindow(win) {\n  return win.__AMP_TOP || (win.__AMP_TOP = win);\n}\n\n/**\n * Returns the parent \"friendly\" iframe if the node belongs to a child window.\n * @param {!Node} node\n * @param {!Window=} opt_topWin\n * @return {?HTMLIFrameElement}\n */\nexport function getParentWindowFrameElement(node, opt_topWin) {\n  const childWin = (node.ownerDocument || node).defaultView;\n  const topWin = opt_topWin || getTopWindow(childWin);\n  if (childWin && childWin != topWin && getTopWindow(childWin) == topWin) {\n    try {\n      return /** @type {?HTMLIFrameElement} */ (childWin.frameElement);\n    } catch (e) {\n      // Ignore the error.\n    }\n  }\n  return null;\n}\n\n/**\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @return {!./service/ampdoc-impl.AmpDoc}\n */\nexport function getAmpdoc(nodeOrDoc) {\n  if (nodeOrDoc.nodeType) {\n    const win = getWin(nodeOrDoc);\n    return getAmpdocService(win).getAmpDoc(/** @type {!Node} */ (nodeOrDoc));\n  }\n  return /** @type {!./service/ampdoc-impl.AmpDoc} */ (nodeOrDoc);\n}\n\n/**\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @return {!./service/ampdoc-impl.AmpDoc|!Window}\n */\nfunction getAmpdocServiceHolder(nodeOrDoc) {\n  const ampdoc = getAmpdoc(nodeOrDoc);\n  return ampdoc.isSingleDoc() ? ampdoc.win : ampdoc;\n}\n\n/**\n * This is essentially a duplicate of `ampdoc.js`, but necessary to avoid\n * circular dependencies.\n * @param {!Window} win\n * @return {!./service/ampdoc-impl.AmpDocService}\n */\nfunction getAmpdocService(win) {\n  return /** @type {!./service/ampdoc-impl.AmpDocService} */ (\n    getService(win, 'ampdoc')\n  );\n}\n\n/**\n * Get service `id` from `holder`. Assumes the service\n * has already been registered.\n * @param {!Object} holder Object holding the service instance.\n * @param {string} id of the service.\n * @return {Object}\n */\nfunction getServiceInternal(holder, id) {\n  devAssert(\n    isServiceRegistered(holder, id),\n    `Expected service ${id} to be registered`\n  );\n  const services = getServices(holder);\n  const s = services[id];\n  if (!s.obj) {\n    devAssert(s.ctor, `Service ${id} registered without ctor nor impl.`);\n    devAssert(s.context, `Service ${id} registered without context.`);\n    s.obj = new s.ctor(s.context);\n    devAssert(s.obj, `Service ${id} constructed to null.`);\n    s.context = null;\n    // The service may have been requested already, in which case we have a\n    // pending promise we need to fulfill.\n    if (s.resolve) {\n      s.resolve(s.obj);\n    }\n  }\n  return s.obj;\n}\n\n/**\n * @param {!Object} holder Object holding the service instance.\n * @param {!Window|!./service/ampdoc-impl.AmpDoc} context Win or AmpDoc.\n * @param {string} id of the service.\n * @param {?function(new:Object, !Window)|?function(new:Object, !./service/ampdoc-impl.AmpDoc)} ctor Constructor function to new the service. Called with context.\n * @param {boolean=} opt_override\n * @param {boolean=} opt_sharedInstance\n */\nfunction registerServiceInternal(\n  holder,\n  context,\n  id,\n  ctor,\n  opt_override,\n  opt_sharedInstance\n) {\n  const services = getServices(holder);\n  let s = services[id];\n\n  if (!s) {\n    s = services[id] = {\n      obj: null,\n      promise: null,\n      resolve: null,\n      reject: null,\n      context: null,\n      ctor: null,\n      sharedInstance: opt_sharedInstance || false,\n    };\n  }\n\n  if (!opt_override && s.ctor) {\n    // Service already registered.\n    return;\n  }\n\n  s.ctor = ctor;\n  s.context = context;\n  s.sharedInstance = opt_sharedInstance || false;\n\n  // The service may have been requested already, in which case there is a\n  // pending promise that needs to fulfilled.\n  if (s.resolve) {\n    // getServiceInternal will resolve the promise.\n    getServiceInternal(holder, id);\n  }\n}\n\n/**\n * @param {!Object} holder\n * @param {string} id of the service.\n * @return {!Promise<!Object>}\n */\nfunction getServicePromiseInternal(holder, id) {\n  const cached = getServicePromiseOrNullInternal(holder, id);\n  if (cached) {\n    return cached;\n  }\n  // Service is not registered.\n\n  // TODO(@cramforce): Add a check that if the element is eventually registered\n  // that the service is actually provided and this promise resolves.\n  const services = getServices(holder);\n  services[id] = emptyServiceHolderWithPromise();\n  return /** @type {!Promise<!Object>} */ (services[id].promise);\n}\n\n/**\n * @param {!Object} holder\n * @param {string} id of the service.\n * @param {*} error\n */\nfunction rejectServicePromiseInternal(holder, id, error) {\n  const services = getServices(holder);\n  const s = services[id];\n  if (s) {\n    if (s.reject) {\n      s.reject(error);\n    }\n    return;\n  }\n\n  services[id] = emptyServiceHolderWithPromise();\n  services[id].reject(error);\n}\n\n/**\n * Returns a promise for service `id` if the service has been registered\n * on `holder`.\n * @param {!Object} holder\n * @param {string} id of the service.\n * @return {?Promise<!Object>}\n */\nfunction getServicePromiseOrNullInternal(holder, id) {\n  const services = getServices(holder);\n  const s = services[id];\n  if (s) {\n    if (s.promise) {\n      return s.promise;\n    } else {\n      // Instantiate service if not already instantiated.\n      getServiceInternal(holder, id);\n      return (s.promise = Promise.resolve(/** @type {!Object} */ (s.obj)));\n    }\n  }\n  return null;\n}\n\n/**\n * Returns the object that holds the services registered in a holder.\n * @param {!Object} holder\n * @return {!Object<string,!ServiceHolderDef>}\n */\nfunction getServices(holder) {\n  let services = holder.__AMP_SERVICES;\n  if (!services) {\n    services = holder.__AMP_SERVICES = {};\n  }\n  return services;\n}\n\n/**\n * Whether the specified service implements `Disposable` interface.\n * @param {!Object} service\n * @return {boolean}\n */\nexport function isDisposable(service) {\n  return typeof service.dispose == 'function';\n}\n\n/**\n * Asserts that the specified service implements `Disposable` interface and\n * typecasts the instance to `Disposable`.\n * @param {!Object} service\n * @return {!Disposable}\n */\nexport function assertDisposable(service) {\n  devAssert(isDisposable(service), 'required to implement Disposable');\n  return /** @type {!Disposable} */ (service);\n}\n\n/**\n * Disposes all disposable (implements `Disposable` interface) services in\n * ampdoc scope.\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n */\nexport function disposeServicesForDoc(ampdoc) {\n  disposeServicesInternal(ampdoc);\n}\n\n/**\n * Disposes all disposable (implements `Disposable` interface) services in\n * embed scope.\n * @param {!Window} embedWin\n */\nexport function disposeServicesForEmbed(embedWin) {\n  disposeServicesInternal(embedWin);\n}\n\n/**\n * @param {!Object} holder Object holding the service instances.\n */\nfunction disposeServicesInternal(holder) {\n  const services = getServices(holder);\n  for (const id in services) {\n    if (!Object.prototype.hasOwnProperty.call(services, id)) {\n      continue;\n    }\n    const serviceHolder = services[id];\n    if (serviceHolder.sharedInstance) {\n      continue;\n    }\n    if (serviceHolder.obj) {\n      disposeServiceInternal(id, serviceHolder.obj);\n    } else if (serviceHolder.promise) {\n      serviceHolder.promise.then((instance) =>\n        disposeServiceInternal(id, instance)\n      );\n    }\n  }\n}\n\n/**\n * @param {string} id\n * @param {!Object} service\n */\nfunction disposeServiceInternal(id, service) {\n  if (!isDisposable(service)) {\n    return;\n  }\n  try {\n    assertDisposable(service).dispose();\n  } catch (e) {\n    // Ensure that a failure to dispose a service does not disrupt other\n    // services.\n    dev().error('SERVICE', 'failed to dispose service', id, e);\n  }\n}\n\n/**\n * This adopts the service **instance** from the parent.\n *\n * This function is dangerous! Sharing an instance means data can leak to and\n * from a child ampdoc.\n *\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {string} id\n */\nexport function adoptServiceForEmbedDoc(ampdoc, id) {\n  const service = getServiceInternal(\n    getAmpdocServiceHolder(devAssert(ampdoc.getParent())),\n    id\n  );\n  registerServiceInternal(\n    getAmpdocServiceHolder(ampdoc),\n    ampdoc,\n    id,\n    function () {\n      return service;\n    },\n    /* override */ false,\n    /* sharedInstance */ true\n  );\n}\n\n/**\n * This adopts the service **factory** from the parent.\n *\n * This function is safer than sharing the service instance, since each ampdoc\n * will create its own instance of the factory (and each instance will have its\n * own instance data). Note that static data is still shared, so it's not 100%\n * foolproof.\n *\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {string} id\n */\nexport function adoptServiceFactoryForEmbedDoc(ampdoc, id) {\n  const parentHolder = getAmpdocServiceHolder(devAssert(ampdoc.getParent()));\n  devAssert(\n    isServiceRegistered(parentHolder, id),\n    `Expected service ${id} to be registered`\n  );\n  const service = getServices(parentHolder)[id];\n  registerServiceInternal(\n    getAmpdocServiceHolder(ampdoc),\n    ampdoc,\n    id,\n    devAssert(service.ctor)\n  );\n}\n\n/**\n * Resets a single service, so it gets recreated on next getService invocation.\n * @param {!Object} holder\n * @param {string} id of the service.\n */\nexport function resetServiceForTesting(holder, id) {\n  if (holder.__AMP_SERVICES) {\n    holder.__AMP_SERVICES[id] = null;\n  }\n}\n\n/**\n * @param {!Object} holder Object holding the service instance.\n * @param {string} id of the service.\n * @return {boolean}\n */\nfunction isServiceRegistered(holder, id) {\n  const service = holder.__AMP_SERVICES && holder.__AMP_SERVICES[id];\n  // All registered services must have a constructor.\n  return !!(service && service.ctor);\n}\n\n/** @return {!ServiceHolderDef} */\nfunction emptyServiceHolderWithPromise() {\n  const deferred = new Deferred();\n  const {promise, reject, resolve} = deferred;\n  promise.catch(() => {}); // avoid uncaught exception when service gets rejected\n  return {\n    obj: null,\n    promise,\n    resolve,\n    reject,\n    context: null,\n    ctor: null,\n  };\n}\n", "import * as dom from '#core/dom';\n\nimport {extensionScriptInNode} from '#service/extension-script';\n\nimport {userAssert} from '#utils/log';\n\nimport {\n  getAmpdoc,\n  getService,\n  getServiceForDocOrNull,\n  getServicePromise,\n  getServicePromiseForDoc,\n  getServicePromiseOrNull,\n  getServicePromiseOrNullForDoc,\n} from './service-helpers';\n\n/**\n * Same as getElementService but produces null if the given element is not\n * actually available on the current page.\n * @param {!Window} win\n * @param {string} id of the service.\n * @param {string} extension Name of the custom extension that provides the\n *     implementation of this service.\n * @param {string} version The extension version.\n * @param {boolean=} opt_element Whether this service is provided by an\n *     element, not the extension.\n * @return {!Promise<?Object>}\n */\nexport function getElementServiceIfAvailable(\n  win,\n  id,\n  extension,\n  version,\n  opt_element\n) {\n  const s = getServicePromiseOrNull(win, id);\n  if (s) {\n    return /** @type {!Promise<?Object>} */ (s);\n  }\n  return getElementServicePromiseOrNull(\n    win,\n    id,\n    extension,\n    version,\n    opt_element\n  );\n}\n\n/**\n * Returns a promise for a service for the given id and window. Also expects an\n * element that has the actual implementation. The promise resolves when the\n * implementation loaded. Users should typically wrap this as a special purpose\n * function (e.g. Services.viewportForDoc(...)) for type safety and because the\n * factory should not be passed around.\n * @param {!Element|!ShadowRoot} element\n * @param {string} id of the service.\n * @param {string} extension Name of the custom extension that provides the\n *     implementation of this service.\n * @param {boolean=} opt_element Whether this service is provided by an element,\n *     not the extension.\n * @return {!Promise<*>}\n */\nexport function getElementServiceForDoc(element, id, extension, opt_element) {\n  return getElementServiceIfAvailableForDoc(\n    element,\n    id,\n    extension,\n    opt_element\n  ).then((service) => assertService(service, id, extension));\n}\n\n/**\n * Same as getElementService but produces null if the given element is not\n * actually available on the current page.\n * @param {!Element|!ShadowRoot} element\n * @param {string} id of the service.\n * @param {string} extension Name of the custom extension that provides the\n *     implementation of this service.\n * @param {boolean=} opt_element Whether this service is provided by an\n *     element, not the extension.\n * @return {!Promise<?Object>}\n */\nexport function getElementServiceIfAvailableForDoc(\n  element,\n  id,\n  extension,\n  opt_element\n) {\n  const s = getServicePromiseOrNullForDoc(element, id);\n  if (s) {\n    return /** @type {!Promise<?Object>} */ (s);\n  }\n  const ampdoc = getAmpdoc(element);\n  return ampdoc\n    .whenExtensionsKnown()\n    .then(() => {\n      const version = ampdoc.getExtensionVersion(extension);\n      if (!version) {\n        return null;\n      }\n      const extensions = getService(ampdoc.win, 'extensions');\n      return extensions.waitForExtension(extension, version);\n    })\n    .then((ext) => {\n      if (!ext) {\n        return null;\n      }\n      // If this service is provided by an element, then we can't depend on\n      // the service (they may not use the element).\n      if (opt_element) {\n        return getServicePromiseOrNullForDoc(element, id);\n      }\n      return getServicePromiseForDoc(element, id);\n    });\n}\n\n/**\n * Returns a promise for service for the given id in the embed scope of\n * a given element, if it exists. Falls back to ampdoc scope if the element\n * is not embedded.\n *\n * @param {!Element|!ShadowRoot} element\n * @param {string} id of the service.\n * @param {string} extension Name of the custom element that provides\n *     the implementation of this service.\n * @return {!Promise<?Object>}\n */\nexport function getElementServiceIfAvailableForDocInEmbedScope(\n  element,\n  id,\n  extension\n) {\n  const s = getServiceForDocOrNull(element, id);\n  if (s) {\n    return /** @type {!Promise<?Object>} */ (Promise.resolve(s));\n  }\n  return getElementServiceIfAvailableForDoc(element, id, extension);\n}\n\n/**\n * Throws user error if `service` is null.\n * @param {Object} service\n * @param {string} id\n * @param {string} extension\n * @return {!Object}\n * @private\n * @closurePrimitive {asserts.matchesReturn}\n */\nfunction assertService(service, id, extension) {\n  return /** @type {!Object} */ (\n    userAssert(\n      service,\n      'Service %s was requested to be provided through %s, ' +\n        'but %s is not loaded in the current page. To fix this ' +\n        'problem load the JavaScript file for %s in this page.',\n      id,\n      extension,\n      extension,\n      extension\n    )\n  );\n}\n\n/**\n * Returns the promise for service with `id` on the given window if available.\n * Otherwise, resolves with null (service was not registered).\n * @param {!Window} win\n * @param {string} id\n * @param {string} extension\n * @param {string} version\n * @param {boolean=} opt_element\n * @return {!Promise<Object>}\n * @private\n */\nfunction getElementServicePromiseOrNull(\n  win,\n  id,\n  extension,\n  version,\n  opt_element\n) {\n  return dom\n    .waitForBodyOpenPromise(win.document)\n    .then(() => {\n      // If there is an extension script wait for it to load before trying\n      // to get the service. Prevents a race condition when everything but\n      // the extensions is in cache. If there is no script then it's either\n      // not present, or the service was defined by a test. In those cases\n      // we don't wait around for an extension that does not exist.\n      const extensions = getService(win, 'extensions');\n\n      // TODO(jpettitt) investigate registerExtension to short circuit\n      // the dom call in extensionScriptsInNode()\n      if (!extensionScriptInNode(extensions.win, extension, version)) {\n        return null;\n      }\n      return extensions.waitForExtension(extension, version);\n    })\n    .then((ext) => {\n      if (!ext) {\n        return null;\n      }\n      // If this service is provided by an element, then we can't depend on\n      // the service (they may not use the element).\n      if (opt_element) {\n        return getServicePromiseOrNull(win, id);\n      }\n      return getServicePromise(win, id);\n    });\n}\n", "import {\n  getElementServiceForDoc,\n  getElementServiceIfAvailable,\n  getElementServiceIfAvailableForDoc,\n  getElementServiceIfAvailableForDocInEmbedScope,\n} from '../element-service';\nimport {\n  getAmpdoc,\n  getExistingServiceOrNull,\n  getService,\n  getServiceForDoc,\n  getServiceForDocOrNull,\n  getServiceInEmbedWin,\n  getServicePromiseForDoc,\n} from '../service-helpers';\n\n/** @typedef {!../extensions/amp-subscriptions/0.1/amp-subscriptions.SubscriptionService} */\nexport let SubscriptionService;\n\nexport class Services {\n  /**\n   * Hint: Add extensions folder path to compile.js with\n   * warnings cannot find modules.\n   */\n\n  /**\n   * Returns a promise for the Access service.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-access/0.1/amp-access.AccessService>}\n   */\n  static accessServiceForDoc(element) {\n    return /** @type {!Promise<!../extensions/amp-access/0.1/amp-access.AccessService>} */ (\n      getElementServiceForDoc(element, 'access', 'amp-access')\n    );\n  }\n\n  /**\n   * Returns a promise for the Access service or a promise for null if the\n   * service is not available on the current page.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-access/0.1/amp-access.AccessService>}\n   */\n  static accessServiceForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-access/0.1/amp-access.AccessService>} */ (\n      getElementServiceIfAvailableForDoc(element, 'access', 'amp-access')\n    );\n  }\n\n  /**\n   * Returns a promise for the Subscriptions service.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!SubscriptionService>}\n   */\n  static subscriptionsServiceForDoc(element) {\n    return /** @type {!Promise<!SubscriptionService>} */ (\n      getElementServiceForDoc(element, 'subscriptions', 'amp-subscriptions')\n    );\n  }\n\n  /**\n   * Returns a promise for the Subscriptions service.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?SubscriptionService>}\n   */\n  static subscriptionsServiceForDocOrNull(element) {\n    return /** @type {!Promise<?SubscriptionService>} */ (\n      getElementServiceIfAvailableForDoc(\n        element,\n        'subscriptions',\n        'amp-subscriptions'\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/action-impl.ActionService}\n   */\n  static actionServiceForDoc(element) {\n    return /** @type {!./service/action-impl.ActionService} */ (\n      getServiceForDocOrNull(element, 'action')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/standard-actions-impl.StandardActions}\n   */\n  static standardActionsForDoc(element) {\n    return /** @type {!./service/standard-actions-impl.StandardActions} */ (\n      getServiceForDocOrNull(element, 'standard-actions')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-analytics/0.1/activity-impl.Activity>}\n   */\n  static activityForDoc(element) {\n    return /** @type {!Promise<!../extensions/amp-analytics/0.1/activity-impl.Activity>} */ (\n      getElementServiceForDoc(element, 'activity', 'amp-analytics')\n    );\n  }\n\n  /**\n   * Returns the global instance of the `AmpDocService` service that can be\n   * used to resolve an ampdoc for any node: either in the single-doc or\n   * shadow-doc environment.\n   * @param {!Window} window\n   * @return {!./service/ampdoc-impl.AmpDocService}\n   */\n  static ampdocServiceFor(window) {\n    return /** @type {!./service/ampdoc-impl.AmpDocService} */ (\n      getService(window, 'ampdoc')\n    );\n  }\n\n  /**\n   * Returns the AmpDoc for the specified context node.\n   * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrAmpDoc\n   * @return {!./service/ampdoc-impl.AmpDoc}\n   */\n  static ampdoc(nodeOrAmpDoc) {\n    return getAmpdoc(nodeOrAmpDoc);\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @param {boolean=} loadAnalytics\n   * @return {!Promise<!../extensions/amp-analytics/0.1/instrumentation.InstrumentationService>}\n   */\n  static analyticsForDoc(element, loadAnalytics = false) {\n    if (loadAnalytics) {\n      // Get Extensions service and force load analytics extension.\n      const ampdoc = getAmpdoc(element);\n      Services.extensionsFor(ampdoc.win)./*OK*/ installExtensionForDoc(\n        ampdoc,\n        'amp-analytics'\n      );\n    }\n    return /** @type {!Promise<!../extensions/amp-analytics/0.1/instrumentation.InstrumentationService>} */ (\n      getElementServiceForDoc(\n        element,\n        'amp-analytics-instrumentation',\n        'amp-analytics'\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-analytics/0.1/instrumentation.InstrumentationService>}\n   */\n  static analyticsForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-analytics/0.1/instrumentation.InstrumentationService>} */ (\n      getElementServiceIfAvailableForDoc(\n        element,\n        'amp-analytics-instrumentation',\n        'amp-analytics'\n      )\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/batched-xhr-impl.BatchedXhr}\n   */\n  static batchedXhrFor(window) {\n    return /** @type {!./service/batched-xhr-impl.BatchedXhr} */ (\n      getService(window, 'batched-xhr')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-bind/0.1/bind-impl.Bind>}\n   */\n  static bindForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-bind/0.1/bind-impl.Bind>} */ (\n      getElementServiceIfAvailableForDocInEmbedScope(\n        element,\n        'bind',\n        'amp-bind'\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-script/0.1/amp-script.AmpScriptService>}\n   */\n  static scriptForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-script/0.1/amp-script.AmpScriptService>} */ (\n      getElementServiceIfAvailableForDocInEmbedScope(\n        element,\n        'amp-script',\n        'amp-script'\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/cid-impl.CidDef>}\n   */\n  static cidForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/cid-impl.CidDef>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'cid')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/navigation.Navigation}\n   */\n  static navigationForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/navigation.Navigation} */ (\n      getServiceForDoc(elementOrAmpDoc, 'navigation')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-loader/0.1/amp-loader.LoaderService>}\n   */\n  static loaderServiceForDoc(element) {\n    return /** @type {!Promise<!../extensions/amp-loader/0.1/amp-loader.LoaderService>} */ (\n      getElementServiceForDoc(element, 'loader', 'amp-loader')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-standalone/0.1/amp-standalone.StandaloneService>}\n   */\n  static standaloneServiceForDoc(element) {\n    return /** @type {!Promise<!../extensions/amp-standalone/0.1/amp-standalone.StandaloneService>} */ (\n      getElementServiceForDoc(element, 'standalone', 'amp-standalone')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/crypto-impl.Crypto}\n   */\n  static cryptoFor(window) {\n    return /** @type {!./service/crypto-impl.Crypto} */ (\n      getService(window, 'crypto')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/document-info-impl.DocumentInfoDef} Info about the doc\n   */\n  static documentInfoForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/document-info-impl.DocInfo} */ (\n      getServiceForDoc(elementOrAmpDoc, 'documentInfo')\n    ).get();\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/extensions-impl.Extensions}\n   */\n  static extensionsFor(window) {\n    return /** @type {!./service/extensions-impl.Extensions} */ (\n      getService(window, 'extensions')\n    );\n  }\n\n  /**\n   * Returns a service to register callbacks we wish to execute when an\n   * amp-form is submitted.\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<../extensions/amp-form/0.1/form-submit-service.FormSubmitService>}\n   */\n  static formSubmitForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<../extensions/amp-form/0.1/form-submit-service.FormSubmitService>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'form-submit-service')\n    );\n  }\n\n  /**\n   * Returns service to listen for `hidden` attribute mutations.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/hidden-observer-impl.HiddenObserver}\n   */\n  static hiddenObserverForDoc(element) {\n    return /** @type {!./service/hidden-observer-impl.HiddenObserver} */ (\n      getServiceForDocOrNull(element, 'hidden-observer')\n    );\n  }\n\n  /**\n   * Returns service implemented in service/history-impl.\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/history-impl.History}\n   */\n  static historyForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/history-impl.History} */ (\n      getServiceForDoc(elementOrAmpDoc, 'history')\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {!./input.Input}\n   */\n  static inputFor(win) {\n    return getService(win, 'input');\n  }\n\n  /**s\n   * Returns a promise for the Inputmask service.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-inputmask/0.1/amp-inputmask.AmpInputmaskService>}\n   */\n  static inputmaskServiceForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-inputmask/0.1/amp-inputmask.AmpInputmaskService>} */ (\n      getElementServiceIfAvailableForDoc(element, 'inputmask', 'amp-inputmask')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {?./service/loading-indicator.LoadingIndicatorImpl}\n   */\n  static loadingIndicatorOrNull(elementOrAmpDoc) {\n    return /** @type {?./service/loading-indicator.LoadingIndicatorImpl} */ (\n      getServiceForDocOrNull(elementOrAmpDoc, 'loadingIndicator')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!../extensions/amp-next-page/1.0/service.NextPageService}\n   */\n  static nextPageServiceForDoc(elementOrAmpDoc) {\n    return /** @type {!../extensions/amp-next-page/1.0/service.NextPageService} */ (\n      getServiceForDoc(elementOrAmpDoc, 'next-page')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/mutator-interface.MutatorInterface}\n   */\n  static mutatorForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/mutator-interface.MutatorInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'mutator')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/owners-interface.OwnersInterface}\n   */\n  static ownersForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/owners-interface.OwnersInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'owners')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/performance-impl.Performance}\n   */\n  static performanceFor(window) {\n    return /** @type {!./service/performance-impl.Performance}*/ (\n      getService(window, 'performance')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/performance-impl.Performance}\n   */\n  static performanceForOrNull(window) {\n    return /** @type {!./service/performance-impl.Performance}*/ (\n      getExistingServiceOrNull(window, 'performance')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/platform-impl.Platform}\n   */\n  static platformFor(window) {\n    return /** @type {!./service/platform-impl.Platform} */ (\n      getService(window, 'platform')\n    );\n  }\n\n  /**\n   * Not installed by default; must be installed in extension code before use.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/position-observer/position-observer-impl.PositionObserver}\n   * @throws If the service is not installed.\n   */\n  static positionObserverForDoc(element) {\n    return /** @type {!./service/position-observer/position-observer-impl.PositionObserver} */ (\n      getServiceForDoc(element, 'position-observer')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./preconnect.PreconnectService}\n   */\n  static preconnectFor(window) {\n    return getService(window, 'preconnect');\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/resources-interface.ResourcesInterface}\n   */\n  static resourcesForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/resources-interface.ResourcesInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'resources')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/resources-interface.ResourcesInterface>}\n   */\n  static resourcesPromiseForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/resources-interface.ResourcesInterface>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'resources')\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?Promise<?../extensions/amp-story/1.0/variable-service.AmpStoryVariableService>}\n   */\n  static storyVariableServiceForOrNull(win) {\n    return (\n      /** @type {!Promise<?../extensions/amp-story/1.0/variable-service.AmpStoryVariableService>} */\n      (getElementServiceIfAvailable(win, 'story-variable', 'amp-story', '1.0'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/variable-service.AmpStoryVariableService}\n   */\n  static storyVariableService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/variable-service.AmpStoryVariableService} */\n      (getExistingServiceOrNull(win, 'story-variable'))\n    );\n  }\n\n  /**\n   * Version of the story store service depends on which version of amp-story\n   * the publisher is loading. They all have the same implementation.\n   * @param {!Window} win\n   * @return {?Promise<?../extensions/amp-story/1.0/amp-story-store-service.AmpStoryStoreService>}\n   */\n  static storyStoreServiceForOrNull(win) {\n    return (\n      /** @type {!Promise<?../extensions/amp-story/1.0/amp-story-store-service.AmpStoryStoreService>} */\n      (getElementServiceIfAvailable(win, 'story-store', 'amp-story', '1.0'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/amp-story-store-service.AmpStoryStoreService}\n   */\n  static storyStoreService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/amp-story-store-service.AmpStoryStoreService} */\n      (getExistingServiceOrNull(win, 'story-store'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/amp-story-media-query-service.AmpStoryMediaQueryService}\n   */\n  static storyMediaQueryService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/amp-story-media-query-service.AmpStoryMediaQueryService} */\n      (getExistingServiceOrNull(win, 'story-media-query'))\n    );\n  }\n\n  /**\n   * Get promise with story request service\n   * @param {!Window} win\n   * @return {?Promise<?../extensions/amp-story/1.0/amp-story-request-service.AmpStoryRequestService>}\n   */\n  static storyRequestServiceForOrNull(win) {\n    return (\n      /** @type {!Promise<?../extensions/amp-story/1.0/amp-story-request-service.AmpStoryRequestService>} */\n      (getElementServiceIfAvailable(win, 'story-request', 'amp-story', '1.0'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/amp-story-request-service.AmpStoryRequestService}\n   */\n  static storyRequestService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/amp-story-request-service.AmpStoryRequestService} */\n      (getExistingServiceOrNull(win, 'story-request'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/media-performance-metrics-service.MediaPerformanceMetricsService}\n   */\n  static mediaPerformanceMetricsService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/media-performance-metrics-service.MediaPerformanceMetricsService} */\n      (getExistingServiceOrNull(win, 'media-performance-metrics'))\n    );\n  }\n\n  /**\n   * @param {!Element} el\n   * @return {!Promise<./service/localization.LocalizationService>}\n   */\n  static localizationServiceForOrNull(el) {\n    return /** @type {!Promise<?./service/localization.LocalizationService>} */ (\n      getServicePromiseForDoc(el, 'localization')\n    );\n  }\n\n  /**\n   * @param {!Element} element\n   * @return {?./service/localization.LocalizationService}\n   */\n  static localizationForDoc(element) {\n    return /** @type {?./service/localization.LocalizationService} */ (\n      getServiceForDocOrNull(element, 'localization')\n    );\n  }\n\n  /**\n   * TODO(#14357): Remove this when amp-story:0.1 is deprecated.\n   * @param {!Window} win\n   * @return {!Promise<?../extensions/amp-story/1.0/story-analytics.StoryAnalyticsService>}\n   */\n  static storyAnalyticsServiceForOrNull(win) {\n    return (\n      /** @type {!Promise<?../extensions/amp-story/1.0/story-analytics.StoryAnalyticsService>} */\n      (\n        getElementServiceIfAvailable(\n          win,\n          'story-analytics',\n          'amp-story',\n          '1.0',\n          true\n        )\n      )\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/story-analytics.StoryAnalyticsService}\n   */\n  static storyAnalyticsService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/story-analytics.StoryAnalyticsService} */\n      (getExistingServiceOrNull(win, 'story-analytics'))\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-animation/0.1/web-animation-service.WebAnimationService>}\n   */\n  static webAnimationServiceFor(element) {\n    return (\n      /** @type {!Promise<!../extensions/amp-animation/0.1/web-animation-service.WebAnimationService>} */\n      (getElementServiceForDoc(element, 'web-animation', 'amp-animation'))\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/real-time-config/real-time-config-impl.RealTimeConfigManager>}\n   */\n  static realTimeConfigForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/real-time-config/real-time-config-impl.RealTimeConfigManager>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'real-time-config')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/storage-impl.Storage>}\n   */\n  static storageForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/storage-impl.Storage>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'storage')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/storage-impl.Storage>}\n   * TODO(dmanek): Add tests for this method.\n   */\n  static storageForTopLevelDoc(elementOrAmpDoc) {\n    const thisAmpdoc = Services.ampdoc(elementOrAmpDoc);\n    const ampdocService = Services.ampdocServiceFor(thisAmpdoc.win);\n    const topAmpdoc = ampdocService.isSingleDoc()\n      ? ampdocService.getSingleDoc()\n      : null;\n    // We need to verify that ampdocs are on the same origin, therefore\n    // we compare the windows of both.\n    const ampdoc =\n      topAmpdoc && topAmpdoc.win == thisAmpdoc.win ? topAmpdoc : thisAmpdoc;\n    return /** @type {!Promise<!./service/storage-impl.Storage>} */ (\n      getServicePromiseForDoc(ampdoc, 'storage')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/template-impl.Templates}\n   */\n  static templatesForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/template-impl.Templates} */ (\n      getServiceForDoc(elementOrAmpDoc, 'templates')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/timer-impl.Timer}\n   */\n  static timerFor(window) {\n    // TODO(alabiaga): This will always return the top window's Timer service.\n    return /** @type {!./service/timer-impl.Timer} */ (\n      getServiceInEmbedWin(window, 'timer')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/url-replacements-impl.UrlReplacements}\n   */\n  static urlReplacementsForDoc(element) {\n    return /** @type {!./service/url-replacements-impl.UrlReplacements} */ (\n      getServiceForDocOrNull(element, 'url-replace')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-user-notification/0.1/amp-user-notification.UserNotificationManager>}\n   */\n  static userNotificationManagerForDoc(element) {\n    return (\n      /** @type {!Promise<!../extensions/amp-user-notification/0.1/amp-user-notification.UserNotificationManager>} */\n      (\n        getElementServiceForDoc(\n          element,\n          'userNotificationManager',\n          'amp-user-notification'\n        )\n      )\n    );\n  }\n\n  /**\n   * Returns a promise for the consentPolicy Service or a promise for null if\n   * the service is not available on the current page.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-consent/0.1/consent-policy-manager.ConsentPolicyManager>}\n   */\n  static consentPolicyServiceForDocOrNull(element) {\n    return (\n      /** @type {!Promise<?../extensions/amp-consent/0.1/consent-policy-manager.ConsentPolicyManager>} */\n      (\n        getElementServiceIfAvailableForDoc(\n          element,\n          'consentPolicyManager',\n          'amp-consent'\n        )\n      )\n    );\n  }\n\n  /**\n   * Returns a promise for the geo service or a promise for null if\n   * the service is not available on the current page.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-geo/0.1/amp-geo.GeoDef>}\n   */\n  static geoForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-geo/0.1/amp-geo.GeoDef>} */ (\n      getElementServiceIfAvailableForDoc(element, 'geo', 'amp-geo', true)\n    );\n  }\n\n  /**\n   * Unlike most service getters, passing `Node` is necessary for some FIE-scope\n   * services since sometimes we only have the FIE Document for context.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/url-impl.Url}\n   */\n  static urlForDoc(element) {\n    return /** @type {!./service/url-impl.Url} */ (\n      getServiceForDocOrNull(element, 'url')\n    );\n  }\n\n  /**\n   * Returns a promise for the experiment variants or a promise for null if it\n   * is not available on the current page.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-experiment/0.1/variant.Variants>}\n   */\n  static variantsForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-experiment/0.1/variant.Variants>} */ (\n      getElementServiceIfAvailableForDoc(\n        element,\n        'variant',\n        'amp-experiment',\n        true\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/video-manager-impl.VideoManager}\n   */\n  static videoManagerForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/video-manager-impl.VideoManager} */ (\n      getServiceForDoc(elementOrAmpDoc, 'video-manager')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/viewer-interface.ViewerInterface}\n   */\n  static viewerForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/viewer-interface.ViewerInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'viewer')\n    );\n  }\n\n  /**\n   * Returns promise for the viewer. This is an unusual case and necessary only\n   * for services that need reference to the viewer before it has been\n   * initialized. Most of the code, however, just should use `viewerForDoc`.\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/viewer-interface.ViewerInterface>}\n   */\n  static viewerPromiseForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/viewer-interface.ViewerInterface>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'viewer')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/vsync-impl.Vsync}\n   */\n  static vsyncFor(window) {\n    return /** @type {!./service/vsync-impl.Vsync} */ (\n      getService(window, 'vsync')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/viewport/viewport-interface.ViewportInterface}\n   */\n  static viewportForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/viewport/viewport-interface.ViewportInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'viewport')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/xhr-impl.Xhr}\n   */\n  static xhrFor(window) {\n    return /** @type {!./service/xhr-impl.Xhr} */ (getService(window, 'xhr'));\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<../amp-cache-url/amp-cache-url.AmpCacheUrlService>}\n   */\n  static cacheUrlServicePromiseForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<?../amp-cache-url/amp-cache-url.AmpCacheUrlService>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'cache-url')\n    );\n  }\n}\n", "import {internalListenImplementation} from '#core/dom/event-helper-listen';\nimport {lastChildElement} from '#core/dom/query';\nimport * as mode from '#core/mode';\n\nimport {user} from '#utils/log';\n\n/** @const {string}  */\nconst LOAD_FAILURE_PREFIX = 'Failed to load:';\n\n/** @const {string} */\nexport const MEDIA_LOAD_FAILURE_SRC_PROPERTY = '__AMP_MEDIA_LOAD_FAILURE_SRC';\n\n/**\n * Returns a CustomEvent with a given type and detail; supports fallback for IE.\n * @param {!Window} win\n * @param {string} type\n * @param {!JsonObject|string|undefined|null} detail\n * @param {EventInit=} opt_eventInit\n * @return {!Event}\n */\nexport function createCustomEvent(win, type, detail, opt_eventInit) {\n  const eventInit = /** @type {!CustomEventInit} */ ({detail});\n  Object.assign(eventInit, opt_eventInit);\n  // win.CustomEvent is a function on Edge, Chrome, FF, Safari but\n  // is an object on IE 11.\n  if (mode.isEsm() || typeof win.CustomEvent == 'function') {\n    return new win.CustomEvent(type, eventInit);\n  } else {\n    // Deprecated fallback for IE.\n    const e = win.document.createEvent('CustomEvent');\n    e.initCustomEvent(\n      type,\n      !!eventInit.bubbles,\n      !!eventInit.cancelable,\n      detail\n    );\n    return e;\n  }\n}\n\n/**\n * Listens for the specified event on the element.\n * @param {!EventTarget} element\n * @param {string} eventType\n * @param {function(!Event)} listener\n * @param {Object=} opt_evtListenerOpts\n * @return {!UnlistenDef}\n */\nexport function listen(element, eventType, listener, opt_evtListenerOpts) {\n  return internalListenImplementation(\n    element,\n    eventType,\n    listener,\n    opt_evtListenerOpts\n  );\n}\n\n/**\n * Returns the data property of an event with the correct type.\n * @param {!Event|{data: !JsonObject}} event\n * @return {?JsonObject|string|undefined}\n */\nexport function getData(event) {\n  return /** @type {?JsonObject|string|undefined} */ (event.data);\n}\n\n/**\n * Returns the detail property of an event with the correct type.\n * @param {!Event|{detail: !JsonObject}} event\n * @return {?JsonObject|string|undefined}\n */\nexport function getDetail(event) {\n  return /** @type {?JsonObject|string|undefined} */ (event.detail);\n}\n\n/**\n * Listens for the specified event on the element and removes the listener\n * as soon as event has been received.\n * @param {!EventTarget} element\n * @param {string} eventType\n * @param {function(!Event)} listener\n * @param {Object=} opt_evtListenerOpts\n * @return {!UnlistenDef}\n */\nexport function listenOnce(element, eventType, listener, opt_evtListenerOpts) {\n  let localListener = listener;\n  const unlisten = internalListenImplementation(\n    element,\n    eventType,\n    (event) => {\n      try {\n        localListener(event);\n      } finally {\n        // Ensure listener is GC'd\n        localListener = null;\n        unlisten();\n      }\n    },\n    opt_evtListenerOpts\n  );\n  return unlisten;\n}\n\n/**\n * Returns  a promise that will resolve as soon as the specified event has\n * fired on the element.\n * @param {!EventTarget} element\n * @param {string} eventType\n * @param {Object=} opt_evtListenerOpts\n * @param {function(!UnlistenDef)=} opt_cancel An optional function that, when\n *     provided, will be called with the unlistener. This gives the caller\n *     access to the unlistener, so it may be called manually when necessary.\n * @return {!Promise<!Event>}\n */\nexport function listenOncePromise(\n  element,\n  eventType,\n  opt_evtListenerOpts,\n  opt_cancel\n) {\n  let unlisten;\n  const eventPromise = new Promise((resolve) => {\n    unlisten = listenOnce(element, eventType, resolve, opt_evtListenerOpts);\n  });\n  eventPromise.then(unlisten, unlisten);\n  if (opt_cancel) {\n    opt_cancel(unlisten);\n  }\n  return eventPromise;\n}\n\n/**\n * Whether the specified element/window has been loaded already.\n * @param {!Element|!Window} eleOrWindow\n * @return {boolean}\n */\nexport function isLoaded(eleOrWindow) {\n  return !!(\n    eleOrWindow.complete ||\n    eleOrWindow.readyState == 'complete' ||\n    (isHTMLMediaElement(eleOrWindow) && eleOrWindow.readyState > 0) ||\n    // If the passed in thing is a Window, infer loaded state from\n    //\n    (eleOrWindow.document && eleOrWindow.document.readyState == 'complete')\n  );\n}\n\n/**\n * Returns a promise that will resolve or fail based on the eleOrWindow's 'load'\n * and 'error' events. Optionally this method takes a timeout, which will reject\n * the promise if the resource has not loaded by then.\n * @param {T} eleOrWindow Supports both Elements and as a special case Windows.\n * @return {!Promise<T>}\n * @template T\n */\nexport function loadPromise(eleOrWindow) {\n  let unlistenLoad;\n  let unlistenError;\n  if (isLoaded(eleOrWindow)) {\n    return Promise.resolve(eleOrWindow);\n  }\n  const isMediaElement = isHTMLMediaElement(eleOrWindow);\n  if (\n    isMediaElement &&\n    eleOrWindow[MEDIA_LOAD_FAILURE_SRC_PROPERTY] === eleOrWindow.currentSrc\n  ) {\n    return Promise.reject(eleOrWindow);\n  }\n  const loadingPromise = new Promise((resolve, reject) => {\n    // Listen once since IE 5/6/7 fire the onload event continuously for\n    // animated GIFs.\n    if (isMediaElement) {\n      // The following event can be triggered by the media or one of its\n      // sources. Using capture is required as the media events do not bubble.\n      unlistenLoad = listenOnce(eleOrWindow, 'loadedmetadata', resolve, {\n        capture: true,\n      });\n    } else {\n      unlistenLoad = listenOnce(eleOrWindow, 'load', resolve);\n    }\n    // Don't unlisten on error for Windows.\n    if (!eleOrWindow.tagName) {\n      return;\n    }\n    let errorTarget = eleOrWindow;\n    // If the media element has no `src`, it will try to load the sources in\n    // document order. If the last source errors, then the media element\n    // loading errored.\n    if (isMediaElement && !eleOrWindow.hasAttribute('src')) {\n      errorTarget = lastChildElement(\n        eleOrWindow,\n        (child) => child.tagName === 'SOURCE'\n      );\n      if (!errorTarget) {\n        return reject(new Error('Media has no source.'));\n      }\n    }\n    unlistenError = listenOnce(errorTarget, 'error', reject);\n  });\n\n  return loadingPromise.then(\n    () => {\n      if (unlistenError) {\n        unlistenError();\n      }\n      return eleOrWindow;\n    },\n    () => {\n      if (unlistenLoad) {\n        unlistenLoad();\n      }\n      failedToLoad(eleOrWindow);\n    }\n  );\n}\n\n/**\n * Emit error on load failure.\n * @param {!Element|!Window} eleOrWindow Supports both Elements and as a special\n *     case Windows.\n */\nfunction failedToLoad(eleOrWindow) {\n  // Mark the element as errored since some elements - like HTMLMediaElement\n  // using HTMLSourceElement - do not provide any synchronous way to verify if\n  // they already errored, even though the error event was already dispatched.\n  if (isHTMLMediaElement(eleOrWindow)) {\n    eleOrWindow[MEDIA_LOAD_FAILURE_SRC_PROPERTY] =\n      eleOrWindow.currentSrc || true;\n  }\n\n  // Report failed loads as user errors so that they automatically go\n  // into the \"document error\" bucket.\n  let target = eleOrWindow;\n  if (target && target.src) {\n    target = target.src;\n  }\n  throw user().createError(LOAD_FAILURE_PREFIX, target);\n}\n\n/**\n * Returns true if the parameter is a HTMLMediaElement.\n * @param {!Element|!Window} eleOrWindow\n * @return {boolean}\n */\nfunction isHTMLMediaElement(eleOrWindow) {\n  return eleOrWindow.tagName === 'AUDIO' || eleOrWindow.tagName === 'VIDEO';\n}\n\n/**\n * Returns true if this error message is was created for a load error.\n * @param {string} message An error message\n * @return {boolean}\n */\nexport function isLoadErrorMessage(message) {\n  return message.indexOf(LOAD_FAILURE_PREFIX) != -1;\n}\n", "import {map} from '#core/types/object';\n\n/**\n * @template T\n */\nexport class LruCache {\n  /**\n   * @param {number} capacity\n   */\n  constructor(capacity) {\n    /** @private @const {number} */\n    this.capacity_ = capacity;\n\n    /** @private {number} */\n    this.size_ = 0;\n\n    /**\n     * An incrementing counter to define the last access.\n     * @private {number}\n     */\n    this.access_ = 0;\n\n    /** @private {!Object<(number|string), {payload: T, access: number}>} */\n    this.cache_ = map();\n  }\n\n  /**\n   * Returns whether key is cached.\n   *\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  has(key) {\n    return !!this.cache_[key];\n  }\n\n  /**\n   * @param {number|string} key\n   * @return {T} The cached payload.\n   */\n  get(key) {\n    const cacheable = this.cache_[key];\n    if (cacheable) {\n      cacheable.access = ++this.access_;\n      return cacheable.payload;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {number|string} key\n   * @param {T} payload The payload to cache.\n   */\n  put(key, payload) {\n    if (!this.has(key)) {\n      this.size_++;\n    }\n    this.cache_[key] = {payload, access: this.access_};\n    this.evict_();\n  }\n\n  /**\n   * Evicts the oldest cache entry, if we've exceeded capacity.\n   */\n  evict_() {\n    if (this.size_ <= this.capacity_) {\n      return;\n    }\n\n    const cache = this.cache_;\n    let oldest = this.access_ + 1;\n    let oldestKey;\n    for (const key in cache) {\n      const {access} = cache[key];\n      if (access < oldest) {\n        oldest = access;\n        oldestKey = key;\n      }\n    }\n\n    if (oldestKey !== undefined) {\n      delete cache[oldestKey];\n      this.size_--;\n    }\n  }\n}\n", "import {LruCache} from '#core/data-structures/lru-cache';\nimport * as mode from '#core/mode';\nimport {arrayOrSingleItemToArray} from '#core/types/array';\nimport {dict, hasOwn} from '#core/types/object';\nimport {endsWith} from '#core/types/string';\nimport {parseQueryString} from '#core/types/string/url';\n\nimport {userAssert} from '#utils/log';\n\nimport {urls} from './config';\n\nconst SERVING_TYPE_PREFIX = new Set([\n  // No viewer\n  'c',\n  // In viewer\n  'v',\n  // Ad landing page\n  'a',\n  // Ad\n  'ad',\n]);\n\n/**\n * Cached a-tag to avoid memory allocation during URL parsing.\n * @type {HTMLAnchorElement}\n */\nlet cachedAnchorEl;\n\n/**\n * We cached all parsed URLs. As of now there are no use cases\n * of AMP docs that would ever parse an actual large number of URLs,\n * but we often parse the same one over and over again.\n * @type {LruCache}\n */\nlet urlCache;\n\n// eslint-disable-next-line no-script-url\nconst INVALID_PROTOCOLS = ['javascript:', 'data:', 'vbscript:'];\n\n/** @const {string} */\nexport const SOURCE_ORIGIN_PARAM = '__amp_source_origin';\n\n/**\n * Coerces a url into a location;\n * @function\n * @param {string|!Location} url\n * @return {!Location}\n */\nconst urlAsLocation = (url) =>\n  typeof url == 'string' ? parseUrlDeprecated(url) : url;\n\n/**\n * Returns the correct origin for a given window.\n * TODO(rcebulko): This really belongs under #core/window somewhere, not in url\n * @param {!Window} win\n * @return {string} origin\n */\nexport function getWinOrigin(win) {\n  return win.origin || parseUrlDeprecated(win.location.href).origin;\n}\n\n/**\n * Returns a Location-like object for the given URL. If it is relative,\n * the URL gets resolved.\n * Consider the returned object immutable. This is enforced during\n * testing by freezing the object.\n * TODO(#34453): The URL constructor isn't supported in IE11, but is supported\n * everywhere else. There's a lot of code paths (and all uses of the LruCache)\n * that are built around this polyfill. Once we can drop IE11 support and just\n * use the URL constructor, we can clear out all of parseWithA, all the URL\n * cache logic (incl. additional caches in other call-sites). Most is guarded by\n * isEsm() and is only included in nomodule builds, but still.\n * @param {string} url\n * @param {boolean=} opt_nocache\n *   Cache is always ignored on ESM builds, see https://go.amp.dev/pr/31594\n * @return {!Location}\n */\nexport function parseUrlDeprecated(url, opt_nocache) {\n  if (!cachedAnchorEl) {\n    cachedAnchorEl = /** @type {!HTMLAnchorElement} */ (\n      self.document.createElement('a')\n    );\n    urlCache = mode.isEsm()\n      ? null\n      : self.__AMP_URL_CACHE || (self.__AMP_URL_CACHE = new LruCache(100));\n  }\n\n  return parseUrlWithA(\n    cachedAnchorEl,\n    url,\n    mode.isEsm() || opt_nocache ? null : urlCache\n  );\n}\n\n/**\n * Returns a Location-like object for the given URL. If it is relative,\n * the URL gets resolved.\n * Consider the returned object immutable. This is enforced during\n * testing by freezing the object.\n * @param {!HTMLAnchorElement} anchorEl\n * @param {string} url\n * @param {LruCache=} opt_cache\n *   Cache is always ignored on ESM builds, see https://go.amp.dev/pr/31594\n * @return {!Location}\n * @restricted\n */\nexport function parseUrlWithA(anchorEl, url, opt_cache) {\n  if (mode.isEsm()) {\n    // Doing this causes the <a> to auto-set its own href to the resolved path,\n    // which would be the baseUrl for the URL constructor.\n    anchorEl.href = '';\n    return /** @type {?} */ (new URL(url, anchorEl.href));\n  }\n\n  if (opt_cache && opt_cache.has(url)) {\n    return opt_cache.get(url);\n  }\n\n  anchorEl.href = url;\n\n  // IE11 doesn't provide full URL components when parsing relative URLs.\n  // Assigning to itself again does the trick #3449.\n  if (!anchorEl.protocol) {\n    anchorEl.href = anchorEl.href;\n  }\n\n  const info = /** @type {!Location} */ ({\n    href: anchorEl.href,\n    protocol: anchorEl.protocol,\n    host: anchorEl.host,\n    hostname: anchorEl.hostname,\n    port: anchorEl.port == '0' ? '' : anchorEl.port,\n    pathname: anchorEl.pathname,\n    search: anchorEl.search,\n    hash: anchorEl.hash,\n    origin: null, // Set below.\n  });\n\n  // Some IE11 specific polyfills.\n  // 1) IE11 strips out the leading '/' in the pathname.\n  if (info.pathname[0] !== '/') {\n    info.pathname = '/' + info.pathname;\n  }\n\n  // 2) For URLs with implicit ports, IE11 parses to default ports while\n  // other browsers leave the port field empty.\n  if (\n    (info.protocol == 'http:' && info.port == 80) ||\n    (info.protocol == 'https:' && info.port == 443)\n  ) {\n    info.port = '';\n    info.host = info.hostname;\n  }\n\n  // For data URI anchorEl.origin is equal to the string 'null' which is not useful.\n  // We instead return the actual origin which is the full URL.\n  let origin;\n  if (anchorEl.origin && anchorEl.origin != 'null') {\n    origin = anchorEl.origin;\n  } else if (info.protocol == 'data:' || !info.host) {\n    origin = info.href;\n  } else {\n    origin = info.protocol + '//' + info.host;\n  }\n  info.origin = origin;\n\n  // Freeze during testing to avoid accidental mutation.\n  const frozen = mode.isTest() && Object.freeze ? Object.freeze(info) : info;\n\n  if (opt_cache) {\n    opt_cache.put(url, frozen);\n  }\n\n  return frozen;\n}\n\n/**\n * Appends the string just before the fragment part (or optionally\n * to the front of the query string) of the URL.\n * @param {string} url\n * @param {string} paramString\n * @param {boolean=} opt_addToFront\n * @return {string}\n */\nexport function appendEncodedParamStringToUrl(\n  url,\n  paramString,\n  opt_addToFront\n) {\n  if (!paramString) {\n    return url;\n  }\n  const mainAndFragment = url.split('#', 2);\n  const mainAndQuery = mainAndFragment[0].split('?', 2);\n\n  let newUrl =\n    mainAndQuery[0] +\n    (mainAndQuery[1]\n      ? opt_addToFront\n        ? `?${paramString}&${mainAndQuery[1]}`\n        : `?${mainAndQuery[1]}&${paramString}`\n      : `?${paramString}`);\n  newUrl += mainAndFragment[1] ? `#${mainAndFragment[1]}` : '';\n  return newUrl;\n}\n\n/**\n * @param {string} key\n * @param {string} value\n * @return {string}\n */\nfunction urlEncodeKeyValue(key, value) {\n  return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n}\n\n/**\n * Appends a query string field and value to a url. `key` and `value`\n * will be ran through `encodeURIComponent` before appending.\n * @param {string} url\n * @param {string} key\n * @param {string} value\n * @param {boolean=} opt_addToFront\n * @return {string}\n */\nexport function addParamToUrl(url, key, value, opt_addToFront) {\n  return appendEncodedParamStringToUrl(\n    url,\n    urlEncodeKeyValue(key, value),\n    opt_addToFront\n  );\n}\n\n/**\n * Appends query string fields and values to a url. The `params` objects'\n * `key`s and `value`s will be transformed into query string keys/values.\n * @param {string} url\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\nexport function addParamsToUrl(url, params) {\n  return appendEncodedParamStringToUrl(url, serializeQueryString(params));\n}\n\n/**\n * Append query string fields and values to a url, only if the key does not\n * exist in current query string.\n * @param {string} url\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\nexport function addMissingParamsToUrl(url, params) {\n  const location = parseUrlDeprecated(url);\n  const existingParams = parseQueryString(location.search);\n  const paramsToAdd = dict({});\n  const keys = Object.keys(params);\n  for (let i = 0; i < keys.length; i++) {\n    if (!hasOwn(existingParams, keys[i])) {\n      paramsToAdd[keys[i]] = params[keys[i]];\n    }\n  }\n  return addParamsToUrl(url, paramsToAdd);\n}\n\n/**\n * Serializes the passed parameter map into a query string with both keys\n * and values encoded.\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\nexport function serializeQueryString(params) {\n  const s = [];\n  for (const k in params) {\n    let v = params[k];\n    if (v == null) {\n      continue;\n    }\n\n    v = arrayOrSingleItemToArray(v);\n    for (let i = 0; i < v.length; i++) {\n      s.push(urlEncodeKeyValue(k, v[i]));\n    }\n  }\n  return s.join('&');\n}\n\n/**\n * Returns `true` if the URL is secure: either HTTPS or localhost (for testing).\n * @param {string|!Location} url\n * @return {boolean}\n */\nexport function isSecureUrlDeprecated(url) {\n  url = urlAsLocation(url);\n  return (\n    url.protocol == 'https:' ||\n    url.hostname == 'localhost' ||\n    url.hostname == '127.0.0.1' ||\n    endsWith(url.hostname, '.localhost')\n  );\n}\n\n/**\n * Asserts that a given url is HTTPS or protocol relative. It's a user-level\n * assert.\n *\n * Provides an exception for localhost.\n *\n * @param {?string|undefined} urlString\n * @param {!Element|string} elementContext Element where the url was found.\n * @param {string=} sourceName Used for error messages.\n * @return {string}\n */\nexport function assertHttpsUrl(\n  urlString,\n  elementContext,\n  sourceName = 'source'\n) {\n  userAssert(\n    urlString != null,\n    '%s %s must be available',\n    elementContext,\n    sourceName\n  );\n  userAssert(\n    isSecureUrlDeprecated(urlString) || /^\\/\\//.test(urlString),\n    '%s %s must start with ' +\n      '\"https://\" or \"//\" or be relative and served from ' +\n      'either https or from localhost. Invalid value: %s',\n    elementContext,\n    sourceName,\n    urlString\n  );\n  return urlString;\n}\n\n/**\n * Asserts that a given url is an absolute HTTP or HTTPS URL.\n * @param {string} urlString\n * @return {string}\n */\nexport function assertAbsoluteHttpOrHttpsUrl(urlString) {\n  userAssert(\n    /^https?\\:/i.test(urlString),\n    'URL must start with \"http://\" or \"https://\". Invalid value: %s',\n    urlString\n  );\n  return parseUrlDeprecated(urlString).href;\n}\n\n/**\n * Returns the URL without fragment. If URL doesn't contain fragment, the same\n * string is returned.\n * @param {string} url\n * @return {string}\n */\nexport function removeFragment(url) {\n  const index = url.indexOf('#');\n  if (index == -1) {\n    return url;\n  }\n  return url.substring(0, index);\n}\n\n/**\n * Returns the fragment from the URL. If the URL doesn't contain fragment,\n * the empty string is returned.\n * @param {string} url\n * @return {string}\n */\nexport function getFragment(url) {\n  const index = url.indexOf('#');\n  if (index == -1) {\n    return '';\n  }\n  return url.substring(index);\n}\n\n/**\n * Returns whether the URL has the origin of a proxy.\n * @param {string|!Location} url URL of an AMP document.\n * @return {boolean}\n */\nexport function isProxyOrigin(url) {\n  return urls.cdnProxyRegex.test(urlAsLocation(url).origin);\n}\n\n/**\n * Returns whether the URL origin is localhost.\n * @param {string|!Location} url URL of an AMP document.\n * @return {boolean}\n */\nexport function isLocalhostOrigin(url) {\n  return urls.localhostRegex.test(urlAsLocation(url).origin);\n}\n\n/**\n * @param {string} uri\n * @return {boolean}\n */\nexport function isAmpScriptUri(uri) {\n  return uri.startsWith('amp-script:');\n}\n\n/**\n * For proxy-origin URLs, returns the serving type. Otherwise, returns null.\n * E.g., 'https://amp-com.cdn.ampproject.org/a/s/amp.com/amp_document.html'\n * returns 'a'.\n * @param {string|!Location} url URL of an AMP document.\n * @return {?string}\n */\nexport function getProxyServingType(url) {\n  url = urlAsLocation(url);\n  if (!isProxyOrigin(url)) {\n    return null;\n  }\n  const path = url.pathname.split('/', 2);\n  return path[1];\n}\n\n/**\n * Returns whether the URL has valid protocol.\n * Deep link protocol is valid, but not javascript etc.\n * @param {string|!Location} url\n * @return {boolean}\n */\nexport function isProtocolValid(url) {\n  return !(url && INVALID_PROTOCOLS.includes(urlAsLocation(url).protocol));\n}\n\n/**\n * Returns a URL without AMP JS parameters.\n * @param {string} url\n * @return {string}\n */\nexport function removeAmpJsParamsFromUrl(url) {\n  const {hash, origin, pathname, search} = parseUrlDeprecated(url);\n  const searchRemoved = removeAmpJsParamsFromSearch(search);\n  return origin + pathname + searchRemoved + hash;\n}\n\n/**\n * Returns a URL without a query string.\n * @param {string} url\n * @return {string}\n */\nexport function removeSearch(url) {\n  const index = url.indexOf('?');\n  if (index == -1) {\n    return url;\n  }\n  const fragment = getFragment(url);\n  return url.substring(0, index) + fragment;\n}\n\n/**\n * Removes parameters that start with amp js parameter pattern and returns the\n * new search string.\n * @param {string} urlSearch\n * @return {string}\n */\nfunction removeAmpJsParamsFromSearch(urlSearch) {\n  // The below regex is a combo of these original patterns. Combining these,\n  // removing the corresponding `.replace` calls, and reusing\n  // removeParamsFromSearch saves ~175B. Matches params in query string:\n  // - /[?&]amp_js[^&]*/   amp_js_*\n  // - /[?&]amp_gsa[^&]*/  amp_gsa\n  // - /[?&]amp_r[^&]*/    amp_r\n  // - /[?&]amp_kit[^&]*/  amp_kit\n  // - /[?&]usqp[^&]*/     usqp (from goog experiment)\n  return removeParamsFromSearch(urlSearch, '(amp_(js[^&=]*|gsa|r|kit)|usqp)');\n}\n\n/**\n * Removes parameters with param name and returns the new search string.\n * @param {string} urlSearch\n * @param {string} paramName\n * @return {string}\n */\nexport function removeParamsFromSearch(urlSearch, paramName) {\n  // TODO: Accept paramNames as an array.\n  if (!urlSearch || urlSearch == '?') {\n    return '';\n  }\n  const paramRegex = new RegExp(`[?&]${paramName}\\\\b[^&]*`, 'g');\n  const search = urlSearch.replace(paramRegex, '').replace(/^[?&]/, '');\n  return search ? '?' + search : '';\n}\n\n/**\n * Returns the source URL of an AMP document for documents served\n * on a proxy origin or directly.\n * @param {string|!Location} url URL of an AMP document.\n * @return {string}\n */\nexport function getSourceUrl(url) {\n  url = urlAsLocation(url);\n\n  // Not a proxy URL - return the URL itself.\n  if (!isProxyOrigin(url)) {\n    return url.href;\n  }\n\n  // A proxy URL.\n  // Example path that is being matched here.\n  // https://cdn.ampproject.org/c/s/www.origin.com/foo/\n  // The /s/ is optional and signals a secure origin.\n  const path = url.pathname.split('/');\n  const prefix = path[1];\n  userAssert(\n    SERVING_TYPE_PREFIX.has(prefix),\n    'Unknown path prefix in url %s',\n    url.href\n  );\n  const domainOrHttpsSignal = path[2];\n  const origin =\n    domainOrHttpsSignal == 's'\n      ? 'https://' + decodeURIComponent(path[3])\n      : 'http://' + decodeURIComponent(domainOrHttpsSignal);\n  // Sanity test that what we found looks like a domain.\n  userAssert(origin.indexOf('.') > 0, 'Expected a . in origin %s', origin);\n  path.splice(1, domainOrHttpsSignal == 's' ? 3 : 2);\n  return (\n    origin +\n    path.join('/') +\n    removeAmpJsParamsFromSearch(url.search) +\n    (url.hash || '')\n  );\n}\n\n/**\n * Returns the source origin of an AMP document for documents served\n * on a proxy origin or directly.\n * @param {string|!Location} url URL of an AMP document.\n * @return {string} The source origin of the URL.\n */\nexport function getSourceOrigin(url) {\n  return parseUrlDeprecated(getSourceUrl(url)).origin;\n}\n\n/**\n * Returns absolute URL resolved based on the relative URL and the base.\n * @param {string} relativeUrlString\n * @param {string|!Location} baseUrl\n * @return {string}\n */\nexport function resolveRelativeUrl(relativeUrlString, baseUrl) {\n  baseUrl = urlAsLocation(baseUrl);\n  if (mode.isEsm() || typeof URL == 'function') {\n    return new URL(relativeUrlString, baseUrl.href).toString();\n  }\n  return resolveRelativeUrlFallback_(relativeUrlString, baseUrl);\n}\n\n/**\n * Fallback for URL resolver when URL class is not available.\n * @param {string} relativeUrlString\n * @param {string|!Location} baseUrl\n * @return {string}\n * @private @visibleForTesting\n */\nexport function resolveRelativeUrlFallback_(relativeUrlString, baseUrl) {\n  baseUrl = urlAsLocation(baseUrl);\n  relativeUrlString = relativeUrlString.replace(/\\\\/g, '/');\n  const relativeUrl = parseUrlDeprecated(relativeUrlString);\n\n  // Absolute URL.\n  if (relativeUrlString.toLowerCase().startsWith(relativeUrl.protocol)) {\n    return relativeUrl.href;\n  }\n\n  // Protocol-relative URL.\n  if (relativeUrlString.startsWith('//')) {\n    return baseUrl.protocol + relativeUrlString;\n  }\n\n  // Absolute path.\n  if (relativeUrlString.startsWith('/')) {\n    return baseUrl.origin + relativeUrlString;\n  }\n\n  // Relative path.\n  return (\n    baseUrl.origin +\n    baseUrl.pathname.replace(/\\/[^/]*$/, '/') +\n    relativeUrlString\n  );\n}\n\n/**\n * Add \"__amp_source_origin\" query parameter to the URL.\n * @param {!Window} win\n * @param {string} url\n * @return {string}\n */\nexport function getCorsUrl(win, url) {\n  checkCorsUrl(url);\n  const sourceOrigin = getSourceOrigin(win.location.href);\n  return addParamToUrl(url, SOURCE_ORIGIN_PARAM, sourceOrigin);\n}\n\n/**\n * Checks if the url has __amp_source_origin and throws if it does.\n * @param {string} url\n */\nexport function checkCorsUrl(url) {\n  const parsedUrl = parseUrlDeprecated(url);\n  const query = parseQueryString(parsedUrl.search);\n  userAssert(\n    !(SOURCE_ORIGIN_PARAM in query),\n    'Source origin is not allowed in %s',\n    url\n  );\n}\n\n/**\n * Adds the path to the given url.\n *\n * @param {!Location} url\n * @param {string} path\n * @return {string}\n */\nexport function appendPathToUrl(url, path) {\n  const pathname = url.pathname.replace(/\\/?$/, '/') + path.replace(/^\\//, '');\n  return url.origin + pathname + url.search + url.hash;\n}\n", "import {getValueForExpr} from '#core/types/object';\n\nimport {Services} from '#service';\n\nimport {user} from '#utils/log';\n\nimport {assertHttpsUrl} from './url';\n\n/**\n * Detail of each `options` property:\n * expr - Dot-syntax reference to subdata of JSON result to return. If not specified,\n *     entire JSON result is returned.\n * urlReplacement - If ALL, replaces all URL vars. If OPT_IN, replaces allowlisted\n *     URL vars. Otherwise, don't expand.\n * refresh - Forces refresh of browser cache.\n * xssiPrefix - Prefix to optionally strip from the response before calling parseJson.\n *\n * @typedef {{\n *  expr:(string|undefined),\n *  urlReplacement: (UrlReplacementPolicy|undefined),\n *  refresh: (boolean|undefined),\n *  xssiPrefix: (string|undefined),\n * }}\n */\nexport let BatchFetchOptionsDef;\n\n/**\n * @enum {number}\n */\nexport const UrlReplacementPolicy = {\n  NONE: 0,\n  OPT_IN: 1,\n  ALL: 2,\n};\n\n/**\n * Batch fetches the JSON endpoint at the given element's `src` attribute.\n * Sets the fetch credentials option from the element's `credentials` attribute,\n * if it exists.\n *\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {!Element} element\n * @param {!BatchFetchOptionsDef} options options bag for modifying the request.\n * @return {!Promise<!JsonObject|!Array<JsonObject>>} Resolved with JSON\n *     result or rejected if response is invalid.\n */\nexport function batchFetchJsonFor(ampdoc, element, options = {}) {\n  const {\n    expr = '.',\n    urlReplacement = UrlReplacementPolicy.NONE,\n    refresh = false,\n    xssiPrefix = undefined,\n  } = options;\n  assertHttpsUrl(element.getAttribute('src'), element);\n  const xhr = Services.batchedXhrFor(ampdoc.win);\n  return requestForBatchFetch(element, urlReplacement, refresh)\n    .then((data) => {\n      return xhr.fetchJson(data.xhrUrl, data.fetchOpt);\n    })\n    .then((res) => Services.xhrFor(ampdoc.win).xssiJson(res, xssiPrefix))\n    .then((data) => {\n      if (data == null) {\n        throw new Error('Response is undefined.');\n      }\n      return getValueForExpr(data, expr || '.');\n    })\n    .catch((err) => {\n      throw user().createError('failed fetching JSON data', err);\n    });\n}\n\n/**\n * Handles url replacement and constructs the FetchInitJsonDef required for a\n * fetch.\n * @param {!Element} element\n * @param {!UrlReplacementPolicy} replacement If ALL, replaces all URL\n *     vars. If OPT_IN, replaces allowlisted URL vars. Otherwise, don't expand.\n * @param {boolean} refresh Forces refresh of browser cache.\n * @return {!Promise<!FetchRequestDef>}\n */\nexport function requestForBatchFetch(element, replacement, refresh) {\n  const url = element.getAttribute('src');\n\n  // Replace vars in URL if desired.\n  const urlReplacements = Services.urlReplacementsForDoc(element);\n  const promise =\n    replacement >= UrlReplacementPolicy.OPT_IN\n      ? urlReplacements.expandUrlAsync(url)\n      : Promise.resolve(url);\n\n  return promise.then((xhrUrl) => {\n    // Throw user error if this element is performing URL substitutions\n    // without the soon-to-be-required opt-in (#12498).\n    if (replacement == UrlReplacementPolicy.OPT_IN) {\n      const invalid = urlReplacements.collectDisallowedVarsSync(element);\n      if (invalid.length > 0) {\n        throw user().createError(\n          'URL variable substitutions in CORS ' +\n            'fetches from dynamic URLs (e.g. via amp-bind) require opt-in. ' +\n            `Please add data-amp-replace=\"${invalid.join(' ')}\" to the ` +\n            `<${element.tagName}> element. See https://bit.ly/amp-var-subs.`\n        );\n      }\n    }\n    const fetchOpt = {};\n    if (element.hasAttribute('credentials')) {\n      fetchOpt.credentials = element.getAttribute('credentials');\n    }\n    // https://hacks.mozilla.org/2016/03/referrer-and-cache-control-apis-for-fetch/\n    if (refresh) {\n      fetchOpt.cache = 'reload';\n    }\n    return {'xhrUrl': xhrUrl, 'fetchOpt': fetchOpt};\n  });\n}\n", "import {ActionTrust} from '#core/constants/action-constants';\nimport {Deferred} from '#core/data-structures/promise';\nimport {isJsonScriptTag} from '#core/dom';\nimport {LayoutPriority} from '#core/dom/layout';\nimport {toggle} from '#core/dom/style';\nimport {dict, map} from '#core/types/object';\nimport {tryParseJson} from '#core/types/object/json';\n\nimport {Services} from '#service';\n\nimport {createCustomEvent} from '#utils/event-helper';\nimport {dev, devAssert, userAssert} from '#utils/log';\n\nimport {\n  UrlReplacementPolicy,\n  batchFetchJsonFor,\n} from '../../../src/batched-json';\nimport {getSourceOrigin} from '../../../src/url';\n\nexport class AmpState extends AMP.BaseElement {\n  /**\n   * @param {!Element} element\n   */\n  constructor(element) {\n    super(element);\n\n    /**\n     * JSON in child <script>, if any.\n     * - `undefined` if the script has never been parsed.\n     * - `null` or `!JsonObject` once the script has been parsed.\n     * @private {?JsonObject|undefined}\n     */\n    this.localData_ = undefined;\n\n    /** @private {!Deferred} */\n    this.loadingDeferred_ = new Deferred();\n  }\n\n  /** @override */\n  getLayoutPriority() {\n    // Loads after other content.\n    return LayoutPriority.METADATA;\n  }\n\n  /** @override */\n  isAlwaysFixed() {\n    return true;\n  }\n\n  /** @override */\n  isLayoutSupported(unusedLayout) {\n    return true;\n  }\n\n  /** @override */\n  buildCallback() {\n    toggle(this.element, /* opt_display */ false);\n    this.element.setAttribute('aria-hidden', 'true');\n\n    const {element} = this;\n    if (element.hasAttribute('overridable')) {\n      Services.bindForDocOrNull(element).then((bind) => {\n        devAssert(bind);\n        bind.addOverridableKey(element.getAttribute('id'));\n      });\n    }\n    // Parse child <script> tag and/or fetch JSON from `src` attribute.\n    // The latter is allowed to overwrite the former.\n    this.parseAndUpdate();\n    if (this.element.hasAttribute('src')) {\n      this.fetchAndUpdate_(/* isInit */ true);\n    }\n\n    this.registerAction('refresh', () => {\n      userAssert(\n        this.element.hasAttribute('src'),\n        'Can\\'t refresh <amp-state> without \"src\" attribute.'\n      );\n      this.fetchAndUpdate_(/* isInit */ false, /* opt_refresh */ true);\n    });\n  }\n\n  /** @override */\n  mutatedAttributesCallback(mutations) {\n    if (!this.getAmpDoc().hasBeenVisible()) {\n      const TAG = this.getName_();\n      dev().error(TAG, 'ampdoc must be visible before mutation.');\n      return;\n    }\n    // \"src\" attribute may be missing if mutated with a non-primitive.\n    if (mutations['src'] !== undefined && this.element.hasAttribute('src')) {\n      this.fetchAndUpdate_(/* isInit */ false);\n    }\n  }\n\n  /** @override */\n  renderOutsideViewport() {\n    // We want the state data to be available wherever it is in the document.\n    return true;\n  }\n\n  /**\n   * Parses JSON in child <script> and updates state.\n   * @return {!Promise}\n   */\n  parseAndUpdate() {\n    if (this.localData_ === undefined) {\n      this.localData_ = this.parse_();\n      if (this.localData_ !== null) {\n        return this.updateState_(this.localData_, /* isInit */ true);\n      }\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Parses JSON in child <script> and returns it.\n   * @return {?JsonObject}\n   * @private\n   */\n  parse_() {\n    const {children} = this.element;\n    if (children.length == 0) {\n      return null;\n    }\n    const TAG = this.getName_();\n    if (children.length != 1) {\n      this.user().error(TAG, 'Should contain exactly one <script> child.');\n      return null;\n    }\n    const firstChild = children[0];\n    if (!isJsonScriptTag(firstChild)) {\n      this.user().error(\n        TAG,\n        'State should be in a <script> tag with type=\"application/json\".'\n      );\n      return null;\n    }\n    return tryParseJson(firstChild.textContent, (e) => {\n      this.user().error(TAG, 'Failed to parse state. Is it valid JSON?', e);\n    });\n  }\n\n  /**\n   * Wrapper to stub during testing.\n   * @param {!../../../src/service/ampdoc-impl.AmpDoc} ampdoc\n   * @param {!UrlReplacementPolicy} policy\n   * @param {boolean=} opt_refresh\n   * @return {!Promise<!JsonObject|!Array<JsonObject>>}\n   * @private\n   */\n  fetch_(ampdoc, policy, opt_refresh) {\n    return batchFetchJsonFor(ampdoc, this.element, {\n      urlReplacement: policy,\n      refresh: opt_refresh,\n    });\n  }\n\n  /**\n   * Transforms and prepares the fetch request.\n   * @param {boolean} isInit\n   * @param {boolean=} opt_refresh\n   * @return {!Promise<!JsonObject|!Array<JsonObject>|undefined>}\n   */\n  prepareAndSendFetch_(isInit, opt_refresh) {\n    const {element} = this;\n    const ampdoc = this.getAmpDoc();\n\n    const src = element.getAttribute('src');\n    const isCorsFetch =\n      getSourceOrigin(src) !== getSourceOrigin(ampdoc.win.location);\n    // Require opt-in for URL variable replacements on CORS fetches triggered\n    // by [src] mutation. @see spec/amp-var-substitutions.md\n    const policy =\n      isCorsFetch && !isInit\n        ? UrlReplacementPolicy.OPT_IN\n        : UrlReplacementPolicy.ALL;\n\n    return this.fetch_(ampdoc, policy, opt_refresh).catch((error) => {\n      const event = error\n        ? createCustomEvent(\n            this.win,\n            'amp-state.error',\n            dict({'response': error.response})\n          )\n        : null;\n      // Trigger \"fetch-error\" event on fetch failure.\n      const actions = Services.actionServiceForDoc(element);\n      actions.trigger(element, 'fetch-error', event, ActionTrust.LOW);\n    });\n  }\n\n  /**\n   * @param {boolean} isInit\n   * @param {boolean=} opt_refresh\n   * @return {!Promise}\n   * @private\n   */\n  fetchAndUpdate_(isInit, opt_refresh) {\n    // On init, we reuse the deferred created in the constructor.\n    if (!isInit) {\n      this.loadingDeferred_ = new Deferred();\n    }\n\n    // Store the deferred locally, in case a new fetch overwrites\n    // it before resolution.\n    const loadingDeferred = this.loadingDeferred_;\n\n    // Don't fetch in prerender mode.\n    return this.getAmpDoc()\n      .whenFirstVisible()\n      .then(() => this.prepareAndSendFetch_(isInit, opt_refresh))\n      .then((json) => this.updateState_(json, isInit))\n      .then(() => loadingDeferred.resolve())\n      .catch((err) => {\n        loadingDeferred.resolve();\n        throw err;\n      });\n  }\n\n  /**\n   * For an \"amp-state\" with a src attribute, this returns a promise that\n   * resolves after the fetch and update completes. For non-src \"amp-state\"s,\n   * return a resolved promise.\n   *\n   * @return {!Promise}\n   */\n  getFetchingPromise() {\n    if (!this.element.hasAttribute('src')) {\n      return Promise.resolve();\n    }\n    return this.loadingDeferred_.promise;\n  }\n\n  /**\n   * @param {*} json\n   * @param {boolean} isInit\n   * @return {!Promise}\n   * @private\n   */\n  updateState_(json, isInit) {\n    if (json === undefined || json === null) {\n      return Promise.resolve();\n    }\n    const id = userAssert(this.element.id, '<amp-state> must have an id.');\n    return Services.bindForDocOrNull(this.element).then((bind) => {\n      devAssert(bind);\n      const state = /** @type {!JsonObject} */ (map());\n      state[id] = json;\n      // As a rule, initialization should skip evaluation.\n      // If we're not initializing then this must be a mutation, so we must\n      // skip <amp-state> evaluation to prevent update cycles.\n      bind.setState(state, {skipEval: isInit, skipAmpState: !isInit});\n    });\n  }\n\n  /**\n   * @return {string} Returns a string to identify this tag. May not be unique\n   *     if the element id is not unique.\n   * @private\n   */\n  getName_() {\n    return '<amp-state> ' + (this.element.getAttribute('id') || '<unknown id>');\n  }\n}\n", "/**\n * Common AMP events.\n * @enum {string}\n */\nexport const AmpEvents = {\n  DOM_UPDATE: 'amp:dom-update',\n  FORM_DIRTINESS_CHANGE: 'amp:form-dirtiness-change',\n  FORM_VALUE_CHANGE: 'amp:form-value-change',\n  VISIBILITY_CHANGE: 'amp:visibilitychange', // https://github.com/ampproject/amphtml/blob/main/ads/README.md#page-visibility\n  // The following codes are only used for testing.\n  // TODO(choumx): Move these to a separate enum so they can be DCE'd.\n  ATTACHED: 'amp:attached',\n  STUBBED: 'amp:stubbed',\n  LOAD_START: 'amp:load-start',\n  LOAD_END: 'amp:load-end',\n  ERROR: 'amp:error',\n  SIZE_CHANGED: 'amp:size-changed',\n  UNLOAD: 'amp:unload',\n};\n", "import {TimestampDef} from '#core/types/date';\nimport {map} from '#core/types/object';\n\nimport {Deferred} from './promise';\n\n/**\n * This object tracts signals and allows blocking until a signal has been\n * received.\n */\nexport class Signals {\n  /**\n   * Creates an instance of Signals.\n   */\n  constructor() {\n    /**\n     * A mapping from a signal name to the signal response: either time or\n     * an error.\n     * @private @const {!Object<string, (!TimestampDef|!Error)>}\n     */\n    this.map_ = map();\n\n    /**\n     * A mapping from a signal name to the signal promise, resolve and reject.\n     * Only allocated when promise has been requested.\n     * @private {?Object<string, {\n     *   promise: !Promise,\n     *   resolve: (function(!TimestampDef)|undefined),\n     *   reject: (function(!Error)|undefined)\n     * }>}\n     */\n    this.promiseMap_ = null;\n  }\n\n  /**\n   * Returns the current known value of the signal. If signal is not yet\n   * available, `null` is returned.\n   * @param {string} name\n   * @return {number|!Error|null}\n   */\n  get(name) {\n    const v = this.map_[name];\n    return v == null ? null : v;\n  }\n\n  /**\n   * Returns the promise that's resolved when the signal is triggered. The\n   * resolved value is the time of the signal.\n   * @param {string} name\n   * @return {!Promise<!TimestampDef>}\n   */\n  whenSignal(name) {\n    let promiseStruct = this.promiseMap_?.[name];\n    if (!promiseStruct) {\n      const result = this.map_[name];\n      if (result != null) {\n        // Immediately resolve signal.\n        const promise =\n          typeof result == 'number'\n            ? Promise.resolve(result)\n            : Promise.reject(result);\n        promiseStruct = {promise};\n      } else {\n        // Allocate the promise/resolver for when the signal arrives in the\n        // future.\n        promiseStruct = new Deferred();\n      }\n      if (!this.promiseMap_) {\n        this.promiseMap_ = map();\n      }\n      this.promiseMap_[name] = promiseStruct;\n    }\n    return promiseStruct.promise;\n  }\n\n  /**\n   * Triggers the signal with the specified name on the element. The time is\n   * optional; if not provided, the current time is used. The associated\n   * promise is resolved with the resulting TimestampDef.\n   * @param {string} name\n   * @param {!TimestampDef=} opt_time\n   */\n  signal(name, opt_time) {\n    if (this.map_[name] != null) {\n      // Do not duplicate signals.\n      return;\n    }\n    const time = opt_time ?? Date.now();\n    this.map_[name] = time;\n    const promiseStruct = this.promiseMap_?.[name];\n    if (promiseStruct?.resolve) {\n      promiseStruct.resolve(time);\n      promiseStruct.resolve = undefined;\n      promiseStruct.reject = undefined;\n    }\n  }\n\n  /**\n   * Rejects the signal. Indicates that the signal will never succeed. The\n   * associated signal is rejected.\n   * @param {string} name\n   * @param {!Error} error\n   */\n  rejectSignal(name, error) {\n    if (this.map_[name] != null) {\n      // Do not duplicate signals.\n      return;\n    }\n    this.map_[name] = error;\n    const promiseStruct = this.promiseMap_?.[name];\n    if (promiseStruct?.reject) {\n      promiseStruct.reject(error);\n      promiseStruct.promise.catch(() => {});\n      promiseStruct.resolve = undefined;\n      promiseStruct.reject = undefined;\n    }\n  }\n\n  /**\n   * Resets all signals.\n   * @param {string} name\n   */\n  reset(name) {\n    if (this.map_[name]) {\n      delete this.map_[name];\n    }\n    // Reset promise it has already been resolved.\n    const promiseStruct = this.promiseMap_?.[name];\n    if (promiseStruct && !promiseStruct.resolve) {\n      delete this.promiseMap_[name];\n    }\n  }\n}\n", "/**\n * Checks that the document is of an AMP format type.\n * @param {!Array<string>} formats\n * @param {!Document} doc\n * @return {boolean}\n */\nfunction isAmpFormatType(formats, doc) {\n  const html = doc.documentElement;\n  const isFormatType = formats.some((format) => html.hasAttribute(format));\n  return isFormatType;\n}\n\n/**\n * @param {!Document} doc\n * @return {boolean}\n */\nexport function isAmp4Email(doc) {\n  return isAmpFormatType(['\u26A14email', 'amp4email'], doc);\n}\n\n/**\n * @param {!Document} doc\n * @return {boolean}\n */\nexport function isAmphtml(doc) {\n  return isAmpFormatType(['\u26A1', 'amp'], doc);\n}\n", "import {devAssert} from '#core/assert';\nimport {Deferred} from '#core/data-structures/promise';\n\n/** @const {string} */\nexport const UPGRADE_TO_CUSTOMELEMENT_PROMISE = '__AMP_UPG_PRM';\n\n/** @const {string} */\nexport const UPGRADE_TO_CUSTOMELEMENT_RESOLVER = '__AMP_UPG_RES';\n\n/**\n * Determines if this element is an AMP element\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isAmpElement(element) {\n  const tag = element.tagName;\n  // Use prefix to recognize AMP element. This is necessary because stub\n  // may not be attached yet.\n  return (\n    tag.startsWith('AMP-') &&\n    // Some \"amp-*\" elements are not really AMP elements. :smh:\n    !(tag == 'AMP-STICKY-AD-TOP-PADDING' || tag == 'AMP-BODY')\n  );\n}\n\n/**\n * Return a promise that resolve when an AMP element upgrade from HTMLElement\n * to CustomElement\n * @param {!HTMLElement} element\n * @return {!Promise<!AmpElement>}\n */\nexport function whenUpgradedToCustomElement(element) {\n  devAssert(isAmpElement(element), 'element is not AmpElement');\n  if (element.createdCallback) {\n    // Element already is CustomElement;\n    return Promise.resolve(/**@type {!AmpElement} */ (element));\n  }\n  // If Element is still HTMLElement, wait for it to upgrade to customElement\n  // Note: use pure string to avoid obfuscation between versions.\n  if (!element[UPGRADE_TO_CUSTOMELEMENT_PROMISE]) {\n    const deferred = new Deferred();\n    element[UPGRADE_TO_CUSTOMELEMENT_PROMISE] = deferred.promise;\n    element[UPGRADE_TO_CUSTOMELEMENT_RESOLVER] = deferred.resolve;\n  }\n\n  return element[UPGRADE_TO_CUSTOMELEMENT_PROMISE];\n}\n", "/**\n * TODO(choumx, #19657): Remove/replace with DOM polling in integration tests.\n * @enum {string}\n */\nexport const BindEvents = {\n  INITIALIZE: 'amp:bind:initialize',\n  RESCAN_TEMPLATE: 'amp:bind:rescan-template',\n  SET_STATE: 'amp:bind:setState',\n};\n", "import {devAssert, userAssert} from '#core/assert';\n\n/**\n * A single source within a srcset. Only one: width or DPR can be specified at\n * a time.\n * @typedef {{\n *   url: string,\n *   width: (number|undefined),\n *   dpr: (number|undefined)\n * }}\n */\nlet SrcsetSourceDef;\n\n/**\n * General grammar: (URL [NUM[w|x]],)*\n * Example 1: \"image1.png 100w, image2.png 50w\"\n * Example 2: \"image1.png 2x, image2.png\"\n * Example 3: \"image1,100w.png 100w, image2.png 50w\"\n */\nconst srcsetRegex = /(\\S+)(?:\\s+(?:(-?\\d+(?:\\.\\d+)?)([a-zA-Z]*)))?\\s*(?:,|$)/g;\n\n/**\n * Extracts `srcset` and fallbacks to `src` if not available.\n * @param {!Element} element\n * @return {!Srcset}\n */\nexport function srcsetFromElement(element) {\n  const srcsetAttr = element.getAttribute('srcset');\n  if (srcsetAttr) {\n    return parseSrcset(srcsetAttr);\n  }\n  // We can't push `src` via `parseSrcset` because URLs in `src` are not always\n  // RFC compliant and can't be easily parsed as an `srcset`. For instance,\n  // they sometimes contain space characters.\n  const srcAttr = userAssert(\n    element.getAttribute('src'),\n    'Either non-empty \"srcset\" or \"src\" attribute must be specified: %s',\n    element\n  );\n  return srcsetFromSrc(srcAttr);\n}\n\n/**\n * Creates a Srcset from a `src` attribute value.\n * @param {string} src\n * @return {!Srcset}\n */\nexport function srcsetFromSrc(src) {\n  return new Srcset([{url: src, width: undefined, dpr: 1}]);\n}\n\n/**\n * Parses the text representation of srcset into Srcset object.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#Attributes.\n * See http://www.w3.org/html/wg/drafts/html/master/semantics.html#attr-img-srcset.\n * @param {string} s\n * @return {!Srcset}\n */\nexport function parseSrcset(s) {\n  const sources = [];\n  let match;\n  while ((match = srcsetRegex.exec(s))) {\n    const url = match[1];\n    let width, dpr;\n    if (match[2]) {\n      const type = match[3].toLowerCase();\n      if (type == 'w') {\n        width = parseInt(match[2], 10);\n      } else if (type == 'x') {\n        dpr = parseFloat(match[2]);\n      } else {\n        continue;\n      }\n    } else {\n      // If no \"w\" or \"x\" specified, we assume it's \"1x\".\n      dpr = 1;\n    }\n    sources.push({url, width, dpr});\n  }\n  return new Srcset(sources);\n}\n\n/**\n * A srcset object contains one or more sources.\n *\n * There are two types of sources: width-based and DPR-based. Only one type\n * of sources allowed to be specified within a single srcset. Depending on a\n * usecase, the components are free to choose any source that best corresponds\n * to the required rendering quality and network and CPU conditions. See\n * \"select\" method for details on how this selection is performed.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#Attributes\n */\nexport class Srcset {\n  /**\n   * @param {!Array<!SrcsetSourceDef>} sources\n   */\n  constructor(sources) {\n    userAssert(sources.length > 0, 'Srcset must have at least one source');\n    /** @private @const {!Array<!SrcsetSourceDef>} */\n    this.sources_ = sources;\n\n    // Only one type of source specified can be used - width or DPR.\n    let hasWidth = false;\n    let hasDpr = false;\n    for (let i = 0; i < sources.length; i++) {\n      const source = sources[i];\n      hasWidth = hasWidth || !!source.width;\n      hasDpr = hasDpr || !!source.dpr;\n    }\n    userAssert(\n      !!(hasWidth ^ hasDpr),\n      'Srcset must have width or dpr sources, but not both'\n    );\n\n    // Source and assert duplicates.\n    sources.sort(hasWidth ? sortByWidth : sortByDpr);\n\n    /** @private @const {boolean} */\n    this.widthBased_ = hasWidth;\n  }\n\n  /**\n   * Performs selection for specified width and DPR. Here, width is the width\n   * in screen pixels and DPR is the device-pixel-ratio or pixel density of\n   * the device. Depending on the circumstances, such as low network conditions,\n   * it's possible to manipulate the result of this method by passing a lower\n   * DPR value.\n   *\n   * The source selection depends on whether this is width-based or DPR-based\n   * srcset.\n   *\n   * In a width-based source, the source's width is the physical width of a\n   * resource (e.g. an image). Depending on the provided DPR, this width is\n   * converted to the screen pixels as following:\n   *   pixelWidth = sourceWidth / DPR\n   *\n   * Then, the source closest to the requested \"width\" is selected using\n   * the \"pixelWidth\". The slight preference is given to the bigger sources to\n   * ensure the most optimal quality.\n   *\n   * In a DPR-based source, the source's DPR is used to return the source that\n   * is closest to the requested DPR.\n   *\n   * Based on\n   * http://www.w3.org/html/wg/drafts/html/master/semantics.html#attr-img-srcset.\n   * @param {number} width\n   * @param {number} dpr\n   * @return {string}\n   */\n  select(width, dpr) {\n    devAssert(width, 'width=%s', width);\n    devAssert(dpr, 'dpr=%s', dpr);\n    let index = 0;\n    if (this.widthBased_) {\n      index = this.selectByWidth_(width * dpr);\n    } else {\n      index = this.selectByDpr_(dpr);\n    }\n    return this.sources_[index].url;\n  }\n\n  /**\n   * @param {number} width\n   * @return {number}\n   * @private\n   */\n  selectByWidth_(width) {\n    const sources = this.sources_;\n    let minIndex = 0;\n    let minScore = Infinity;\n    let minWidth = Infinity;\n\n    for (let i = 0; i < sources.length; i++) {\n      const sWidth = sources[i].width;\n      const score = Math.abs(sWidth - width);\n\n      // Select the one that is closer with a slight preference toward larger\n      // widths. If smaller size is closer, enforce minimum ratio to ensure\n      // image isn't too distorted.\n      if (score <= minScore * 1.1 || width / minWidth > 1.2) {\n        minIndex = i;\n        minScore = score;\n        minWidth = sWidth;\n      } else {\n        break;\n      }\n    }\n    return minIndex;\n  }\n\n  /**\n   * @param {number} dpr\n   * @return {number}\n   * @private\n   */\n  selectByDpr_(dpr) {\n    const sources = this.sources_;\n    let minIndex = 0;\n    let minScore = Infinity;\n\n    for (let i = 0; i < sources.length; i++) {\n      const score = Math.abs(sources[i].dpr - dpr);\n      if (score <= minScore) {\n        minIndex = i;\n        minScore = score;\n      } else {\n        break;\n      }\n    }\n    return minIndex;\n  }\n\n  /**\n   * Returns all URLs in the srcset.\n   * @return {!Array<string>}\n   */\n  getUrls() {\n    return this.sources_.map((s) => s.url);\n  }\n\n  /**\n   * Reconstructs the string expression for this srcset.\n   * @param {function(string):string=} opt_mapper\n   * @return {string}\n   */\n  stringify(opt_mapper) {\n    const res = [];\n    const sources = this.sources_;\n    for (let i = 0; i < sources.length; i++) {\n      const source = sources[i];\n      let src = source.url;\n      if (opt_mapper) {\n        src = opt_mapper(src);\n      }\n      if (this.widthBased_) {\n        src += ` ${source.width}w`;\n      } else {\n        src += ` ${source.dpr}x`;\n      }\n      res.push(src);\n    }\n    return res.join(', ');\n  }\n}\n\n/**\n * Sorts by width\n *\n * @param {!SrcsetSourceDef} s1\n * @param {!SrcsetSourceDef} s2\n * @return {number}\n */\nfunction sortByWidth(s1, s2) {\n  userAssert(s1.width != s2.width, 'Duplicate width: %s', s1.width);\n  return s1.width - s2.width;\n}\n\n/**\n * Sorts by dpr\n *\n * @param {!SrcsetSourceDef} s1\n * @param {!SrcsetSourceDef} s2\n * @return {number}\n */\nfunction sortByDpr(s1, s2) {\n  userAssert(s1.dpr != s2.dpr, 'Duplicate dpr: %s', s1.dpr);\n  return s1.dpr - s2.dpr;\n}\n", "import {parseSrcset} from '#core/dom/srcset';\nimport {hasOwn, ownProperty} from '#core/types/object';\n\nimport {user} from '#utils/log';\n\nconst TAG = 'amp-bind';\n\n/**\n * @typedef {{\n *   allowedProtocols: (!Object<string,boolean>|undefined),\n *   alternativeName: (string|undefined),\n * }}\n */\nlet PropertyRulesDef;\n\n/**\n * Property rules that apply to any and all tags.\n * @private {Object<string, ?PropertyRulesDef>}\n */\nconst GLOBAL_PROPERTY_RULES = {\n  'class': {\n    denylistedValueRegex: '(^|\\\\W)i-amphtml-',\n  },\n  'hidden': null,\n  'text': null,\n};\n\n/**\n * Property rules that apply to all AMP elements.\n * @private {Object<string, ?PropertyRulesDef>}\n */\nconst AMP_PROPERTY_RULES = {\n  'width': null,\n  'height': null,\n};\n\n/**\n * Maps tag names to property names to PropertyRulesDef.\n * If `ELEMENT_RULES[tag][property]` is null, then all values are valid\n * for that property in that tag.\n * @private {Object<string, Object<string, ?PropertyRulesDef>>}}\n */\nconst ELEMENT_RULES = createElementRules_();\n\n/**\n * Map whose keys comprise all properties that contain URLs.\n * @private {Object<string, boolean>}\n */\nconst URL_PROPERTIES = {\n  'src': true,\n  'srcset': true,\n  'href': true,\n  'xlink:href': true,\n};\n\n/**\n * BindValidator performs runtime validation of Bind expression results.\n *\n * For performance reasons, the validation rules enforced are a subset\n * of the AMP validator's, selected with a focus on security and UX.\n */\nexport class BindValidator {\n  /**\n   * @param {boolean} allowUrlBindings\n   */\n  constructor(allowUrlBindings) {\n    /** @const @private {boolean} */\n    this.allowUrlBindings_ = allowUrlBindings;\n  }\n\n  /**\n   * Returns true if (tag, property) binding is allowed.\n   * Otherwise, returns false.\n   * NOTE: `tag` and `property` are case-sensitive.\n   * @param {string} tag\n   * @param {string} property\n   * @return {boolean}\n   */\n  canBind(tag, property) {\n    return this.rulesForTagAndProperty_(tag, property) !== undefined;\n  }\n\n  /**\n   * Returns true if `value` is a valid result for a (tag, property) binding.\n   * Otherwise, returns false.\n   * @param {string} tag\n   * @param {string} property\n   * @param {?string} value\n   * @return {boolean}\n   */\n  isResultValid(tag, property, value) {\n    let rules = this.rulesForTagAndProperty_(tag, property);\n    // `alternativeName` is a reference to another property's rules.\n    if (rules && rules.alternativeName) {\n      rules = this.rulesForTagAndProperty_(tag, rules.alternativeName);\n    }\n    // If binding to (tag, property) is not allowed, return false.\n    if (rules === undefined) {\n      return false;\n    }\n    // If binding is allowed but have no specific rules, return true.\n    if (rules === null) {\n      return true;\n    }\n    // Validate URL(s) if applicable.\n    if (value && ownProperty(URL_PROPERTIES, property)) {\n      let urls;\n      if (property === 'srcset') {\n        let srcset;\n        try {\n          srcset = parseSrcset(value);\n        } catch (e) {\n          user().error(TAG, 'Failed to parse srcset: ', e);\n          return false;\n        }\n        urls = srcset.getUrls();\n      } else {\n        urls = [value];\n      }\n      for (let i = 0; i < urls.length; i++) {\n        if (!this.isUrlValid_(urls[i], rules)) {\n          return false;\n        }\n      }\n    }\n    // @see validator/js/engine/validator.ParsedTagSpec.validateAttributes()\n    const {denylistedValueRegex} = rules;\n    if (value && denylistedValueRegex) {\n      const re = new RegExp(denylistedValueRegex, 'i');\n      if (re.test(value)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns true if a url's value is valid within a property rules spec.\n   * @param {string} url\n   * @param {!PropertyRulesDef} rules\n   * @return {boolean}\n   * @private\n   */\n  isUrlValid_(url, rules) {\n    // @see validator/js/engine/validator.js#validateUrlAndProtocol()\n    if (url) {\n      if (/__amp_source_origin/.test(url)) {\n        return false;\n      }\n      const {allowedProtocols} = rules;\n      if (allowedProtocols) {\n        const re = /^([^:\\/?#.]+):[\\s\\S]*$/;\n        const match = re.exec(url);\n        if (match !== null) {\n          const protocol = match[1].toLowerCase().trim();\n          // hasOwn() needed since nested objects are not prototype-less.\n          if (!hasOwn(allowedProtocols, protocol)) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the property rules object for (tag, property), if it exists.\n   * Returns null if binding is allowed without constraints.\n   * Returns undefined if binding is not allowed.\n   * @param {string} tag\n   * @param {string} property\n   * @return {(?PropertyRulesDef|undefined)}\n   * @private\n   */\n  rulesForTagAndProperty_(tag, property) {\n    // Allow binding to all ARIA attributes.\n    if (property.startsWith('aria-')) {\n      return null;\n    }\n    // Disallow URL property bindings if configured as such.\n    if (ownProperty(URL_PROPERTIES, property) && !this.allowUrlBindings_) {\n      return undefined;\n    }\n    const globalRules = ownProperty(GLOBAL_PROPERTY_RULES, property);\n    if (globalRules !== undefined) {\n      return /** @type {PropertyRulesDef} */ (globalRules);\n    }\n    const ampPropertyRules = ownProperty(AMP_PROPERTY_RULES, property);\n    if (tag.startsWith('AMP-') && ampPropertyRules !== undefined) {\n      return /** @type {PropertyRulesDef} */ (ampPropertyRules);\n    }\n    const tagRules = ownProperty(ELEMENT_RULES, tag);\n    if (tagRules) {\n      return tagRules[property];\n    }\n    return undefined;\n  }\n}\n\n/**\n * @return {Object<string, Object<string, ?PropertyRulesDef>>}}\n * @private\n */\nfunction createElementRules_() {\n  // Initialize `rules` with tag-specific constraints.\n  const rules = {\n    'AMP-AUDIO': {\n      'album': null,\n      'artist': null,\n      'artwork': null,\n      'controlsList': null,\n      'loop': null,\n      'src': {\n        'allowedProtocols': {\n          'https': true,\n        },\n      },\n      'title': null,\n    },\n    'AMP-AUTOCOMPLETE': {\n      'src': {\n        'allowedProtocols': {\n          'https': true,\n        },\n      },\n    },\n    'AMP-BASE-CAROUSEL': {\n      'advance-count': null,\n      'auto-advance-count': null,\n      'auto-advance-interval': null,\n      'auto-advance-loops': null,\n      'auto-advance': null,\n      'horizontal': null,\n      'initial-index': null,\n      'loop': null,\n      'mixed-length': null,\n      'side-slide-count': null,\n      'slide': null,\n      'snap-align': null,\n      'snap-by': null,\n      'snap': null,\n      'visible-count': null,\n    },\n    'AMP-BRIGHTCOVE': {\n      'data-account': null,\n      'data-embed': null,\n      'data-player': null,\n      'data-player-id': null,\n      'data-playlist-id': null,\n      'data-video-id': null,\n    },\n    'AMP-CAROUSEL': {\n      'slide': null,\n    },\n    'AMP-DATE-PICKER': {\n      'max': null,\n      'min': null,\n      'src': {\n        'allowedProtocols': {\n          'https': true,\n        },\n      },\n    },\n    'AMP-GOOGLE-DOCUMENT-EMBED': {\n      'src': null,\n      'title': null,\n    },\n    'AMP-IFRAME': {\n      'src': null,\n      'title': null,\n    },\n    'AMP-IMG': {\n      'alt': null,\n      'attribution': null,\n      'src': {\n        'allowedProtocols': {\n          'data': true,\n          'http': true,\n          'https': true,\n        },\n      },\n      'srcset': {\n        'alternativeName': 'src',\n      },\n    },\n    'AMP-LIGHTBOX': {\n      'open': null,\n    },\n    'AMP-LIST': {\n      'src': {\n        'allowedProtocols': {\n          'https': true,\n        },\n      },\n      'state': null,\n      'is-layout-container': null,\n    },\n    'AMP-RENDER': {\n      'src': {\n        'allowedProtocols': {\n          'https': true,\n        },\n      },\n    },\n    'AMP-SELECTOR': {\n      'disabled': null,\n      'selected': null,\n    },\n    'AMP-STATE': {\n      'src': {\n        'allowedProtocols': {\n          'https': true,\n        },\n      },\n    },\n    'AMP-TIMEAGO': {\n      'datetime': null,\n      'title': null,\n    },\n    'AMP-TWITTER': {\n      'data-tweetid': null,\n    },\n    'AMP-VIDEO': {\n      'album': null,\n      'alt': null,\n      'artist': null,\n      'artwork': null,\n      'attribution': null,\n      'controls': null,\n      'controlslist': null,\n      'loop': null,\n      'poster': null,\n      'preload': null,\n      'src': {\n        'allowedProtocols': {\n          'https': true,\n        },\n      },\n      'title': null,\n    },\n    'AMP-YOUTUBE': {\n      'data-videoid': null,\n    },\n    'A': {\n      'href': {\n        // This should be kept in sync with validator-main.protoascii.\n        'allowedProtocols': {\n          'ftp': true,\n          'geo': true,\n          'http': true,\n          'https': true,\n          'mailto': true,\n          'maps': true,\n          // 3rd Party Protocols\n          'bip': true,\n          'bbmi': true,\n          'chrome': true,\n          'itms-services': true,\n          'facetime': true,\n          'fb-me': true,\n          'fb-messenger': true,\n          'intent': true,\n          'line': true,\n          'skype': true,\n          'sms': true,\n          'snapchat': true,\n          'tel': true,\n          'tg': true,\n          'threema': true,\n          'twitter': true,\n          'viber': true,\n          'webcal': true,\n          'web+mastodon': true,\n          'wh': true,\n          'whatsapp': true,\n        },\n      },\n    },\n    'BUTTON': {\n      'disabled': null,\n      'type': null,\n      'value': null,\n    },\n    'DETAILS': {\n      'open': null,\n    },\n    'FIELDSET': {\n      'disabled': null,\n    },\n    'IMAGE': {\n      'xlink:href': {\n        'allowedProtocols': {\n          'http': true,\n          'https': true,\n        },\n      },\n    },\n    'INPUT': {\n      'accept': null,\n      'accesskey': null,\n      'autocomplete': null,\n      'checked': null,\n      'disabled': null,\n      'height': null,\n      'inputmode': null,\n      'max': null,\n      'maxlength': null,\n      'min': null,\n      'minlength': null,\n      'multiple': null,\n      'pattern': null,\n      'placeholder': null,\n      'readonly': null,\n      'required': null,\n      'selectiondirection': null,\n      'size': null,\n      'spellcheck': null,\n      'step': null,\n      'type': {\n        denylistedValueRegex: '(^|\\\\s)(button|image|)(\\\\s|$)',\n      },\n      'value': null,\n      'width': null,\n    },\n    'OPTION': {\n      'disabled': null,\n      'label': null,\n      'selected': null,\n      'value': null,\n    },\n    'OPTGROUP': {\n      'disabled': null,\n      'label': null,\n    },\n    'SECTION': {\n      'data-expand': null,\n      'expanded': null,\n    },\n    'SELECT': {\n      'autofocus': null,\n      'disabled': null,\n      'multiple': null,\n      'required': null,\n      'size': null,\n    },\n    'SOURCE': {\n      'src': {\n        'allowedProtocols': {\n          'https': true,\n        },\n      },\n      'type': null,\n    },\n    'TRACK': {\n      'label': null,\n      'src': {\n        'allowedProtocols': {\n          'https': true,\n        },\n      },\n      'srclang': null,\n    },\n    'TEXTAREA': {\n      'autocomplete': null,\n      'autofocus': null,\n      'cols': null,\n      'disabled': null,\n      'maxlength': null,\n      'minlength': null,\n      'pattern': null,\n      'placeholder': null,\n      'readonly': null,\n      'required': null,\n      'rows': null,\n      'selectiondirection': null,\n      'selectionend': null,\n      'selectionstart': null,\n      'spellcheck': null,\n      'wrap': null,\n      // Non-standard property.\n      'defaulttext': null,\n    },\n  };\n  return rules;\n}\n", "/**\n * A priority queue backed with sorted array.\n * @template T\n */\nexport class PriorityQueue {\n  /**\n   * Creates an instance of PriorityQueue.\n   */\n  constructor() {\n    /** @private @const {Array<{item: T, priority: number}>} */\n    this.queue_ = [];\n  }\n\n  /**\n   * Returns the max priority item without dequeueing it.\n   * @return {T}\n   */\n  peek() {\n    const l = this.length;\n    if (!l) {\n      return null;\n    }\n    return this.queue_[l - 1].item;\n  }\n\n  /**\n   * Enqueues an item with the given priority.\n   * @param {T} item\n   * @param {number} priority\n   */\n  enqueue(item, priority) {\n    if (isNaN(priority)) {\n      throw new Error('Priority must not be NaN.');\n    }\n    const i = this.binarySearch_(priority);\n    this.queue_.splice(i, 0, {item, priority});\n  }\n\n  /**\n   * Returns index at which item with `target` priority should be inserted.\n   * @param {number} target\n   * @return {number}\n   * @private\n   */\n  binarySearch_(target) {\n    let i = -1;\n    let lo = 0;\n    let hi = this.length;\n    while (lo <= hi) {\n      i = Math.floor((lo + hi) / 2);\n      // This means `target` is the new max priority in the queue.\n      if (i === this.length) {\n        break;\n      }\n      // Stop searching once p[i] >= target AND p[i-1] < target.\n      // This way, we'll return the index of the first occurence of `target`\n      // priority (if any), which preserves FIFO order of same-priority items.\n      if (this.queue_[i].priority < target) {\n        lo = i + 1;\n      } else if (i > 0 && this.queue_[i - 1].priority >= target) {\n        hi = i - 1;\n      } else {\n        break;\n      }\n    }\n    return i;\n  }\n\n  /**\n   * @param {function(T)} callback\n   */\n  forEach(callback) {\n    let index = this.length;\n    while (index--) {\n      callback(this.queue_[index].item);\n    }\n  }\n\n  /**\n   * Dequeues the max priority item.\n   * Items with the same priority are dequeued in FIFO order.\n   * @return {T}\n   */\n  dequeue() {\n    if (!this.length) {\n      return null;\n    }\n    return this.queue_.pop().item;\n  }\n\n  /**\n   * The number of items in the queue.\n   * @return {number}\n   */\n  get length() {\n    return this.queue_.length;\n  }\n}\n", "import {CommonSignals} from '#core/constants/common-signals';\nimport {TickLabel} from '#core/constants/enums';\nimport {insertAfterOrAtStart, waitForBodyOpenPromise} from '#core/dom';\nimport {setStyles} from '#core/dom/style';\nimport {rethrowAsync} from '#core/error';\nimport {map} from '#core/types/object';\n\nimport {Services} from '#service';\n\nimport {dev, devAssert} from '#utils/log';\n\nimport {waitForServices} from './render-delaying-services';\nimport {getAmpdoc} from './service-helpers';\n\nconst TRANSFORMER_PROP = '__AMP_CSS_TR';\nconst STYLE_MAP_PROP = '__AMP_CSS_SM';\n\n/**\n * Adds the given css text to the given ampdoc.\n *\n * The style tags will be at the beginning of the head before all author\n * styles. One element can be the main runtime CSS. This is guaranteed\n * to always be the first stylesheet in the doc.\n *\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc The ampdoc that should get the new styles.\n * @param {string} cssText\n * @param {?function(!Element)|undefined} cb Called when the new styles are available.\n *     Not using a promise, because this is synchronous when possible.\n *     for better performance.\n * @param {boolean=} opt_isRuntimeCss If true, this style tag will be inserted\n *     as the first element in head and all style elements will be positioned\n *     after.\n * @param {string=} opt_ext\n * @return {!Element}\n */\nexport function installStylesForDoc(\n  ampdoc,\n  cssText,\n  cb,\n  opt_isRuntimeCss,\n  opt_ext\n) {\n  const cssRoot = ampdoc.getHeadNode();\n  const style = insertStyleElement(\n    cssRoot,\n    maybeTransform(cssRoot, cssText),\n    opt_isRuntimeCss || false,\n    opt_ext || null\n  );\n\n  if (cb) {\n    const rootNode = ampdoc.getRootNode();\n    // Styles aren't always available synchronously. E.g. if there is a\n    // pending style download, it will have to finish before the new\n    // style is visible.\n    // For this reason we poll until the style becomes available.\n    // Sync case.\n    if (styleLoaded(rootNode, style)) {\n      cb(style);\n      return style;\n    }\n    // Poll until styles are available.\n    const interval = setInterval(() => {\n      if (styleLoaded(rootNode, style)) {\n        clearInterval(interval);\n        cb(style);\n      }\n    }, 4);\n  }\n  return style;\n}\n\n/**\n * Creates the properly configured style element.\n * @param {!Element|!ShadowRoot} cssRoot\n * @param {string} cssText\n * @param {boolean} isRuntimeCss\n * @param {?string} ext\n * @return {!Element}\n */\nfunction insertStyleElement(cssRoot, cssText, isRuntimeCss, ext) {\n  let styleMap = cssRoot[STYLE_MAP_PROP];\n  if (!styleMap) {\n    styleMap = cssRoot[STYLE_MAP_PROP] = map();\n  }\n\n  const isExtCss =\n    !isRuntimeCss && ext && ext != 'amp-custom' && ext != 'amp-keyframes';\n  const key = isRuntimeCss\n    ? 'amp-runtime'\n    : isExtCss\n    ? `amp-extension=${ext}`\n    : null;\n\n  // Check if it has already been created or discovered.\n  if (key) {\n    const existing = getExistingStyleElement(cssRoot, styleMap, key);\n    if (existing) {\n      if (existing.textContent !== cssText) {\n        existing.textContent = cssText;\n      }\n      return existing;\n    }\n  }\n\n  // Create the new style element and append to cssRoot.\n  const doc = cssRoot.ownerDocument || cssRoot;\n  const style = doc.createElement('style');\n  style./*OK*/ textContent = cssText;\n  let afterElement = null;\n  // Make sure that we place style tags after the main runtime CSS. Otherwise\n  // the order is random.\n  if (isRuntimeCss) {\n    style.setAttribute('amp-runtime', '');\n  } else if (isExtCss) {\n    style.setAttribute('amp-extension', ext || '');\n    afterElement = dev().assertElement(\n      getExistingStyleElement(cssRoot, styleMap, 'amp-runtime')\n    );\n  } else {\n    if (ext) {\n      style.setAttribute(ext, '');\n    }\n    afterElement = cssRoot.lastChild;\n  }\n  insertAfterOrAtStart(cssRoot, style, afterElement);\n  if (key) {\n    styleMap[key] = style;\n  }\n  return style;\n}\n\n/**\n * @param {!Element|!ShadowRoot} cssRoot\n * @param {!Object<string, !Element>} styleMap\n * @param {string} key\n * @return {?Element}\n */\nfunction getExistingStyleElement(cssRoot, styleMap, key) {\n  // Already cached.\n  if (styleMap[key]) {\n    return styleMap[key];\n  }\n  // Check if the style has already been added by the server layout.\n  const existing = cssRoot./*OK*/ querySelector(`style[${key}]`);\n  if (existing) {\n    styleMap[key] = existing;\n    return existing;\n  }\n  // Nothing found.\n  return null;\n}\n\n/**\n * Applies a transformer to the CSS text if it has been registered.\n * @param {!Element|!ShadowRoot} cssRoot\n * @param {function(string):string} transformer\n */\nexport function installCssTransformer(cssRoot, transformer) {\n  cssRoot[TRANSFORMER_PROP] = transformer;\n}\n\n/**\n * Applies a transformer to the CSS text if it has been registered.\n * @param {!Element|!ShadowRoot} cssRoot\n * @param {string} cssText\n * @return {string}\n */\nfunction maybeTransform(cssRoot, cssText) {\n  const transformer = cssRoot[TRANSFORMER_PROP];\n  return transformer ? transformer(cssText) : cssText;\n}\n\n/** @private {boolean} */\nlet bodyMadeVisible = false;\n\n/**\n * @param {boolean} value\n * @visibleForTesting\n */\nexport function setBodyMadeVisibleForTesting(value) {\n  bodyMadeVisible = value;\n}\n\n/**\n * Sets the document's body opacity to 1.\n * If the body is not yet available (because our script was loaded\n * synchronously), polls until it is.\n * @param {!Document} doc The document who's body we should make visible.\n */\nexport function makeBodyVisible(doc) {\n  devAssert(doc.defaultView, 'Passed in document must have a defaultView');\n  const win = /** @type {!Window} */ (doc.defaultView);\n  waitForBodyOpenPromise(doc)\n    .then(() => {\n      return waitForServices(win);\n    })\n    .catch((reason) => {\n      rethrowAsync(reason);\n      return [];\n    })\n    .then((services) => {\n      bodyMadeVisible = true;\n      if (INI_LOAD_INOB) {\n        // Force sync measurement to ensure that style recalc is complete\n        // before showing body, which would trigger FCP. This should reduce\n        // make it less likely that a CLS would be triggered after FCP.\n        doc.body./*OK*/ getBoundingClientRect();\n      }\n      setBodyVisibleStyles(doc);\n      const ampdoc = getAmpdoc(doc);\n      ampdoc.signals().signal(CommonSignals.RENDER_START);\n      if (services.length > 0) {\n        const resources = Services.resourcesForDoc(doc.documentElement);\n        resources./*OK*/ schedulePass(1, /* relayoutAll */ true);\n      }\n      try {\n        const perf = Services.performanceFor(win);\n        perf.tick(TickLabel.MAKE_BODY_VISIBLE);\n        perf.flush();\n      } catch (e) {}\n    });\n}\n\n/**\n * Set the document's body opacity to 1. Called in error cases.\n * @param {!Document} doc The document who's body we should make visible.\n */\nexport function makeBodyVisibleRecovery(doc) {\n  devAssert(doc.defaultView, 'Passed in document must have a defaultView');\n  if (bodyMadeVisible) {\n    return;\n  }\n  bodyMadeVisible = true;\n  setBodyVisibleStyles(doc);\n}\n\n/**\n * Make sure that body exists, and make it visible.\n * @param {!Document} doc\n */\nfunction setBodyVisibleStyles(doc) {\n  setStyles(dev().assertElement(doc.body), {\n    opacity: 1,\n    visibility: 'visible',\n    'animation': 'none',\n  });\n}\n\n/**\n * Indicates that the body is always visible. For instance, in case of PWA.\n * This check is on a module level variable, and could be problematic if you are\n * relying on this function across different binaries.\n * @param {!Window} unusedWin\n */\nexport function bodyAlwaysVisible(unusedWin) {\n  bodyMadeVisible = true;\n}\n\n/**\n * Checks whether a style element was registered in the DOM.\n * @param {!Document|!ShadowRoot} doc\n * @param {!Element} style\n * @return {boolean}\n */\nfunction styleLoaded(doc, style) {\n  const sheets = doc.styleSheets;\n  for (let i = 0; i < sheets.length; i++) {\n    const sheet = sheets[i];\n    if (sheet.ownerNode == style) {\n      return true;\n    }\n  }\n  return false;\n}\n", "import {PriorityQueue} from '#core/data-structures/priority-queue';\n\nimport {Services} from '#service';\n\nimport {getData} from '#utils/event-helper';\nimport {dev} from '#utils/log';\n\nimport {\n  getServiceForDoc,\n  registerServiceBuilderForDoc,\n} from './service-helpers';\nimport {makeBodyVisibleRecovery} from './style-installer';\n\n/**\n * @const {string}\n */\nconst TAG = 'CHUNK';\n\n/**\n * @type {boolean}\n */\nlet deactivated = /nochunking=1/.test(self.location.hash);\nlet allowLongTasks = false;\n\n/**\n * @const {!Promise}\n */\nconst resolved = Promise.resolve();\n\n/**\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @return {!Chunks}\n * @private\n */\nfunction chunkServiceForDoc(elementOrAmpDoc) {\n  registerServiceBuilderForDoc(elementOrAmpDoc, 'chunk', Chunks);\n  return getServiceForDoc(elementOrAmpDoc, 'chunk');\n}\n\n/**\n * Run the given function. For visible documents the function will be\n * called in a micro task (Essentially ASAP). If the document is\n * not visible, tasks will yield to the event loop (to give the browser\n * time to do other things) and may even be further delayed until\n * there is time.\n *\n * @param {!Document|!./service/ampdoc-impl.AmpDoc} doc\n * @param {function(?IdleDeadline)} fn\n * @param {boolean=} opt_makesBodyVisible Pass true if this service makes\n *     the body visible. This is relevant because it may influence the\n *     task scheduling strategy.\n */\nexport function startupChunk(doc, fn, opt_makesBodyVisible) {\n  if (deactivated) {\n    resolved.then(fn);\n    return;\n  }\n  const service = chunkServiceForDoc(doc.documentElement || doc);\n  service.runForStartup(fn);\n  if (opt_makesBodyVisible) {\n    service.runForStartup(() => {\n      service.bodyIsVisible_ = true;\n    });\n  }\n}\n\n/**\n * Run the given function sometime in the future without blocking UI.\n *\n * Higher priority tasks are executed before lower priority tasks.\n * Tasks with the same priority are executed in FIFO order.\n *\n * Uses `requestIdleCallback` if available and passes the `IdleDeadline`\n * object to the function, which can be used to perform a variable amount\n * of work depending on the remaining amount of idle time.\n *\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {function(?IdleDeadline)} fn\n * @param {ChunkPriority} priority\n */\nexport function chunk(elementOrAmpDoc, fn, priority) {\n  if (deactivated) {\n    resolved.then(fn);\n    return;\n  }\n  const service = chunkServiceForDoc(elementOrAmpDoc);\n  service.run(fn, priority);\n}\n\n/**\n * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @return {!Chunks}\n */\nexport function chunkInstanceForTesting(elementOrAmpDoc) {\n  return chunkServiceForDoc(elementOrAmpDoc);\n}\n\n/**\n * Use a standard micro task for every invocation. This should only\n * be called from the AMP bootstrap script if it is known that\n * chunking makes no sense. In particular this is the case when\n * AMP runs in the `amp-shadow` multi document mode.\n */\nexport function deactivateChunking() {\n  deactivated = true;\n}\n\n/**\n * Allow continuing macro tasks after a long task (>5ms).\n * In particular this is the case when AMP runs in the `amp-inabox` ads mode.\n */\nexport function allowLongTasksInChunking() {\n  allowLongTasks = true;\n}\n\n/**\n * @visibleForTesting\n */\nexport function activateChunkingForTesting() {\n  deactivated = false;\n}\n\n/**\n * Runs all currently scheduled chunks.\n * Independent of errors it will unwind the queue. Will afterwards\n * throw the first encountered error.\n * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n */\nexport function runChunksForTesting(elementOrAmpDoc) {\n  const service = chunkInstanceForTesting(elementOrAmpDoc);\n  const errors = [];\n  while (true) {\n    try {\n      if (!service.execute_(/* idleDeadline */ null)) {\n        break;\n      }\n    } catch (e) {\n      errors.push(e);\n    }\n  }\n  if (errors.length) {\n    throw errors[0];\n  }\n}\n\n/**\n * The priority of a chunk task. Higher priority tasks have higher values.\n * @enum {number}\n */\nexport const ChunkPriority = {\n  HIGH: 20,\n  LOW: 10,\n  BACKGROUND: 0,\n};\n\n/** @enum {string} */\nconst TaskState = {\n  NOT_RUN: 'not_run',\n  RUN: 'run',\n};\n\n/**\n * A default chunkable task.\n * @private\n */\nclass Task {\n  /**\n   * @param {function(?IdleDeadline)} fn\n   */\n  constructor(fn) {\n    /** @public {TaskState} */\n    this.state = TaskState.NOT_RUN;\n\n    /** @private @const {!function(?IdleDeadline)} */\n    this.fn_ = fn;\n  }\n\n  /**\n   * Executes the wrapped function.\n   * @param {?IdleDeadline} idleDeadline\n   * @throws {Error}\n   * @protected\n   */\n  runTask_(idleDeadline) {\n    if (this.state == TaskState.RUN) {\n      return;\n    }\n    this.state = TaskState.RUN;\n    try {\n      this.fn_(idleDeadline);\n    } catch (e) {\n      this.onTaskError_(e);\n      throw e;\n    }\n  }\n\n  /**\n   * @return {string}\n   * @protected\n   */\n  getName_() {\n    return this.fn_.displayName || this.fn_.name;\n  }\n\n  /**\n   * Optional handling when a task run throws an error.\n   * @param {Error} unusedError\n   * @private\n   */\n  onTaskError_(unusedError) {\n    // By default, no-op.\n  }\n\n  /**\n   * Returns true if this task should be run without delay.\n   * @return {boolean}\n   * @protected\n   */\n  immediateTriggerCondition_() {\n    // By default, there are no immediate trigger conditions.\n    return false;\n  }\n\n  /**\n   * Returns true if this task should be scheduled using `requestIdleCallback`.\n   * Otherwise, task is scheduled as macro-task on next event loop.\n   * @return {boolean}\n   * @protected\n   */\n  useRequestIdleCallback_() {\n    // By default, never use requestIdleCallback.\n    return false;\n  }\n}\n\n/**\n * A task that's run as part of AMP's startup sequence.\n * @private\n */\nclass StartupTask extends Task {\n  /**\n   * @param {function(?IdleDeadline)} fn\n   * @param {!Window} win\n   * @param {!Chunks} chunks\n   */\n  constructor(fn, win, chunks) {\n    super(fn);\n\n    /** @private @const */\n    this.chunks_ = chunks;\n  }\n\n  /** @override */\n  onTaskError_(unusedError) {\n    // Startup tasks run early in init. All errors should show the doc.\n    makeBodyVisibleRecovery(self.document);\n  }\n\n  /** @override */\n  immediateTriggerCondition_() {\n    // Run in a micro task when the doc is visible. Otherwise, run after\n    // having yielded to the event queue once.\n    return this.isVisible_();\n  }\n\n  /** @override */\n  useRequestIdleCallback_() {\n    // We only start using requestIdleCallback when the core runtime has\n    // been initialized. Otherwise we risk starving ourselves\n    // before the render-critical work is done.\n    return this.chunks_.coreReady_;\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  isVisible_() {\n    return this.chunks_.ampdoc.isVisible();\n  }\n}\n\n/**\n * Handles queueing, scheduling and executing tasks.\n */\nclass Chunks {\n  /**\n   * @param {!./service/ampdoc-impl.AmpDoc} ampDoc\n   */\n  constructor(ampDoc) {\n    /** @protected @const {!./service/ampdoc-impl.AmpDoc} */\n    this.ampdoc = ampDoc;\n    /** @private @const {!Window} */\n    this.win_ = ampDoc.win;\n    /** @private @const {!PriorityQueue<Task>} */\n    this.tasks_ = new PriorityQueue();\n    /** @private @const {function(?IdleDeadline)} */\n    this.boundExecute_ = this.execute_.bind(this);\n    /** @private {number} */\n    this.durationOfLastExecution_ = 0;\n    /** @private @const {boolean} */\n    this.supportsInputPending_ = !!(\n      this.win_.navigator.scheduling &&\n      this.win_.navigator.scheduling.isInputPending\n    );\n\n    /**\n     * Set to true if we scheduled a macro or micro task to execute the next\n     * task. If true, we don't schedule another one.\n     * Not set to true if we use rIC, because we always want to transition\n     * to immeditate invocation from that state.\n     * @private {boolean}\n     */\n    this.scheduledImmediateInvocation_ = false;\n    /** @private {boolean} Whether the document can actually be painted. */\n    this.bodyIsVisible_ = this.win_.document.documentElement.hasAttribute(\n      'i-amphtml-no-boilerplate'\n    );\n\n    this.win_.addEventListener('message', (e) => {\n      if (getData(e) == 'amp-macro-task') {\n        this.execute_(/* idleDeadline */ null);\n      }\n    });\n\n    /** @protected {boolean} */\n    this.coreReady_ = false;\n    Services.viewerPromiseForDoc(ampDoc).then(() => {\n      // Once the viewer has been resolved, most of core runtime has been\n      // initialized as well.\n      this.coreReady_ = true;\n    });\n\n    ampDoc.onVisibilityChanged(() => {\n      if (ampDoc.isVisible()) {\n        this.schedule_();\n      }\n    });\n  }\n\n  /**\n   * Run fn as a \"chunk\".\n   * @param {function(?IdleDeadline)} fn\n   * @param {number} priority\n   */\n  run(fn, priority) {\n    const t = new Task(fn);\n    this.enqueueTask_(t, priority);\n  }\n\n  /**\n   * Run a fn that's part of AMP's startup sequence as a \"chunk\".\n   * @param {function(?IdleDeadline)} fn\n   */\n  runForStartup(fn) {\n    const t = new StartupTask(fn, this.win_, this);\n    this.enqueueTask_(t, Number.POSITIVE_INFINITY);\n  }\n\n  /**\n   * Queues a task to be executed later with given priority.\n   * @param {!Task} task\n   * @param {number} priority\n   * @private\n   */\n  enqueueTask_(task, priority) {\n    this.tasks_.enqueue(task, priority);\n    this.schedule_();\n  }\n\n  /**\n   * Returns the next task that hasn't been run yet.\n   * If `opt_dequeue` is true, remove the returned task from the queue.\n   * @param {boolean=} opt_dequeue\n   * @return {?Task}\n   * @private\n   */\n  nextTask_(opt_dequeue) {\n    let t = this.tasks_.peek();\n    // Dequeue tasks until we find one that hasn't been run yet.\n    while (t && t.state !== TaskState.NOT_RUN) {\n      this.tasks_.dequeue();\n      t = this.tasks_.peek();\n    }\n    // If `opt_dequeue` is true, remove this task from the queue.\n    if (t && opt_dequeue) {\n      this.tasks_.dequeue();\n    }\n    return t;\n  }\n\n  /**\n   * Run a task.\n   * Schedule the next round if there are more tasks.\n   * @param {?IdleDeadline} idleDeadline\n   * @return {boolean} Whether anything was executed.\n   * @private\n   */\n  execute_(idleDeadline) {\n    const t = this.nextTask_(/* opt_dequeue */ true);\n    if (!t) {\n      this.scheduledImmediateInvocation_ = false;\n      this.durationOfLastExecution_ = 0;\n      return false;\n    }\n    let before;\n    try {\n      before = Date.now();\n      t.runTask_(idleDeadline);\n    } finally {\n      // We want to capture the time of the entire task duration including\n      // scheduled immediate (from resolved promises) micro tasks.\n      // Lacking a better way to do this we just scheduled 10 nested\n      // micro tasks.\n      resolved\n        .then()\n        .then()\n        .then()\n        .then()\n        .then()\n        .then()\n        .then()\n        .then()\n        .then(() => {\n          this.scheduledImmediateInvocation_ = false;\n          this.durationOfLastExecution_ += Date.now() - before;\n          dev().fine(\n            TAG,\n            t.getName_(),\n            'Chunk duration',\n            Date.now() - before,\n            this.durationOfLastExecution_\n          );\n\n          this.schedule_();\n        });\n    }\n    return true;\n  }\n\n  /**\n   * Calls `execute_()` asynchronously.\n   * @param {?IdleDeadline} idleDeadline\n   * @private\n   */\n  executeAsap_(idleDeadline) {\n    // If the user-agent supports isInputPending, use it to break to a macro task as necessary.\n    // Otherwise If we've spent over 5 millseconds executing the\n    // last instruction yield back to the main thread.\n    // 5 milliseconds is a magic number.\n    if (\n      !allowLongTasks &&\n      this.bodyIsVisible_ &&\n      (this.supportsInputPending_\n        ? /** @type {!{scheduling: {isInputPending: Function}}} */ (\n            this.win_.navigator\n          ).scheduling.isInputPending()\n        : this.durationOfLastExecution_ > 5)\n    ) {\n      this.durationOfLastExecution_ = 0;\n      this.requestMacroTask_();\n      return;\n    }\n    resolved.then(() => {\n      this.boundExecute_(idleDeadline);\n    });\n  }\n\n  /**\n   * Schedule running the next queued task.\n   * @private\n   */\n  schedule_() {\n    if (this.scheduledImmediateInvocation_) {\n      return;\n    }\n    const nextTask = this.nextTask_();\n    if (!nextTask) {\n      return;\n    }\n    if (nextTask.immediateTriggerCondition_()) {\n      this.scheduledImmediateInvocation_ = true;\n      this.executeAsap_(/* idleDeadline */ null);\n      return;\n    }\n    // If requestIdleCallback exists, schedule a task with it, but\n    // do not wait longer than two seconds.\n    if (nextTask.useRequestIdleCallback_() && this.win_.requestIdleCallback) {\n      onIdle(\n        this.win_,\n        // Wait until we have a budget of at least 15ms.\n        // 15ms is a magic number. Budgets are higher when the user\n        // is completely idle (around 40), but that occurs too\n        // rarely to be usable. 15ms budgets can happen during scrolling\n        // but only if the device is doing super, super well, and no\n        // real processing is done between frames.\n        15 /* minimumTimeRemaining */,\n        2000 /* timeout */,\n        this.boundExecute_\n      );\n      return;\n    }\n    this.requestMacroTask_();\n  }\n\n  /**\n   * Requests executing of a macro task. Yields to the event queue\n   * before executing the task.\n   * Places task on browser message queue which then respectively\n   * triggers dequeuing and execution of a chunk.\n   */\n  requestMacroTask_() {\n    // The message doesn't actually matter.\n    this.win_./*OK*/ postMessage('amp-macro-task', '*');\n  }\n}\n\n/**\n * Delays calling the given function until the browser is notifying us\n * about a certain minimum budget or the timeout is reached.\n * @param {!Window} win\n * @param {number} minimumTimeRemaining Minimum number of millis idle\n *     budget for callback to fire.\n * @param {number} timeout in millis for callback to fire.\n * @param {function(?IdleDeadline)} fn Callback.\n * @visibleForTesting\n */\nexport function onIdle(win, minimumTimeRemaining, timeout, fn) {\n  const startTime = Date.now();\n  /**\n   * @param {!IdleDeadline} info\n   */\n  function rIC(info) {\n    if (info.timeRemaining() < minimumTimeRemaining) {\n      const remainingTimeout = timeout - (Date.now() - startTime);\n      if (remainingTimeout <= 0 || info.didTimeout) {\n        dev().fine(TAG, 'Timed out', timeout, info.didTimeout);\n        fn(info);\n      } else {\n        dev().fine(\n          TAG,\n          'Rescheduling with',\n          remainingTimeout,\n          info.timeRemaining()\n        );\n        win.requestIdleCallback(rIC, {timeout: remainingTimeout});\n      }\n    } else {\n      dev().fine(TAG, 'Running idle callback with ', minimumTimeRemaining);\n      fn(info);\n    }\n  }\n  win.requestIdleCallback(rIC, {timeout});\n}\n", "/**\n * @param {number=} opt_base Exponential base. Defaults to 2.\n * @return {function(function()): number} Function that when invoked will\n *     call the passed in function. On every invocation the next\n *     invocation of the passed in function will be exponentially\n *     later. Returned function returns timeout id.\n */\nexport function exponentialBackoff(opt_base) {\n  const getTimeout = exponentialBackoffClock(opt_base);\n  return (work) => {\n    return setTimeout(work, getTimeout());\n  };\n}\n\n/**\n * @param {number=} opt_base Exponential base. Defaults to 2.\n * @return {function(): number} Function that when invoked will return\n *    a number that exponentially grows per invocation.\n */\nexport function exponentialBackoffClock(opt_base) {\n  const base = opt_base || 2;\n  let count = 0;\n  return () => {\n    let wait = Math.pow(base, count++);\n    wait += getJitter(wait);\n    return wait * 1000;\n  };\n}\n\n/**\n * Add jitter to avoid the thundering herd. This can e.g. happen when\n * we poll a backend and it fails for everyone at the same time.\n * We add up to 30% (default) longer or shorter than the given time.\n *\n * @param {number} wait the amount if base milliseconds\n * @param {number=} opt_perc the min/max percentage to add or sutract\n * @return {number}\n */\nexport function getJitter(wait, opt_perc) {\n  opt_perc = opt_perc || 0.3;\n  let jitter = wait * opt_perc * Math.random();\n  if (Math.random() > 0.5) {\n    jitter *= -1;\n  }\n  return jitter;\n}\n", "/**\n * @fileoverview Experiments system allows a developer to opt-in to test\n * features that are not yet fully tested.\n *\n * Experiments page: https://cdn.ampproject.org/experiments.html *\n */\n\nimport {isArray} from '#core/types';\nimport {hasOwn, map} from '#core/types/object';\nimport {parseJson} from '#core/types/object/json';\nimport {parseQueryString} from '#core/types/string/url';\n\nimport {dev, user} from '#utils/log';\n\nimport {ExperimentInfoDef} from './experiments.type';\n\nimport {getMode} from '../mode';\nimport {getTopWindow} from '../service-helpers';\n\n/** @const {string} */\nconst TAG = 'EXPERIMENTS';\n\n/** @const {string} */\nconst LOCAL_STORAGE_KEY = 'amp-experiment-toggles';\n\n/** @const {string} */\nconst TOGGLES_WINDOW_PROPERTY = '__AMP__EXPERIMENT_TOGGLES';\n\n/**\n * Whether we are in canary.\n * @param {!Window} win\n * @return {boolean}\n */\nexport function isCanary(win) {\n  return !!win.AMP_CONFIG?.canary;\n}\n\n/**\n * Returns binary type, e.g., canary, production, control, or rc.\n * @param {!Window} win\n * @return {string}\n */\nexport function getBinaryType(win) {\n  return win.AMP_CONFIG?.type || 'unknown';\n}\n\n/**\n * Whether the specified experiment is on or off.\n * @param {!Window} win\n * @param {string} experimentId\n * @return {boolean}\n */\nexport function isExperimentOn(win, experimentId) {\n  const toggles = experimentToggles(win);\n  return !!toggles[experimentId];\n}\n\n/**\n * Toggles the experiment on or off. Returns the actual value of the experiment\n * after toggling is done.\n * @param {!Window} win\n * @param {string} experimentId\n * @param {boolean=} opt_on\n * @param {boolean=} opt_transientExperiment  Whether to toggle the\n *     experiment state \"transiently\" (i.e., for this page load only) or\n *     durably (by saving the experiment IDs after toggling).\n *     Default: false (save durably).\n * @return {boolean} New state for experimentId.\n */\nexport function toggleExperiment(\n  win,\n  experimentId,\n  opt_on,\n  opt_transientExperiment\n) {\n  const currentlyOn = isExperimentOn(win, /*OK*/ experimentId);\n  const on = opt_on ?? !currentlyOn;\n  if (on != currentlyOn) {\n    const toggles = experimentToggles(win);\n    toggles[experimentId] = on;\n\n    if (!opt_transientExperiment) {\n      const storedToggles = getExperimentToggles(win);\n      storedToggles[experimentId] = on;\n      saveExperimentToggles(win, storedToggles);\n      // Avoid affecting tests that spy/stub warn().\n      if (!getMode().test) {\n        user().warn(\n          TAG,\n          '\"%s\" experiment %s for the domain \"%s\". See: https://amp.dev/documentation/guides-and-tutorials/learn/experimental',\n          experimentId,\n          on ? 'enabled' : 'disabled',\n          win.location.hostname\n        );\n      }\n    }\n  }\n  return on;\n}\n\n/**\n * Calculate whether the experiment is on or off based off of its default value,\n * stored overriden value, or the global config frequency given.\n * @param {!Window} win\n * @return {!Object<string, boolean>}\n */\nexport function experimentToggles(win) {\n  if (win[TOGGLES_WINDOW_PROPERTY]) {\n    return win[TOGGLES_WINDOW_PROPERTY];\n  }\n  win[TOGGLES_WINDOW_PROPERTY] = map();\n  const toggles = win[TOGGLES_WINDOW_PROPERTY];\n\n  // Read default and injected configs of this build.\n  const buildExperimentConfigs = {\n    ...(win.AMP_CONFIG ?? {}),\n    ...(win.AMP_EXP ?? parseJson(win.__AMP_EXP?.textContent || '{}')),\n  };\n  for (const experimentId in buildExperimentConfigs) {\n    const frequency = buildExperimentConfigs[experimentId];\n    if (typeof frequency === 'number' && frequency >= 0 && frequency <= 1) {\n      toggles[experimentId] = Math.random() < frequency;\n    }\n  }\n  // Read document level override from meta tag.\n  const allowedDocOptIn = win.AMP_CONFIG?.['allow-doc-opt-in'];\n  if (isArray(allowedDocOptIn) && allowedDocOptIn.length) {\n    const meta = win.document.head.querySelector(\n      'meta[name=\"amp-experiments-opt-in\"]'\n    );\n    if (meta) {\n      const optedInExperiments = meta.getAttribute('content').split(',');\n      for (const experiment of optedInExperiments) {\n        if (dev().assertArray(allowedDocOptIn).includes(experiment)) {\n          toggles[experiment] = true;\n        }\n      }\n    }\n  }\n\n  Object.assign(toggles, getExperimentToggles(win));\n\n  const allowedUrlOptIn = win.AMP_CONFIG?.['allow-url-opt-in'];\n  if (isArray(allowedUrlOptIn) && allowedUrlOptIn.length) {\n    const hash = win.location['originalHash'] || win.location.hash;\n    const params = parseQueryString(hash);\n    for (const experiment of allowedUrlOptIn) {\n      const param = params[`e-${experiment}`];\n      if (param == '1') {\n        toggles[experiment] = true;\n      }\n      if (param == '0') {\n        toggles[experiment] = false;\n      }\n    }\n  }\n  return toggles;\n}\n\n/**\n * Returns the cached experiments toggles, or null if they have not been\n * computed yet.\n * @param {!Window} win\n * @return {?Object<string, boolean>}\n */\nexport function experimentTogglesOrNull(win) {\n  return win[TOGGLES_WINDOW_PROPERTY] || null;\n}\n\n/**\n * Returns a set of experiment IDs currently on.\n * @param {!Window} win\n * @return {!Object<string, boolean>}\n */\nfunction getExperimentToggles(win) {\n  let experimentsString = '';\n  try {\n    if ('localStorage' in win) {\n      experimentsString = win.localStorage.getItem(LOCAL_STORAGE_KEY);\n    }\n  } catch {\n    dev().warn(TAG, 'Failed to retrieve experiments from localStorage.');\n  }\n  const tokens = experimentsString?.split(/\\s*,\\s*/g) || [];\n\n  const toggles = map();\n  for (const token of tokens) {\n    if (!token) {\n      continue;\n    }\n    if (token[0] == '-') {\n      toggles[token.substr(1)] = false;\n    } else {\n      toggles[token] = true;\n    }\n  }\n  return toggles;\n}\n\n/**\n * Saves a set of experiment IDs currently on.\n * @param {!Window} win\n * @param {!Object<string, boolean>} toggles\n */\nfunction saveExperimentToggles(win, toggles) {\n  const experimentIds = [];\n  for (const experiment in toggles) {\n    experimentIds.push((toggles[experiment] === false ? '-' : '') + experiment);\n  }\n  try {\n    win.localStorage?.setItem(LOCAL_STORAGE_KEY, experimentIds.join(','));\n  } catch (e) {\n    user().error(TAG, 'Failed to save experiments to localStorage.');\n  }\n}\n\n/**\n * See getExperimentToggles().\n * @param {!Window} win\n * @return {!Object<string, boolean>}\n * @visibleForTesting\n */\nexport function getExperimentTogglesForTesting(win) {\n  return getExperimentToggles(win);\n}\n\n/**\n * Resets the experimentsToggle cache for testing purposes.\n * @param {!Window} win\n * @visibleForTesting\n */\nexport function resetExperimentTogglesForTesting(win) {\n  saveExperimentToggles(win, {});\n  win[TOGGLES_WINDOW_PROPERTY] = null;\n}\n\n/**\n * In some browser implementations of Math.random(), sequential calls of\n * Math.random() are correlated and can cause a bias.  In particular,\n * if the previous random() call was < 0.001 (as it will be if we select\n * into an experiment), the next value could be less than 0.5 more than\n * 50.7% of the time.  This provides an implementation that roots down into\n * the crypto API, when available, to produce less biased samples.\n *\n * @return {number} Pseudo-random floating-point value on the range [0, 1).\n */\nfunction slowButAccuratePrng() {\n  // TODO(tdrl): Implement.\n  return Math.random();\n}\n\n/**\n * Container for alternate random number generator implementations.  This\n * allows us to set an \"accurate\" PRNG for branch selection, but to mock it\n * out easily in tests.\n *\n * @visibleForTesting\n * @const {!{accuratePrng: function():number}}\n */\nexport const RANDOM_NUMBER_GENERATORS = {\n  accuratePrng: slowButAccuratePrng,\n};\n\n/**\n * Selects, uniformly at random, a single item from the array.\n * @param {!Array<string>} arr Object to select from.\n * @return {?string} Single item from arr or null if arr was empty.\n */\nfunction selectRandomItem(arr) {\n  const rn = RANDOM_NUMBER_GENERATORS.accuratePrng();\n  return dev().assertString(arr[Math.floor(rn * arr.length)]) || null;\n}\n\n/**\n * Selects which page-level experiment branches are enabled. If a given\n * experiment name is already set (including to the null / no branches selected\n * state), this won't alter its state.\n *\n * Check whether a given experiment is set using isExperimentOn(win,\n * experimentName) and, if it is on, look for which branch is selected in\n * win.__AMP_EXPERIMENT_BRANCHES[experimentName].\n *\n * @param {!Window} win Window context on which to save experiment\n *     selection state.\n * @param {!Array<!ExperimentInfoDef>} experiments  Set of experiments to\n *     configure for this page load.\n * @return {!Object<string, string>} Map of experiment names to selected\n *     branches.\n */\nexport function randomlySelectUnsetExperiments(win, experiments) {\n  win.__AMP_EXPERIMENT_BRANCHES = win.__AMP_EXPERIMENT_BRANCHES || {};\n  const selectedExperiments = {};\n  for (const experiment of experiments) {\n    const experimentName = experiment.experimentId;\n    if (hasOwn(win.__AMP_EXPERIMENT_BRANCHES, experimentName)) {\n      selectedExperiments[experimentName] =\n        win.__AMP_EXPERIMENT_BRANCHES[experimentName];\n      continue;\n    }\n\n    if (!experiment.isTrafficEligible?.(win)) {\n      win.__AMP_EXPERIMENT_BRANCHES[experimentName] = null;\n      continue;\n    }\n\n    // If we're in the experiment, but we haven't already forced a specific\n    // experiment branch (e.g., via a test setup), then randomize the branch\n    // choice.\n    if (\n      !win.__AMP_EXPERIMENT_BRANCHES[experimentName] &&\n      isExperimentOn(win, /*OK*/ experimentName)\n    ) {\n      win.__AMP_EXPERIMENT_BRANCHES[experimentName] = selectRandomItem(\n        experiment.branches\n      );\n      selectedExperiments[experimentName] =\n        win.__AMP_EXPERIMENT_BRANCHES[experimentName];\n    }\n  }\n  return selectedExperiments;\n}\n\n/**\n * Returns the experiment branch enabled for the given experiment ID.\n * For example, 'control' or 'experiment'.\n *\n * @param {!Window} win Window context to check for experiment state.\n * @param {string} experimentName Name of the experiment to check.\n * @return {?string} Active experiment branch ID for experimentName (possibly\n *     null if experimentName has been tested but no branch was enabled).\n */\nexport function getExperimentBranch(win, experimentName) {\n  return win.__AMP_EXPERIMENT_BRANCHES\n    ? win.__AMP_EXPERIMENT_BRANCHES[experimentName]\n    : null;\n}\n\n/**\n * Returns an object containing all active experiment branches on the\n * top Window.\n *\n * @param {!Window} win Window context to check for experiment state.\n * @return {!Object} contains all experiment branches and their ids.\n */\nexport function getActiveExperimentBranches(win) {\n  const topWin = getTopWindow(win);\n  if (!topWin.__AMP_EXPERIMENT_BRANCHES) {\n    topWin.__AMP_EXPERIMENT_BRANCHES = {};\n  }\n  return {...topWin.__AMP_EXPERIMENT_BRANCHES};\n}\n\n/**\n * Force enable (or disable) a specific branch of a given experiment name.\n * Disables the experiment name altogether if branchId is falseish.\n *\n * @param {!Window} win Window context to check for experiment state.\n * @param {string} experimentName Name of the experiment to check.\n * @param {?string} branchId ID of branch to force or null to disable\n *     altogether.\n * @visibleForTesting\n */\nexport function forceExperimentBranch(win, experimentName, branchId) {\n  win.__AMP_EXPERIMENT_BRANCHES = win.__AMP_EXPERIMENT_BRANCHES || {};\n  toggleExperiment(win, experimentName, !!branchId, true);\n  win.__AMP_EXPERIMENT_BRANCHES[experimentName] = branchId;\n}\n", "import {AmpEvents} from '#core/constants/amp-events';\nimport {duplicateErrorIfNecessary} from '#core/error';\nimport {\n  USER_ERROR_SENTINEL,\n  isUserErrorEmbedMessage,\n  isUserErrorMessage,\n} from '#core/error/message-helpers';\nimport * as mode from '#core/mode';\nimport {findIndex} from '#core/types/array';\nimport {exponentialBackoff} from '#core/types/function/exponential-backoff';\nimport {dict} from '#core/types/object';\n\nimport {experimentTogglesOrNull, getBinaryType, isCanary} from '#experiments';\n\nimport {Services} from '#service';\n\nimport {triggerAnalyticsEvent} from '#utils/analytics';\nimport {isLoadErrorMessage} from '#utils/event-helper';\nimport {dev, setReportError} from '#utils/log';\n\nimport {urls} from './config';\nimport {getMode} from './mode';\nimport {makeBodyVisibleRecovery} from './style-installer';\nimport {isProxyOrigin} from './url';\n\nexport {setReportError};\n\n/**\n * @const {string}\n */\nconst CANCELLED = 'CANCELLED';\n\n/**\n * @const {string}\n */\nconst BLOCK_BY_CONSENT = 'BLOCK_BY_CONSENT';\n\n/**\n * @const {string}\n */\nconst ABORTED = 'AbortError';\n\n/**\n * The threshold for errors throttled because nothing can be done about\n * them, but we'd still like to report the rough number.\n * @const {number}\n */\nconst NON_ACTIONABLE_ERROR_THROTTLE_THRESHOLD = 0.001;\n\n/**\n * The threshold for errors throttled because nothing can be done about\n * them, but we'd still like to report the rough number.\n * @const {number}\n */\nconst USER_ERROR_THROTTLE_THRESHOLD = 0.1;\n\n/**\n * Chance to post to the new error reporting endpoint.\n * @const {number}\n */\nconst BETA_ERROR_REPORT_URL_FREQ = 0.1;\n\n/**\n * Collects error messages, so they can be included in subsequent reports.\n * That allows identifying errors that might be caused by previous errors.\n */\nlet accumulatedErrorMessages = self.__AMP_ERRORS || [];\n// Use a true global, to avoid multi-module inclusion issues.\nself.__AMP_ERRORS = accumulatedErrorMessages;\n\n/**\n * Pushes element into array, keeping at most the most recent limit elements\n *\n * @param {!Array<T>} array\n * @param {T} element\n * @param {number} limit\n * @template T\n */\nfunction pushLimit(array, element, limit) {\n  if (array.length >= limit) {\n    array.splice(0, array.length - limit + 1);\n  }\n  array.push(element);\n}\n\n/**\n * A wrapper around our exponentialBackoff, to lazy initialize it to avoid an\n * un-DCE'able side-effect.\n * @param {function()} work the function to execute after backoff\n * @return {number} the setTimeout id\n */\nlet reportingBackoff = function (work) {\n  // Set reportingBackoff as the lazy-created function. JS Vooodoooo.\n  reportingBackoff = exponentialBackoff(1.5);\n  return reportingBackoff(work);\n};\n\n/**\n * Attempts to stringify a value, falling back to String.\n * @param {*} value\n * @return {string}\n */\nfunction tryJsonStringify(value) {\n  try {\n    // Cast is fine, because we really don't care here. Just trying.\n    return JSON.stringify(/** @type {!JsonObject} */ (value));\n  } catch (e) {\n    return String(value);\n  }\n}\n\n/**\n * @param {!Window} win\n * @param {*} error\n * @param {!Element=} opt_associatedElement\n */\nexport function reportErrorForWin(win, error, opt_associatedElement) {\n  reportError(error, opt_associatedElement);\n  if (\n    error &&\n    !!win &&\n    isUserErrorMessage(error.message) &&\n    !isUserErrorEmbedMessage(error.message)\n  ) {\n    reportErrorToAnalytics(/** @type {!Error} */ (error), win);\n  }\n}\n\n/**\n * Reports an error. If the error has an \"associatedElement\" property\n * the element is marked with the `i-amphtml-element-error` and displays\n * the message itself. The message is always send to the console.\n * If the error has a \"messageArray\" property, that array is logged.\n * This way one gets the native fidelity of the console for things like\n * elements instead of stringification.\n * @param {*} error\n * @param {!Element=} opt_associatedElement\n * @return {!Error}\n */\nexport function reportError(error, opt_associatedElement) {\n  try {\n    // Convert error to the expected type.\n    let isValidError;\n    if (error) {\n      if (error.message !== undefined) {\n        error = duplicateErrorIfNecessary(/** @type {!Error} */ (error));\n        isValidError = true;\n      } else {\n        const origError = error;\n        error = new Error(tryJsonStringify(origError));\n        error.origError = origError;\n      }\n    } else {\n      error = new Error('Unknown error');\n    }\n    // Report if error is not an expected type.\n    if (!isValidError && getMode().localDev && !getMode().test) {\n      setTimeout(function () {\n        const rethrow = new Error(\n          '_reported_ Error reported incorrectly: ' + error\n        );\n        throw rethrow;\n      });\n    }\n\n    if (error.reported) {\n      return /** @type {!Error} */ (error);\n    }\n    error.reported = true;\n\n    // `associatedElement` is used to add the i-amphtml-error class; in\n    // `#development=1` mode, it also adds `i-amphtml-element-error` to the\n    // element and sets the `error-message` attribute.\n    if (error.messageArray) {\n      const elIndex = findIndex(error.messageArray, (item) => item?.tagName);\n      if (elIndex > -1) {\n        error.associatedElement = error.messageArray[elIndex];\n      }\n    }\n    // Update element.\n    const element = opt_associatedElement || error.associatedElement;\n    if (element && element.classList) {\n      element.classList.add('i-amphtml-error');\n      if (getMode().development) {\n        element.classList.add('i-amphtml-element-error');\n        element.setAttribute('error-message', error.message);\n      }\n    }\n\n    // Report to console.\n    if (\n      self.console &&\n      (isUserErrorMessage(error.message) ||\n        !error.expected ||\n        getMode().localDev)\n    ) {\n      const output = console.error || console.log;\n      if (error.messageArray) {\n        output.apply(console, error.messageArray);\n      } else {\n        if (element) {\n          output.call(console, error.message, element);\n        } else if (!mode.isMinified()) {\n          output.call(console, error.stack);\n        } else {\n          output.call(console, error.message);\n        }\n      }\n    }\n    if (element && element.dispatchCustomEventForTesting) {\n      element.dispatchCustomEventForTesting(AmpEvents.ERROR, error.message);\n    }\n\n    // 'call' to make linter happy. And .call to make compiler happy\n    // that expects some @this.\n    onError['call'](self, undefined, undefined, undefined, undefined, error);\n  } catch (errorReportingError) {\n    setTimeout(function () {\n      throw errorReportingError;\n    });\n  }\n  return /** @type {!Error} */ (error);\n}\n\n/**\n * Returns an error for a cancellation of a promise.\n * @return {!Error}\n */\nexport function cancellation() {\n  return new Error(CANCELLED);\n}\n\n/**\n * @param {*} errorOrMessage\n * @return {boolean}\n */\nexport function isCancellation(errorOrMessage) {\n  if (!errorOrMessage) {\n    return false;\n  }\n  if (typeof errorOrMessage == 'string') {\n    return errorOrMessage.startsWith(CANCELLED);\n  }\n  if (typeof errorOrMessage.message == 'string') {\n    return errorOrMessage.message.startsWith(CANCELLED);\n  }\n  return false;\n}\n\n/**\n * Returns an error for component blocked by consent\n * @return {!Error}\n */\nexport function blockedByConsentError() {\n  return new Error(BLOCK_BY_CONSENT);\n}\n\n/**\n * @param {*} errorOrMessage\n * @return {boolean}\n */\nexport function isBlockedByConsent(errorOrMessage) {\n  if (!errorOrMessage) {\n    return false;\n  }\n  if (typeof errorOrMessage == 'string') {\n    return errorOrMessage.startsWith(BLOCK_BY_CONSENT);\n  }\n  if (typeof errorOrMessage.message == 'string') {\n    return errorOrMessage.message.startsWith(BLOCK_BY_CONSENT);\n  }\n  return false;\n}\n\n/**\n * Install handling of global unhandled exceptions.\n * @param {!Window} win\n */\nexport function installErrorReporting(win) {\n  win.onerror = /** @type {!Function} */ (onError);\n  win.addEventListener('unhandledrejection', (event) => {\n    if (\n      event.reason &&\n      (event.reason.message === CANCELLED ||\n        event.reason.message === BLOCK_BY_CONSENT ||\n        event.reason.message === ABORTED)\n    ) {\n      event.preventDefault();\n      return;\n    }\n    reportError(event.reason || new Error('rejected promise ' + event));\n  });\n}\n\n/**\n * Signature designed, so it can work with window.onerror\n * @param {string|undefined} message\n * @param {string|undefined} filename\n * @param {string|undefined} line\n * @param {string|undefined} col\n * @param {*|undefined} error\n * @this {!Window|undefined}\n */\nfunction onError(message, filename, line, col, error) {\n  // Make an attempt to unhide the body but don't if the error is actually expected.\n  // eslint-disable-next-line local/no-invalid-this\n  if (this && this.document && (!error || !error.expected)) {\n    // eslint-disable-next-line local/no-invalid-this\n    makeBodyVisibleRecovery(this.document);\n  }\n  if (getMode().localDev || getMode().development || getMode().test) {\n    return;\n  }\n  let hasNonAmpJs = false;\n  try {\n    hasNonAmpJs = detectNonAmpJs(self);\n  } catch (ignore) {\n    // Ignore errors during error report generation.\n  }\n  if (hasNonAmpJs && Math.random() > 0.01) {\n    // Only report 1% of errors on pages with non-AMP JS.\n    // These errors can almost never be acted upon, but spikes such as\n    // due to buggy browser extensions may be helpful to notify authors.\n    return;\n  }\n  const data = getErrorReportData(\n    message,\n    filename,\n    line,\n    col,\n    error,\n    hasNonAmpJs\n  );\n  if (data) {\n    reportingBackoff(() => {\n      try {\n        return reportErrorToServerOrViewer(\n          // eslint-disable-next-line local/no-invalid-this\n          this,\n          /** @type {!JsonObject} */\n          (data)\n        ).catch(() => {\n          // catch async errors to avoid recursive errors.\n        });\n      } catch (e) {\n        // catch async errors to avoid recursive errors.\n      }\n    });\n  }\n}\n\n/**\n * Determines the error reporting endpoint which should be used.\n * If changing this URL, keep `docs/spec/amp-errors.md` in sync.\n * @return {string} error reporting endpoint URL.\n */\nfunction chooseReportingUrl_() {\n  return Math.random() < BETA_ERROR_REPORT_URL_FREQ\n    ? urls.betaErrorReporting\n    : urls.errorReporting;\n}\n\n/**\n * Passes the given error data to either server or viewer.\n * @param {!Window} win\n * @param {!JsonObject} data Data from `getErrorReportData`.\n * @return {Promise<undefined>}\n */\nexport function reportErrorToServerOrViewer(win, data) {\n  // Report the error to viewer if it has the capability. The data passed\n  // to the viewer is exactly the same as the data passed to the server\n  // below.\n\n  // Throttle reports from Stable by 90%.\n  if (data['pt'] && Math.random() < 0.9) {\n    return Promise.resolve();\n  }\n\n  return maybeReportErrorToViewer(win, data).then((reportedErrorToViewer) => {\n    if (!reportedErrorToViewer) {\n      const xhr = new XMLHttpRequest();\n      xhr.open('POST', chooseReportingUrl_(), true);\n      xhr.send(JSON.stringify(data));\n    }\n  });\n}\n\n/**\n * Passes the given error data to the viewer if the following criteria is met:\n * - The viewer is a trusted viewer\n * - The viewer has the `errorReporter` capability\n * - The AMP doc is in single doc mode\n * - The AMP doc is opted-in for error interception (`<html>` tag has the\n *   `report-errors-to-viewer` attribute)\n *\n * @param {!Window} win\n * @param {!JsonObject} data Data from `getErrorReportData`.\n * @return {!Promise<boolean>} `Promise<True>` if the error was sent to the\n *     viewer, `Promise<False>` otherwise.\n * @visibleForTesting\n */\nexport function maybeReportErrorToViewer(win, data) {\n  const ampdocService = Services.ampdocServiceFor(win);\n  if (!ampdocService.isSingleDoc()) {\n    return Promise.resolve(false);\n  }\n  const ampdocSingle = ampdocService.getSingleDoc();\n  const htmlElement = ampdocSingle.getRootNode().documentElement;\n  const docOptedIn = htmlElement.hasAttribute('report-errors-to-viewer');\n  if (!docOptedIn) {\n    return Promise.resolve(false);\n  }\n  const viewer = Services.viewerForDoc(ampdocSingle);\n  if (!viewer.hasCapability('errorReporter')) {\n    return Promise.resolve(false);\n  }\n  return viewer.isTrustedViewer().then((viewerTrusted) => {\n    if (!viewerTrusted) {\n      return false;\n    }\n    viewer.sendMessage('error', errorReportingDataForViewer(data));\n    return true;\n  });\n}\n\n/**\n * Strips down the error reporting data to a minimal set\n * to be sent to the viewer.\n * @param {!JsonObject} errorReportData\n * @return {!JsonObject}\n * @visibleForTesting\n */\nexport function errorReportingDataForViewer(errorReportData) {\n  return dict({\n    'm': errorReportData['m'], // message\n    'a': errorReportData['a'], // isUserError\n    's': errorReportData['s'], // error stack\n    'el': errorReportData['el'], // tagName\n    'ex': errorReportData['ex'], // expected error?\n    'v': errorReportData['v'], // runtime\n    'pt': errorReportData['pt'], // is pre-throttled\n  });\n}\n\n/**\n * @param {string|undefined}  message\n * @param {*|undefined} error\n * @return {string}\n */\nfunction buildErrorMessage_(message, error) {\n  if (error) {\n    if (error.message) {\n      message = error.message;\n    } else {\n      // This should never be a string, but sometimes it is.\n      message = String(error);\n    }\n  }\n  if (!message) {\n    message = 'Unknown error';\n  }\n\n  return message;\n}\n\n/**\n * Signature designed, so it can work with window.onerror\n * @param {string|undefined} message\n * @param {string|undefined} filename\n * @param {string|undefined} line\n * @param {string|undefined} col\n * @param {*|undefined} error\n * @param {boolean} hasNonAmpJs\n * @return {!JsonObject|undefined} The data to post\n * visibleForTesting\n */\nexport function getErrorReportData(\n  message,\n  filename,\n  line,\n  col,\n  error,\n  hasNonAmpJs\n) {\n  message = buildErrorMessage_(message, error);\n  // An \"expected\" error is still an error, i.e. some features are disabled\n  // or not functioning fully because of it. However, it's an expected\n  // error. E.g. as is the case with some browser API missing (storage).\n  // Thus, the error can be classified differently by log aggregators.\n  // The main goal is to monitor that an \"expected\" error doesn't deteriorate\n  // over time. It's impossible to completely eliminate it.\n  let expected = !!(error && error.expected);\n  if (/_reported_/.test(message)) {\n    return;\n  }\n  if (message == CANCELLED) {\n    return;\n  }\n\n  const detachedWindow = !(self && self.window);\n  const throttleBase = Math.random();\n\n  // We throttle load errors and generic \"Script error.\" errors\n  // that have no information and thus cannot be acted upon.\n  if (\n    isLoadErrorMessage(message) ||\n    // See https://github.com/ampproject/amphtml/issues/7353\n    // for context.\n    message == 'Script error.' ||\n    // Window has become detached, really anything can happen\n    // at this point.\n    detachedWindow\n  ) {\n    expected = true;\n\n    if (throttleBase > NON_ACTIONABLE_ERROR_THROTTLE_THRESHOLD) {\n      return;\n    }\n  }\n\n  const isUserError = isUserErrorMessage(message);\n\n  // Only report a subset of user errors.\n  if (isUserError && throttleBase > USER_ERROR_THROTTLE_THRESHOLD) {\n    return;\n  }\n\n  // This is the App Engine app in\n  // https://github.com/ampproject/error-tracker\n  // It stores error reports via https://cloud.google.com/error-reporting/\n  // for analyzing production issues.\n  const data = /** @type {!JsonObject} */ (Object.create(null));\n  data['v'] = getMode().rtvVersion;\n  data['noAmp'] = hasNonAmpJs ? '1' : '0';\n  data['m'] = message.replace(USER_ERROR_SENTINEL, '');\n  data['a'] = isUserError ? '1' : '0';\n\n  // Errors are tagged with \"ex\" (\"expected\") label to allow loggers to\n  // classify these errors as benchmarks and not exceptions.\n  data['ex'] = expected ? '1' : '0';\n  data['dw'] = detachedWindow ? '1' : '0';\n\n  let runtime = '1p';\n  if (IS_SXG) {\n    runtime = 'sxg';\n    data['sxg'] = '1';\n  } else if (mode.isEsm()) {\n    runtime = 'esm';\n    data['esm'] = '1';\n  } else if (self.context && self.context.location) {\n    data['3p'] = '1';\n    runtime = '3p';\n  } else if (getMode().runtime) {\n    runtime = getMode().runtime;\n  }\n\n  data['rt'] = runtime;\n\n  // Add our a4a id if we are inabox\n  if (runtime === 'inabox') {\n    data['adid'] = getMode().a4aId;\n  }\n\n  // TODO(erwinm): Remove ca when all systems read `bt` instead of `ca` to\n  // identify js binary type.\n  data['ca'] = isCanary(self) ? '1' : '0';\n\n  // Pass binary type.\n  data['bt'] = getBinaryType(self);\n\n  if (self.location.ancestorOrigins && self.location.ancestorOrigins[0]) {\n    data['or'] = self.location.ancestorOrigins[0];\n  }\n  if (self.viewerState) {\n    data['vs'] = self.viewerState;\n  }\n  // Is embedded?\n  if (self.parent && self.parent != self) {\n    data['iem'] = '1';\n  }\n\n  if (self.AMP && self.AMP.viewer) {\n    const resolvedViewerUrl = self.AMP.viewer.getResolvedViewerUrl();\n    const messagingOrigin = self.AMP.viewer.maybeGetMessagingOrigin();\n    if (resolvedViewerUrl) {\n      data['rvu'] = resolvedViewerUrl;\n    }\n    if (messagingOrigin) {\n      data['mso'] = messagingOrigin;\n    }\n  }\n\n  const exps = [];\n  const experiments = experimentTogglesOrNull(self);\n  for (const exp in experiments) {\n    const on = experiments[exp];\n    exps.push(`${exp}=${on ? '1' : '0'}`);\n  }\n  data['exps'] = exps.join(',');\n\n  if (error) {\n    data['el'] = error.associatedElement?.tagName || 'u'; // Unknown\n\n    if (error.args) {\n      data['args'] = JSON.stringify(error.args);\n    }\n\n    if (!isUserError && !error.ignoreStack && error.stack) {\n      data['s'] = error.stack;\n    }\n\n    // TODO(jridgewell, #18574); Make sure error is always an object.\n    if (error.message) {\n      error.message += ' _reported_';\n    }\n  } else {\n    data['f'] = filename || '';\n    data['l'] = line || '';\n    data['c'] = col || '';\n  }\n  data['r'] = self.document ? self.document.referrer : '';\n  data['ae'] = accumulatedErrorMessages.join(',');\n  data['fr'] = self.location['originalHash'] || self.location.hash;\n\n  // TODO(https://github.com/ampproject/error-tracker/issues/129): Remove once\n  // all clients are serving a version with pre-throttling.\n  if (data['bt'] === 'production') {\n    // Setting this field allows the error reporting service to know that this\n    // error has already been pre-throttled for Stable, so it doesn't need to\n    // throttle again.\n    data['pt'] = '1';\n  }\n\n  pushLimit(accumulatedErrorMessages, message, 25);\n\n  return data;\n}\n\n/**\n * Returns true if it appears like there is non-AMP JS on the\n * current page.\n * @param {!Window} win\n * @return {boolean}\n * @visibleForTesting\n */\nexport function detectNonAmpJs(win) {\n  if (!win.document) {\n    return false;\n  }\n  const scripts = win.document.querySelectorAll('script[src]');\n  for (let i = 0; i < scripts.length; i++) {\n    if (!isProxyOrigin(scripts[i].src.toLowerCase())) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Resets accumulated error messages for testing\n */\nexport function resetAccumulatedErrorMessagesForTesting() {\n  accumulatedErrorMessages = [];\n}\n\n/**\n * @param {!Error} error\n * @param {!Window} win\n */\nexport function reportErrorToAnalytics(error, win) {\n  // Currently this can only be executed in a single-doc mode. Otherwise,\n  // it's not clear which ampdoc the event would belong too.\n  if (Services.ampdocServiceFor(win).isSingleDoc()) {\n    const vars = dict({\n      'errorName': error.name,\n      'errorMessage': error.message,\n    });\n    triggerAnalyticsEvent(\n      getRootElement_(win),\n      'user-error',\n      vars,\n      /** enableDataVars */ false\n    );\n  }\n}\n\n/**\n * @param {!Window} win\n * @return {!Element}\n * @private\n */\nfunction getRootElement_(win) {\n  const root = Services.ampdocServiceFor(win).getSingleDoc().getRootNode();\n  return dev().assertElement(root.documentElement || root.body || root);\n}\n", "import {parseSrcset} from '#core/dom/srcset';\n\nimport {user} from '#utils/log';\n\nimport {urls} from './config';\nimport {\n  checkCorsUrl,\n  getSourceUrl,\n  isProxyOrigin,\n  parseUrlDeprecated,\n  resolveRelativeUrl,\n} from './url';\n\nconst TAG = 'URL-REWRITE';\n\n/** @private @const {string} */\nconst ORIGINAL_TARGET_VALUE = '__AMP_ORIGINAL_TARGET_VALUE_';\n\n/**\n * The same as rewriteAttributeValue() but actually updates the element and\n * modifies other related attribute(s) for special cases, i.e. `target` for <a>.\n * @param {!Element} element\n * @param {string} attrName\n * @param {string} attrValue\n * @param {!Location=} opt_location\n * @param {boolean=} opt_updateProperty\n * @return {string}\n */\nexport function rewriteAttributesForElement(\n  element,\n  attrName,\n  attrValue,\n  opt_location,\n  opt_updateProperty\n) {\n  const tag = element.tagName.toLowerCase();\n  const attr = attrName.toLowerCase();\n  const rewrittenValue = rewriteAttributeValue(tag, attr, attrValue);\n  // When served from proxy (CDN), changing an <a> tag from a hash link to a\n  // non-hash link requires updating `target` attribute per cache modification\n  // rules. @see amp-cache-modifications.md#url-rewrites\n  const isProxy = isProxyOrigin(opt_location || self.location);\n  if (isProxy && tag === 'a' && attr === 'href') {\n    const oldValue = element.getAttribute(attr);\n    const newValueIsHash = rewrittenValue[0] === '#';\n    const oldValueIsHash = oldValue && oldValue[0] === '#';\n\n    if (newValueIsHash && !oldValueIsHash) {\n      // Save the original value of `target` so it can be restored (if needed).\n      if (!element[ORIGINAL_TARGET_VALUE]) {\n        element[ORIGINAL_TARGET_VALUE] = element.getAttribute('target');\n      }\n      element.removeAttribute('target');\n    } else if (oldValueIsHash && !newValueIsHash) {\n      // Restore the original value of `target` or default to `_top`.\n      element.setAttribute('target', element[ORIGINAL_TARGET_VALUE] || '_top');\n    }\n  }\n  if (opt_updateProperty) {\n    // Must be done first for <input> elements to correctly update the UI for\n    // the first change on Safari and Chrome.\n    element[attr] = rewrittenValue;\n  }\n  element.setAttribute(attr, rewrittenValue);\n  return rewrittenValue;\n}\n\n/**\n * If (tagName, attrName) is a CDN-rewritable URL attribute, returns the\n * rewritten URL value. Otherwise, returns the unchanged `attrValue`.\n * See resolveUrlAttr() for rewriting rules.\n * @param {string} tagName Lowercase tag name.\n * @param {string} attrName Lowercase attribute name.\n * @param {string} attrValue\n * @return {string}\n * @visibleForTesting\n */\nexport function rewriteAttributeValue(tagName, attrName, attrValue) {\n  if (isUrlAttribute(attrName)) {\n    return resolveUrlAttr(tagName, attrName, attrValue, self.location);\n  }\n  return attrValue;\n}\n\n/**\n * @param {string} attrName Lowercase attribute name.\n * @return {boolean}\n */\nexport function isUrlAttribute(attrName) {\n  return (\n    attrName == 'src' ||\n    attrName == 'href' ||\n    attrName == 'xlink:href' ||\n    attrName == 'srcset'\n  );\n}\n\n/**\n * Rewrites the URL attribute values. URLs are rewritten as following:\n * - If URL is absolute, it is not rewritten\n * - If URL is relative, it's rewritten as absolute against the source origin\n * - If resulting URL is a `http:` URL and it's for image, the URL is rewritten\n *   again to be served with AMP Cache (cdn.ampproject.org).\n *\n * @param {string} tagName Lowercase tag name.\n * @param {string} attrName Lowercase attribute name.\n * @param {string} attrValue\n * @param {!Location} windowLocation\n * @return {string}\n * @private\n * @visibleForTesting\n */\nexport function resolveUrlAttr(tagName, attrName, attrValue, windowLocation) {\n  checkCorsUrl(attrValue);\n  const isProxyHost = isProxyOrigin(windowLocation);\n  const baseUrl = parseUrlDeprecated(getSourceUrl(windowLocation));\n\n  if (attrName == 'href' && !attrValue.startsWith('#')) {\n    return resolveRelativeUrl(attrValue, baseUrl);\n  }\n\n  if (attrName == 'src') {\n    if (tagName == 'amp-img') {\n      return resolveImageUrlAttr(attrValue, baseUrl, isProxyHost);\n    }\n    return resolveRelativeUrl(attrValue, baseUrl);\n  }\n\n  if (attrName == 'srcset') {\n    let srcset;\n    try {\n      srcset = parseSrcset(attrValue);\n    } catch (e) {\n      // Do not fail the whole template just because one srcset is broken.\n      // An AMP element will pick it up and report properly.\n      user().error(TAG, 'Failed to parse srcset: ', e);\n      return attrValue;\n    }\n    return srcset.stringify((url) =>\n      resolveImageUrlAttr(url, baseUrl, isProxyHost)\n    );\n  }\n\n  return attrValue;\n}\n\n/**\n * Non-HTTPs image URLs are rewritten via proxy.\n * @param {string} attrValue\n * @param {!Location} baseUrl\n * @param {boolean} isProxyHost\n * @return {string}\n */\nfunction resolveImageUrlAttr(attrValue, baseUrl, isProxyHost) {\n  const src = parseUrlDeprecated(resolveRelativeUrl(attrValue, baseUrl));\n\n  // URLs such as `data:` or proxy URLs are returned as is. Unsafe protocols\n  // do not arrive here - already stripped by the sanitizer.\n  if (src.protocol == 'data:' || isProxyOrigin(src) || !isProxyHost) {\n    return src.href;\n  }\n\n  // Rewrite as a proxy URL.\n  return (\n    `${urls.cdn}/i/` +\n    (src.protocol == 'https:' ? 's/' : '') +\n    encodeURIComponent(src.host) +\n    src.pathname +\n    (src.search || '') +\n    (src.hash || '')\n  );\n}\n", "import {devAssert} from '#core/assert';\n\nimport {Services} from '#service';\nimport {calculateEntryPointScriptUrl} from '#service/extension-script';\n\nimport {dev} from '#utils/log';\n\nimport {ModeDef, getMode} from '../mode';\nimport {getService, registerServiceBuilder} from '../service-helpers';\n\nconst TAG = 'web-worker';\n\n/**\n * @typedef {{method: string, resolve: !Function, reject: !Function}}\n */\nlet PendingMessageDef;\n\n/**\n * Invokes function named `method` with args `opt_args` on the web worker\n * and returns a Promise that will be resolved with the function's return value.\n *\n * If `opt_localWin` is provided, method will be executed in a scope limited\n * to other invocations with `opt_localWin`.\n *\n * Note: Currently only works in a single entry point (amp-bind.js).\n *\n * @param {!Window} win\n * @param {string} method\n * @param {!Array=} opt_args\n * @param {!Window=} opt_localWin\n * @return {!Promise}\n */\nexport function invokeWebWorker(win, method, opt_args, opt_localWin) {\n  if (!win.Worker) {\n    return Promise.reject('Worker not supported in window.');\n  }\n  registerServiceBuilder(win, 'amp-worker', AmpWorker);\n  const worker = getService(win, 'amp-worker');\n  return worker.sendMessage_(method, opt_args || [], opt_localWin);\n}\n\n/**\n * @param {!Window} win\n * @return {!AmpWorker}\n * @visibleForTesting\n */\nexport function ampWorkerForTesting(win) {\n  registerServiceBuilder(win, 'amp-worker', AmpWorker);\n  return getService(win, 'amp-worker');\n}\n\n/**\n * A Promise-based API wrapper around a single Web Worker.\n * @private\n */\nclass AmpWorker {\n  /**\n   * @param {!Window} win\n   */\n  constructor(win) {\n    /** @const @private {!Window} */\n    this.win_ = win;\n\n    /** @const @private {!../service/xhr-impl.Xhr} */\n    this.xhr_ = Services.xhrFor(win);\n\n    // Use `testLocation` for testing with iframes. @see testing/iframe.js.\n    let loc = win.location;\n    if (getMode().test && win.testLocation) {\n      loc = win.testLocation;\n    }\n    // Use RTV to make sure we fetch prod/canary/experiment correctly.\n    const useLocal = getMode().localDev || getMode().test;\n    const useRtvVersion = !useLocal;\n    const url = calculateEntryPointScriptUrl(\n      loc,\n      'ww',\n      useLocal,\n      useRtvVersion\n    );\n    dev().fine(TAG, 'Fetching web worker from', url);\n\n    /** @private {Worker} */\n    this.worker_ = null;\n\n    /** @const @private {!Promise} */\n    this.fetchPromise_ = this.xhr_\n      .fetchText(url, {\n        ampCors: false,\n        bypassInterceptorForDev: getMode().localDev,\n      })\n      .then((res) => res.text())\n      .then((text) => {\n        // Replace sourceMappingUrl with the absolute URL\n        const sourceMappingUrl = `${url}.map`;\n        text = text.replace(\n          /^\\/\\/# sourceMappingURL=.*/,\n          `//# sourceMappingURL=${sourceMappingUrl}`\n        );\n\n        // Workaround since Worker constructor only accepts same origin URLs.\n        const blob = new win.Blob([text + '\\n//# sourceurl=' + url], {\n          type: 'text/javascript',\n        });\n        const blobUrl = win.URL.createObjectURL(blob);\n        this.worker_ = new win.Worker(blobUrl);\n        this.worker_.onmessage = this.receiveMessage_.bind(this);\n      });\n\n    /**\n     * Array of in-flight messages pending response from worker.\n     * @const @private {!Object<number, PendingMessageDef>}\n     */\n    this.messages_ = {};\n\n    /**\n     * Monotonically increasing integer that increments on each message.\n     * @private {number}\n     */\n    this.counter_ = 0;\n\n    /**\n     * Array of top-level and local windows passed into `invokeWebWorker`.\n     * Used to uniquely identify windows for scoping worker functions when\n     * a single worker is used for multiple windows (i.e. FIE).\n     * @const @private {!Array<!Window>}\n     */\n    this.windows_ = [win];\n  }\n\n  /**\n   * Sends a method invocation request to the worker and returns a Promise.\n   * @param {string} method\n   * @param {!Array} args\n   * @param {Window=} opt_localWin\n   * @return {!Promise}\n   * @private\n   * @restricted\n   */\n  sendMessage_(method, args, opt_localWin) {\n    return this.fetchPromise_.then(() => {\n      return new Promise((resolve, reject) => {\n        const id = this.counter_++;\n        this.messages_[id] = {method, resolve, reject};\n\n        const scope = this.idForWindow_(opt_localWin || this.win_);\n\n        const message = /** @type {ToWorkerMessageDef} */ ({\n          method,\n          args,\n          scope,\n          id,\n        });\n        this.worker_./*OK*/ postMessage(message);\n      });\n    });\n  }\n\n  /**\n   * Receives the result of a method invocation from the worker and resolves\n   * the Promise returned from the corresponding `sendMessage_()` call.\n   * @param {!MessageEvent} event\n   * @private\n   */\n  receiveMessage_(event) {\n    const {id, method, returnValue} = /** @type {FromWorkerMessageDef} */ (\n      event.data\n    );\n\n    const message = this.messages_[id];\n    if (!message) {\n      dev().error(\n        TAG,\n        `Received unexpected message (${method}, ${id}) from worker.`\n      );\n      return;\n    }\n    devAssert(\n      method == message.method,\n      'Received mismatched method ' +\n        `(${method}, ${id}), expected ${message.method}.`\n    );\n\n    message.resolve(returnValue);\n\n    delete this.messages_[id];\n  }\n\n  /**\n   * @return {boolean}\n   * @visibleForTesting\n   */\n  hasPendingMessages() {\n    return Object.keys(this.messages_).length > 0;\n  }\n\n  /**\n   * Returns an identifier for `win`, unique for set of windows seen so far.\n   * @param {!Window} win\n   * @return {number}\n   * @private\n   */\n  idForWindow_(win) {\n    const index = this.windows_.indexOf(win);\n    if (index >= 0) {\n      return index;\n    } else {\n      return this.windows_.push(win) - 1;\n    }\n  }\n\n  /**\n   * @return {!Promise}\n   * @visibleForTesting\n   */\n  fetchPromiseForTesting() {\n    return this.fetchPromise_;\n  }\n}\n", "import {RAW_OBJECT_ARGS_KEY} from '#core/constants/action-constants';\nimport {AmpEvents} from '#core/constants/amp-events';\nimport {Deferred} from '#core/data-structures/promise';\nimport {Signals} from '#core/data-structures/signals';\nimport {isAmp4Email} from '#core/document/format';\nimport {iterateCursor} from '#core/dom';\nimport {whenUpgradedToCustomElement} from '#core/dom/amp-element-helpers';\nimport {escapeCssSelectorIdent} from '#core/dom/css-selectors';\nimport {closestAncestorElementBySelector} from '#core/dom/query';\nimport {isFiniteNumber, isObject} from '#core/types';\nimport {findIndex, isArray, remove, toArray} from '#core/types/array';\nimport {debounce} from '#core/types/function';\nimport {deepMerge, dict, getValueForExpr, map} from '#core/types/object';\nimport {deepEquals, parseJson} from '#core/types/object/json';\n\nimport {Services} from '#service';\n\nimport {createCustomEvent, getDetail} from '#utils/event-helper';\nimport {dev, devAssert, user} from '#utils/log';\n\nimport {BindEvents} from './bind-events';\nimport {BindValidator} from './bind-validator';\n\nimport {ChunkPriority, chunk} from '../../../src/chunk';\nimport {reportError} from '../../../src/error-reporting';\nimport {getMode} from '../../../src/mode';\nimport {rewriteAttributesForElement} from '../../../src/url-rewrite';\nimport {invokeWebWorker} from '../../../src/web-worker/amp-worker';\n\n/** @const {string} */\nconst TAG = 'amp-bind';\n\n/**\n * Regular expression that identifies AMP CSS classes.\n * Includes 'i-amphtml-', '-amp-', and 'amp-' prefixes.\n * @type {!RegExp}\n */\nconst AMP_CSS_RE = /^(i?-)?amp(html)?-/;\n\n/**\n * Maximum depth for state merge.\n * @type {number}\n */\nconst MAX_MERGE_DEPTH = 10;\n\n/** @const {!Object<string, !Object<string, boolean>>} */\nconst FORM_VALUE_PROPERTIES = {\n  'INPUT': {\n    'checked': true,\n    'value': true,\n  },\n  'OPTION': {\n    'selected': true,\n  },\n  'TEXTAREA': {\n    'text': true,\n    // amp-form relies on FORM_VALUE_CHANGE to update form validity state due\n    // to value changes from amp-bind. However, disabled form elements always\n    // report \"valid\" even if they have invalid values! A consequence is that\n    // toggling `disabled` via amp-bind may affect validity, so we need to\n    // inform amp-form about these too.\n    'disabled': true,\n  },\n};\n\n/**\n * A bound property, e.g. [property]=\"expression\".\n * `previousResult` is the result of this expression during the last evaluation.\n * @typedef {{property: string, expressionString: string, previousResult: (BindExpressionResultDef|undefined)}}\n */\nlet BoundPropertyDef;\n\n/**\n * A tuple containing a single element and all of its bound properties.\n * @typedef {{boundProperties: !Array<BoundPropertyDef>, element: !Element}}\n */\nlet BoundElementDef;\n\n/**\n * The options bag for binding application.\n *\n * @typedef {Record} ApplyOptionsDef\n * @property {boolean=} skipAmpState If true, skips <amp-state> elements.\n * @property {Array<!Element>=} constrain If provided, restricts application to children of the provided elements.\n * @property {boolean=} evaluateOnly If provided, caches the evaluated result on each bound element and skips the actual DOM updates.\n */\n\n/**\n * A map of tag names to arrays of attributes that do not have non-bind\n * counterparts. For instance, amp-carousel allows a `[slide]` attribute,\n * but does not support a `slide` attribute.\n * @const {!Object<string, !Array<string>>}\n */\nconst BIND_ONLY_ATTRIBUTES = map({\n  'AMP-CAROUSEL': ['slide'],\n  'AMP-LIST': ['is-layout-container'],\n  'AMP-SELECTOR': ['selected'],\n});\n\n/**\n * Elements that opt-out of tree walking in favor of rescan() with {fast: true}.\n * @const {!Array<string>}\n */\nconst FAST_RESCAN_TAGS = ['AMP-LIST', 'AMP-RENDER'];\n\n/**\n * Bind is an ampdoc-scoped service that handles the Bind lifecycle, from\n * scanning for bindings to evaluating expressions to mutating elements.\n */\nexport class Bind {\n  /**\n   * @param {!../../../src/service/ampdoc-impl.AmpDoc} ampdoc\n   */\n  constructor(ampdoc) {\n    /** @const {!../../../src/service/ampdoc-impl.AmpDoc} */\n    this.ampdoc = ampdoc;\n\n    /** @const @private {!Window} */\n    this.win_ = ampdoc.win;\n\n    /**\n     * The window containing the document to scan.\n     * May differ from the `ampdoc`'s window e.g. in FIE.\n     * @const @private {!Window}\n     */\n    this.localWin_ = ampdoc.win;\n\n    /**\n     * Array of ActionInvocation.sequenceId values that have been invoked.\n     * Used to ensure that only one \"AMP.setState\" or \"AMP.pushState\" action\n     * may be triggered per event. Periodically cleared.\n     * @const @private {!Array<number>}\n     */\n    this.actionSequenceIds_ = [];\n\n    /** @const @private {!Function} */\n    this.eventuallyClearActionSequenceIds_ = debounce(\n      this.win_,\n      () => {\n        this.actionSequenceIds_.length = 0;\n      },\n      5000\n    );\n\n    /** @private {!Array<BoundElementDef>} */\n    this.boundElements_ = [];\n\n    /**\n     * Maps expression string to the element(s) that contain it.\n     * @private @const {!Object<string, !Array<!Element>>}\n     */\n    this.expressionToElements_ = map();\n\n    /** @private {!../../../src/service/history-impl.History} */\n    this.history_ = Services.historyForDoc(ampdoc);\n\n    /** @private {!Array<string>} */\n    this.overridableKeys_ = [];\n\n    /**\n     * Upper limit on total number of bindings.\n     *\n     * The initial value is set to 1000 which, based on ~2ms expression parse\n     * time, caps \"time to interactive\" at ~2s after page load.\n     *\n     * User interactions can add new bindings (e.g. infinite scroll), so this\n     * can increase over time to a final limit of 2000 bindings.\n     *\n     * @private {number}\n     */\n    this.maxNumberOfBindings_ = 1000;\n\n    /** @const @private {!../../../src/service/mutator-interface.MutatorInterface} */\n    this.mutator_ = Services.mutatorForDoc(ampdoc);\n\n    /**\n     * The current values of all bound expressions on the page.\n     * @const @private {!JsonObject}\n     */\n    this.state_ = /** @type {!JsonObject} */ (map());\n\n    /** @const {!../../../src/service/timer-impl.Timer} */\n    this.timer_ = Services.timerFor(this.win_);\n\n    /** @private {?./bind-validator.BindValidator} */\n    this.validator_ = null;\n\n    /** @const @private {!../../../src/service/viewer-interface.ViewerInterface} */\n    this.viewer_ = Services.viewerForDoc(this.ampdoc);\n    this.viewer_.onMessageRespond('premutate', this.premutate_.bind(this));\n\n    /** @const @private {!Promise<!Document>} */\n    this.rootNodePromise_ = ampdoc.whenFirstVisible().then(() => {\n      // Otherwise, scan the root node of the ampdoc.\n      return ampdoc.whenReady().then(() => ampdoc.getRootNode());\n    });\n\n    /**\n     * Resolved when the service finishes scanning the document for bindings.\n     * @const @private {Promise}\n     */\n    this.initializePromise_ = this.rootNodePromise_.then((root) =>\n      this.initialize_(root)\n    );\n\n    /** @const @private {!Deferred} */\n    this.addMacrosDeferred_ = new Deferred();\n\n    /** @private {Promise} */\n    this.setStatePromise_ = null;\n\n    /** @private @const {!../../../src/utils/signals.Signals} */\n    this.signals_ = new Signals();\n\n    // Install debug tools.\n    const g = self.AMP;\n    g.printState = g.printState || this.debugPrintState_.bind(this);\n    g.setState = g.setState || ((state) => this.setState(state));\n    g.eval = g.eval || this.debugEvaluate_.bind(this);\n  }\n\n  /**\n   * @return {!../../../src/utils/signals.Signals}\n   */\n  signals() {\n    return this.signals_;\n  }\n\n  /**\n   * Merges `state` into the current state and immediately triggers an\n   * evaluation unless `skipEval` is false.\n   * @param {!JsonObject} state\n   * @param {!BindSetStateOptionsDef} opts options bag\n   * @return {!Promise}\n   */\n  setState(state, opts = {}) {\n    dev().info(TAG, 'setState (init=%s):', opts.skipEval, state);\n\n    try {\n      deepMerge(this.state_, state, MAX_MERGE_DEPTH);\n    } catch (e) {\n      user().error(TAG, 'Failed to merge result from AMP.setState().', e);\n    }\n\n    if (opts.skipEval) {\n      return Promise.resolve();\n    }\n\n    const promise = this.initializePromise_\n      .then(() => this.evaluate_())\n      .then((results) =>\n        this.apply_(results, {\n          skipAmpState: opts.skipAmpState,\n          constrain: opts.constrain,\n        })\n      );\n\n    if (getMode().test) {\n      promise.then(() => {\n        this.dispatchEventForTesting_(BindEvents.SET_STATE);\n      });\n    }\n\n    return (this.setStatePromise_ = promise);\n  }\n\n  /**\n   * Executes an `AMP.setState()` or `AMP.pushState()` action.\n   * @param {!../../../src/service/action-impl.ActionInvocation} invocation\n   * @return {!Promise}\n   */\n  invoke(invocation) {\n    const {args, event, method, sequenceId, tagOrTarget} = invocation;\n\n    // Store the sequenceId values of action invocations and only allow one\n    // setState() or pushState() event per sequence.\n    if (this.actionSequenceIds_.includes(sequenceId)) {\n      user().error(TAG, 'One state action allowed per event.');\n      return Promise.resolve();\n    }\n    this.actionSequenceIds_.push(sequenceId);\n    // Flush stored sequence IDs five seconds after the last invoked action.\n    this.eventuallyClearActionSequenceIds_();\n\n    const expression = args[RAW_OBJECT_ARGS_KEY];\n    if (expression) {\n      // Increment bindings limit by 500 on each invocation to a max of 2000.\n      this.maxNumberOfBindings_ = Math.min(\n        2000,\n        Math.max(1000, this.maxNumberOfBindings_ + 500)\n      );\n\n      this.signals_.signal('FIRST_MUTATE');\n\n      const scope = dict();\n      if (event && getDetail(/** @type {!Event} */ (event))) {\n        scope['event'] = getDetail(/** @type {!Event} */ (event));\n      }\n      switch (method) {\n        case 'setState':\n          return this.setStateWithExpression(expression, scope);\n        case 'pushState':\n          return this.pushStateWithExpression(expression, scope);\n        default:\n          return Promise.reject(\n            dev().createError('Unrecognized method: %s.%s', tagOrTarget, method)\n          );\n      }\n    } else {\n      user().error(\n        'AMP-BIND',\n        'Please use the object-literal syntax, ' +\n          'e.g. \"AMP.setState({foo: \\'bar\\'})\" instead of ' +\n          '\"AMP.setState(foo=\\'bar\\')\".'\n      );\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Parses and evaluates an expression with a given scope and merges the\n   * resulting object into current state.\n   * @param {string} expression\n   * @param {!JsonObject} scope\n   * @return {!Promise}\n   */\n  setStateWithExpression(expression, scope) {\n    return this.evaluateExpression_(expression, scope).then((result) =>\n      this.setStateAndUpdateHistory_(result)\n    );\n  }\n\n  /**\n   * Sanitizes a state object and merges the resulting object into the current\n   * state.\n   * @param {!JsonObject} state\n   * @return {!Promise}\n   */\n  setStateWithObject(state) {\n    // Sanitize and copy state\n    const result = this.copyJsonObject_(state);\n    if (!result) {\n      return Promise.reject('Invalid state');\n    }\n    return this.setStateAndUpdateHistory_(result);\n  }\n\n  /**\n   * Merges a state object into the current global state.\n   * @param {!JsonObject} state\n   * @return {!Promise}\n   * @private\n   */\n  setStateAndUpdateHistory_(state) {\n    dev().info(TAG, 'setState:', state);\n    this.setStatePromise_ = this.setState(state)\n      .then(() => this.getDataForHistory_())\n      .then((data) => {\n        // Don't bother calling History.replace with empty data.\n        if (data) {\n          this.history_.replace(data);\n        }\n      });\n    return this.setStatePromise_;\n  }\n\n  /**\n   * Same as setStateWithExpression() except also pushes new history.\n   * Popping the new history stack entry will restore the values of variables\n   * in `expression`.\n   * @param {string} expression\n   * @param {!JsonObject} scope\n   * @return {!Promise}\n   */\n  pushStateWithExpression(expression, scope) {\n    dev().info(TAG, 'pushState:', expression);\n    return this.evaluateExpression_(expression, scope).then((result) => {\n      // Store the current values of each referenced variable in `expression`\n      // so that we can restore them on history-pop.\n      const oldState = map();\n      Object.keys(result).forEach((variable) => {\n        const value = this.state_[variable];\n        // Store a deep copy of `value` to make sure `oldState` isn't\n        // modified by subsequent setState() actions.\n        oldState[variable] = this.copyJsonObject_(value);\n      });\n\n      const onPop = () => this.setState(oldState);\n      return this.setState(result)\n        .then(() => this.getDataForHistory_())\n        .then((data) => {\n          this.history_.push(onPop, data);\n        });\n    });\n  }\n\n  /**\n   * Returns data that should be saved in browser history on AMP.setState() or\n   * AMP.pushState(). This enables features like restoring browser tabs.\n   * @return {!Promise<?JsonObject>}\n   */\n  getDataForHistory_() {\n    const data = dict({\n      'data': dict({'amp-bind': this.state_}),\n      'title': this.localWin_.document.title,\n    });\n    if (!this.viewer_.isEmbedded()) {\n      // CC doesn't recognize !JsonObject as a subtype of (JsonObject|null).\n      return /** @type {!Promise<?JsonObject>} */ (Promise.resolve(data));\n    }\n    // Only pass state for history updates to trusted viewers, since they\n    // may contain user data e.g. form input.\n    return this.viewer_.isTrustedViewer().then((trusted) => {\n      return trusted ? data : null;\n    });\n  }\n\n  /**\n   * Removes bindings from `removedElements` and adds new bindings in\n   * `addedElements`.\n   *\n   * If `options.update` is true, evaluates and applies changes to\n   * `addedElements` after adding new bindings. If \"evaluate\",\n   * it skips the actual DOM update but caches the expression results.\n   *\n   * If `options.fast` is true, uses a faster scan method that requires\n   * (1) elements with bindings to have the attribute `i-amphtml-binding` and\n   * (2) the parent element tag name be listed in FAST_RESCAN_TAGS.\n   *\n   * @param {!Array<!Element>} addedElements\n   * @param {!Array<!Element>} removedElements\n   * @param {!BindRescanOptionsDef=} options\n   * @return {!Promise} Resolved when all operations complete. If they don't\n   * complete within `options.timeout` (default=2000), promise is rejected.\n   */\n  rescan(addedElements, removedElements, options = {}) {\n    // * In non-fast mode, wait for initial tree walk to avoid racy double\n    //   scanning of `addedElements` which may cause duplicate bindings.\n    // * In fast mode, the initial tree walk skips subtrees of FAST_RESCAN_TAGS\n    //   so only wait for <amp-bind-macro> setup (much faster!).\n    const waitFor = options.fast\n      ? this.addMacrosDeferred_.promise\n      : this.initializePromise_;\n\n    return waitFor.then(() =>\n      this.timer_.timeoutPromise(\n        options.timeout || 2000,\n        this.rescan_(addedElements, removedElements, options),\n        'Timed out waiting for amp-bind to rescan.'\n      )\n    );\n  }\n\n  /**\n   * @param {!Array<!Element>} addedElements\n   * @param {!Array<!Element>} removedElements\n   * @param {!BindRescanOptionsDef} options\n   * @return {!Promise}\n   * @private\n   */\n  rescan_(addedElements, removedElements, options) {\n    dev().info(TAG, 'rescan: ', addedElements, removedElements, options);\n\n    const rescanPromise = options.fast\n      ? this.fastScan_(addedElements, removedElements)\n      : this.slowScan_(addedElements, removedElements);\n\n    return rescanPromise.then(() => {\n      if (options.update) {\n        return this.evaluate_().then((results) =>\n          this.apply_(results, {\n            constrain: addedElements,\n            evaluateOnly: options.update === 'evaluate',\n          })\n        );\n      }\n    });\n  }\n\n  /**\n   * @param {!Array<!Element>} addedElements\n   * @param {!Array<!Element>} removedElements\n   * @return {!Promise}\n   * @private\n   */\n  fastScan_(addedElements, removedElements) {\n    // Sync remove bindings from internal state first, but don't chain on\n    // returned promise (worker message) as an optimization.\n    const removePromise = this.removeBindingsForNodes_(removedElements);\n\n    // Scan `addedElements` and descendants for bindings.\n    const bindings = [];\n    const elementsToScan = addedElements.filter((el) =>\n      el.hasAttribute('i-amphtml-binding')\n    );\n    addedElements.forEach((el) => {\n      const children = el.querySelectorAll('[i-amphtml-binding]');\n      Array.prototype.push.apply(elementsToScan, children);\n    });\n    const quota = this.maxNumberOfBindings_ - this.numberOfBindings();\n    for (let i = 0; i < elementsToScan.length; i++) {\n      const el = elementsToScan[i];\n      if (this.scanElement_(el, quota - bindings.length, bindings)) {\n        break;\n      }\n    }\n\n    removePromise.then((removed) => {\n      dev().info(\n        TAG,\n        'rescan.fast: delta=%s, total=%s',\n        bindings.length - removed,\n        this.numberOfBindings()\n      );\n    });\n\n    if (bindings.length > 0) {\n      return this.sendBindingsToWorker_(bindings);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  /**\n   * Returns a copy of the global state for a given field-based expression,\n   * e.g. \"foo.bar\".\n   * @param {string} expr\n   * @return {*}\n   */\n  getState(expr) {\n    const value = expr ? getValueForExpr(this.state_, expr) : undefined;\n    if (isObject(value) || isArray(value)) {\n      return this.copyJsonObject_(/** @type {JsonObject} */ (value));\n    }\n    return value;\n  }\n\n  /**\n   * Returns a copy of the global state for an expression, after waiting for its\n   * associated 'amp-state' element to finish fetching data. If there is no\n   * corresponding 'amp-state' element in the DOM, then reject.\n   *\n   * e.g. \"foo.bar\".\n   * @param {string} expr\n   * @return {!Promise<*>}\n   */\n  getStateAsync(expr) {\n    const stateId = /^[^.]*/.exec(expr)[0];\n    return this.rootNodePromise_.then((root) => {\n      const ampStateEl = root.querySelector(\n        `#${escapeCssSelectorIdent(stateId)}`\n      );\n      if (!ampStateEl) {\n        throw user().createError(TAG, `#${stateId} does not exist.`);\n      }\n\n      return whenUpgradedToCustomElement(ampStateEl)\n        .then((el) => el.getImpl(true))\n        .then((ampState) => ampState.getFetchingPromise())\n        .catch(() => {})\n        .then(() => this.getState(expr));\n    });\n  }\n\n  /**\n   * Returns the stringified value of the global state for a given field-based\n   * expression, e.g. \"foo.bar.baz\".\n   * @param {string} expr\n   * @return {?string}\n   */\n  getStateValue(expr) {\n    const value = getValueForExpr(this.state_, expr);\n    if (value === undefined || value === null) {\n      return null;\n    } else if (isObject(value) || isArray(value)) {\n      return JSON.stringify(/** @type {JsonObject} */ (value));\n    } else {\n      return String(value);\n    }\n  }\n\n  /**\n   * Scans the root node (and array of optional nodes) for bindings.\n   * @param {!Node} root\n   * @return {!Promise}\n   * @private\n   */\n  initialize_(root) {\n    // Disallow URL property bindings in AMP4EMAIL.\n    const allowUrlProperties = !isAmp4Email(this.localWin_.document);\n    this.validator_ = new BindValidator(allowUrlProperties);\n\n    // The web worker's evaluator also has an instance of BindValidator\n    // that should be initialized with the same `allowUrlProperties` value.\n    return this.ww_('bind.init', [allowUrlProperties])\n      .then(() => {\n        return Promise.all([\n          this.addMacros_().then(() => this.addMacrosDeferred_.resolve()),\n          this.addBindingsForNodes_([root]),\n        ]);\n      })\n      .then(() => {\n        // Listen for DOM updates (e.g. template render) to rescan for bindings.\n        root.addEventListener(AmpEvents.DOM_UPDATE, (e) =>\n          this.onDomUpdate_(e)\n        );\n      })\n      .then(() => {\n        const ampStates = root.querySelectorAll('AMP-STATE');\n        // Force all query-able <amp-state> elements to parse local data instead\n        // of waiting for runtime to build them all.\n        const whenBuilt = false;\n        const whenParsed = toArray(ampStates).map((el) => {\n          return whenUpgradedToCustomElement(el)\n            .then(() => el.getImpl(whenBuilt))\n            .then((impl) => impl.parseAndUpdate());\n        });\n        return Promise.all(whenParsed);\n      })\n      .then(() => {\n        // Bind is \"ready\" when its initialization completes _and_ all <amp-state>\n        // elements' local data is parsed and processed (not remote data).\n        this.viewer_.sendMessage('bindReady', undefined);\n        this.dispatchEventForTesting_(BindEvents.INITIALIZE);\n\n        // In dev mode, check default values against initial expression results.\n        if (getMode().development) {\n          return this.evaluate_().then((results) => this.verify_(results));\n        }\n      });\n  }\n\n  /**\n   * The current number of bindings.\n   * @return {number}\n   * @visibleForTesting\n   */\n  numberOfBindings() {\n    return this.boundElements_.reduce((number, boundElement) => {\n      return number + boundElement.boundProperties.length;\n    }, 0);\n  }\n\n  /**\n   * @param {number} value\n   * @visibleForTesting\n   */\n  setMaxNumberOfBindingsForTesting(value) {\n    this.maxNumberOfBindings_ = value;\n  }\n\n  /** @return {!../../../src/service/history-impl.History} */\n  historyForTesting() {\n    return this.history_;\n  }\n\n  /**\n   * Calls setState(s), where s is data.state with the non-overridable keys\n   * removed.\n   * @param {!JsonObject} data\n   * @return {!Promise}\n   * @private\n   */\n  premutate_(data) {\n    const ignoredKeys = [];\n    return this.initializePromise_.then(() => {\n      Object.keys(data['state']).forEach((key) => {\n        if (!this.overridableKeys_.includes(key)) {\n          delete data['state'][key];\n          ignoredKeys.push(key);\n        }\n      });\n      if (ignoredKeys.length > 0) {\n        user().warn(\n          TAG,\n          'Some state keys could not be premutated ' +\n            'because they are missing the overridable attribute: ' +\n            ignoredKeys.join(', ')\n        );\n      }\n      return this.setState(data['state']);\n    });\n  }\n\n  /**\n   * Marks the given key as overridable so that it can be overriden by\n   * a premutate message from the viewer.\n   * @param {string} key\n   */\n  addOverridableKey(key) {\n    this.overridableKeys_.push(key);\n  }\n\n  /**\n   * Scans the document for <amp-bind-macro> elements, and adds them to the\n   * bind-evaluator.\n   *\n   * Returns a promise that resolves after macros have been added.\n   *\n   * @return {!Promise<number>}\n   * @private\n   */\n  addMacros_() {\n    // TODO(choumx, #17194): One-time query selector can miss dynamically\n    // created elements. Should do what <amp-state> does.\n    const elements = this.ampdoc.getBody().querySelectorAll('AMP-BIND-MACRO');\n    const macros = /** @type {!Array<!BindMacroDef>} */ ([]);\n    iterateCursor(elements, (element) => {\n      const argumentNames = (element.getAttribute('arguments') || '')\n        .split(',')\n        .map((s) => s.trim());\n      macros.push({\n        id: element.getAttribute('id'),\n        argumentNames,\n        expressionString: element.getAttribute('expression'),\n      });\n    });\n    if (macros.length == 0) {\n      return Promise.resolve(0);\n    } else {\n      return this.ww_('bind.addMacros', [macros]).then((errors) => {\n        // Report macros that failed to parse (e.g. expression size exceeded).\n        /** @type {!Array} */ (errors).forEach((e, i) => {\n          this.reportWorkerError_(\n            e,\n            `${TAG}: Parsing amp-bind-macro failed.`,\n            elements[i]\n          );\n        });\n        return macros.length;\n      });\n    }\n  }\n\n  /**\n   * For each node in an array, scans it and its descendants for bindings.\n   * This function is not idempotent.\n   *\n   * Returns a promise that resolves with the number of bindings added upon\n   * completion.\n   *\n   * @param {!Array<!Node>} nodes\n   * @return {!Promise<number>}\n   * @private\n   */\n  addBindingsForNodes_(nodes) {\n    if (!nodes.length) {\n      return Promise.resolve(0);\n    }\n\n    // For each node, scan it for bindings and store them.\n    const scanPromises = nodes.map((node) => {\n      // Limit number of total bindings (unless in local manual testing).\n      const limit =\n        getMode().localDev && !getMode().test\n          ? Number.POSITIVE_INFINITY\n          : this.maxNumberOfBindings_ - this.numberOfBindings();\n\n      return this.scanNode_(node, limit).then((results) => {\n        const {bindings, limitExceeded} = results;\n        if (limitExceeded) {\n          this.emitMaxBindingsExceededError_();\n        }\n        return bindings;\n      });\n    });\n\n    // Once all scans are complete, combine the bindings and ask web-worker to\n    // evaluate expressions in a single RPC.\n    return Promise.all(scanPromises).then((results) => {\n      // `results` is a 2D array where results[i] is an array of bindings.\n      // Flatten this into a 1D array of bindings via concat.\n      const bindings = Array.prototype.concat.apply([], results);\n      return bindings.length > 0 ? this.sendBindingsToWorker_(bindings) : 0;\n    });\n  }\n\n  /** Emits console error stating that the binding limit was exceeded. */\n  emitMaxBindingsExceededError_() {\n    dev().expectedError(\n      TAG,\n      'Maximum number of bindings reached ' +\n        '(%s). Additional elements with bindings will be ignored.',\n      this.maxNumberOfBindings_\n    );\n  }\n\n  /**\n   * Sends new bindings to the web worker for parsing.\n   * @param {!Array<!BindBindingDef>} bindings\n   * @return {!Promise<number>}\n   */\n  sendBindingsToWorker_(bindings) {\n    return this.ww_('bind.addBindings', [bindings]).then((parseErrors) => {\n      // Report each parse error.\n      Object.keys(parseErrors).forEach((expressionString) => {\n        const elements = this.expressionToElements_[expressionString];\n        if (elements.length > 0) {\n          this.reportWorkerError_(\n            parseErrors[expressionString],\n            `${TAG}: Expression compile error in \"${expressionString}\".`,\n            elements[0]\n          );\n        }\n      });\n      return bindings.length;\n    });\n  }\n\n  /**\n   * For each node in an array, removes all bindings for it and its descendants.\n   *\n   * Returns a promise that resolves with the number of removed bindings upon\n   * completion.\n   *\n   * @param {!Array<!Node>} nodes\n   * @return {!Promise<number>}\n   * @private\n   */\n  removeBindingsForNodes_(nodes) {\n    if (!nodes.length) {\n      return Promise.resolve(0);\n    }\n\n    // Eliminate bound elements that are descendants of `nodes`.\n    remove(this.boundElements_, (boundElement) => {\n      for (let i = 0; i < nodes.length; i++) {\n        if (nodes[i].contains(boundElement.element)) {\n          return true;\n        }\n      }\n      return false;\n    });\n    // Eliminate elements from the expression to elements map that\n    // have node as an ancestor. Delete expressions that are no longer\n    // bound to elements.\n    const deletedExpressions = /** @type {!Array<string>} */ ([]);\n    for (const expression in this.expressionToElements_) {\n      const elements = this.expressionToElements_[expression];\n      remove(elements, (element) => {\n        for (let i = 0; i < nodes.length; i++) {\n          if (nodes[i].contains(element)) {\n            return true;\n          }\n        }\n        return false;\n      });\n      if (elements.length == 0) {\n        deletedExpressions.push(expression);\n        delete this.expressionToElements_[expression];\n      }\n    }\n\n    // Remove the bindings from the evaluator.\n    const removed = deletedExpressions.length;\n    if (removed > 0) {\n      return this.ww_('bind.removeBindingsWithExpressionStrings', [\n        deletedExpressions,\n      ]).then(() => removed);\n    } else {\n      return Promise.resolve(0);\n    }\n  }\n\n  /**\n   * Scans `node` for attributes that conform to bind syntax and returns\n   * a tuple containing bound elements and binding data for the evaluator.\n   * @param {!Node} node\n   * @param {number} limit\n   * @return {!Promise<{bindings: !Array<!BindBindingDef>, limitExceeded: boolean}>}\n   * @private\n   */\n  scanNode_(node, limit) {\n    /** @type {!Array<!BindBindingDef>} */\n    const bindings = [];\n    const walker = new BindWalker(node);\n    // Set to true if number of bindings in `node` exceeds `limit`.\n    let limitExceeded = false;\n    // Helper function for scanning the tree walker's next node.\n    // Returns true if the walker has no more nodes.\n    const scanNextNode_ = () => {\n      const node = walker.currentNode;\n      // If `node` is a Document, it will be scanned first (despite\n      // NodeFilter.SHOW_ELEMENT). Skip it.\n      if (node.nodeType !== Node.ELEMENT_NODE) {\n        return !walker.nextNode();\n      }\n      const element = dev().assertElement(node);\n      const remainingQuota = limit - bindings.length;\n      if (this.scanElement_(element, remainingQuota, bindings)) {\n        limitExceeded = true;\n      }\n      // Elements in FAST_RESCAN_TAGS opt-out of \"slow\" tree walking in favor of\n      // rescan() with {fast: true} for better performance. Note that only\n      // children are opted-out (e.g. amp-list children, not amp-list itself).\n      const next = FAST_RESCAN_TAGS.includes(node.nodeName)\n        ? walker.skipSubtree()\n        : walker.nextNode();\n      return !next || limitExceeded;\n    };\n\n    return new Promise((resolve) => {\n      const chunktion = (idleDeadline) => {\n        let completed = false;\n        // If `requestIdleCallback` is available, scan elements until\n        // idle time runs out.\n        if (idleDeadline && !idleDeadline.didTimeout) {\n          while (idleDeadline.timeRemaining() > 1 && !completed) {\n            completed = scanNextNode_();\n          }\n        } else {\n          // If `requestIdleCallback` isn't available, scan elements in buckets.\n          // Bucket size is a magic number that fits within a single frame.\n          const bucketSize = 250;\n          for (let i = 0; i < bucketSize && !completed; i++) {\n            completed = scanNextNode_();\n          }\n        }\n        // If we scanned all elements, resolve. Otherwise, continue chunking.\n        if (completed) {\n          resolve({bindings, limitExceeded});\n        } else {\n          chunk(this.ampdoc, chunktion, ChunkPriority.LOW);\n        }\n      };\n      chunk(this.ampdoc, chunktion, ChunkPriority.LOW);\n    });\n  }\n\n  /**\n   * Scans the element for bindings and adds up to |quota| to `outBindings`.\n   * Also updates ivars `boundElements_` and `expressionToElements_`.\n   * @param {!Element} element\n   * @param {number} quota\n   * @param {!Array<!BindBindingDef>} outBindings\n   * @return {boolean} Returns true if `element` contains more than `quota`\n   *     bindings. Otherwise, returns false.\n   */\n  scanElement_(element, quota, outBindings) {\n    let quotaExceeded = false;\n    const boundProperties = this.boundPropertiesInElement_(element);\n    if (boundProperties.length > quota) {\n      boundProperties.length = quota;\n      quotaExceeded = true;\n    }\n    if (boundProperties.length > 0) {\n      this.boundElements_.push({element, boundProperties});\n    }\n    const {tagName} = element;\n    boundProperties.forEach((boundProperty) => {\n      const {expressionString, property} = boundProperty;\n      outBindings.push({tagName, property, expressionString});\n      if (!this.expressionToElements_[expressionString]) {\n        this.expressionToElements_[expressionString] = [];\n      }\n      this.expressionToElements_[expressionString].push(element);\n    });\n    return quotaExceeded;\n  }\n\n  /**\n   * Returns bound properties for an element.\n   * @param {!Element} element\n   * @return {!Array<{property: string, expressionString: string}>}\n   * @private\n   */\n  boundPropertiesInElement_(element) {\n    const boundProperties = [];\n    const attrs = element.attributes;\n    for (let i = 0, numberOfAttrs = attrs.length; i < numberOfAttrs; i++) {\n      const attr = attrs[i];\n      const boundProperty = this.boundPropertyInAttribute_(attr, element);\n      if (boundProperty) {\n        boundProperties.push(boundProperty);\n      }\n    }\n    return boundProperties;\n  }\n\n  /**\n   * Returns the bound property and expression string within a given attribute,\n   * if it exists. Otherwise, returns null.\n   * @param {!Attr} attribute\n   * @param {!Element} element\n   * @return {?{property: string, expressionString: string}}\n   * @private\n   */\n  boundPropertyInAttribute_(attribute, element) {\n    const tag = element.tagName;\n    const attr = attribute.name;\n\n    let property;\n    if (attr.length > 2 && attr[0] === '[' && attr[attr.length - 1] === ']') {\n      property = attr.substr(1, attr.length - 2);\n    } else if (attr.startsWith('data-amp-bind-')) {\n      property = attr.substr(14);\n      // Ignore `data-amp-bind-foo` if `[foo]` already exists.\n      if (element.hasAttribute(`[${property}]`)) {\n        return null;\n      }\n    }\n\n    if (property) {\n      if (this.validator_.canBind(tag, property)) {\n        return {property, expressionString: attribute.value};\n      } else {\n        const err = user().createError(\n          '%s: Binding to [%s] on <%s> is not allowed.',\n          TAG,\n          property,\n          tag\n        );\n        this.reportError_(err, element);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Evaluates a single expression and returns its result.\n   * @param {string} expression\n   * @param {!JsonObject} scope\n   * @return {!Promise<!JsonObject>}\n   */\n  evaluateExpression_(expression, scope) {\n    return this.initializePromise_\n      .then(() => {\n        // Allow expression to reference current state in addition to event state.\n        Object.assign(scope, this.state_);\n        return this.ww_('bind.evaluateExpression', [expression, scope]);\n      })\n      .then((returnValue) => {\n        const {error, result} = returnValue;\n        if (error) {\n          // Throw to reject promise.\n          throw this.reportWorkerError_(\n            error,\n            `${TAG}: Expression eval failed.`\n          );\n        } else {\n          return result;\n        }\n      });\n  }\n\n  /**\n   * Reevaluates all expressions and returns a map of expressions to results.\n   * @return {!Promise<!Object<string, BindExpressionResultDef>>}\n   * @private\n   */\n  evaluate_() {\n    const evaluatePromise = this.ww_('bind.evaluateBindings', [this.state_]);\n    return evaluatePromise.then((returnValue) => {\n      const {errors, results} = returnValue;\n      // Report evaluation errors.\n      Object.keys(errors).forEach((expressionString) => {\n        const elements = this.expressionToElements_[expressionString];\n        if (elements.length > 0) {\n          const evalError = errors[expressionString];\n          const userError = user().createError(\n            '%s: Expression evaluation error in \"%s\". %s',\n            TAG,\n            expressionString,\n            evalError.message\n          );\n          userError.stack = evalError.stack;\n          this.reportError_(userError, elements[0]);\n        }\n      });\n      dev().info(TAG, 'evaluation:', results);\n      return results;\n    });\n  }\n\n  /**\n   * Verifies expression results vs. current DOM state and returns an\n   * array of bindings with mismatches (if any).\n   * @param {Object<string, BindExpressionResultDef>} results\n   * @param {?Array<!Element>=} elements If provided, only verifies bindings\n   *     contained within the given elements. Otherwise, verifies all bindings.\n   * @param {boolean=} warn If true, emits a user warning for verification\n   *     mismatches. Otherwise, does not emit a warning.\n   * @return {!Array<string>}\n   * @private\n   */\n  verify_(results, elements = null, warn = true) {\n    // Collate strings containing details of verification mismatches to return.\n    const mismatches = {};\n\n    this.boundElements_.forEach((boundElement) => {\n      const {boundProperties, element} = boundElement;\n\n      // If provided, filter elements that are _not_ children of `opt_elements`.\n      if (elements && !this.elementsContains_(elements, element)) {\n        return;\n      }\n\n      boundProperties.forEach((boundProperty) => {\n        const newValue = results[boundProperty.expressionString];\n        if (newValue === undefined) {\n          return;\n        }\n        const mismatch = this.verifyBinding_(boundProperty, element, newValue);\n        if (!mismatch) {\n          return;\n        }\n        const {tagName} = element;\n        const {expressionString, property} = boundProperty;\n        const {actual, expected} = mismatch;\n\n        // Only store unique mismatches (dupes possible when rendering an array\n        // of data to a template).\n        mismatches[`${tagName}[${property}]${expected}:${actual}`] = true;\n\n        if (warn) {\n          user().warn(\n            TAG,\n            `Default value (${actual}) does not match first ` +\n              `result (${expected}) for <${tagName} [${property}]=\"` +\n              `${expressionString}\">. We recommend writing expressions with ` +\n              'matching default values, but this can be safely ignored if ' +\n              'intentional.'\n          );\n        }\n      });\n    });\n    return Object.keys(mismatches);\n  }\n\n  /**\n   * Returns true if `el` is contained within any element in `elements`.\n   * @param {!Array<!Element>} elements\n   * @param {!Element} el\n   * @return {boolean}\n   * @private\n   */\n  elementsContains_(elements, el) {\n    for (let i = 0; i < elements.length; i++) {\n      if (elements[i].contains(el)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Determines which properties to update based on results of evaluation\n   * of all bound expression strings with the current state. This method\n   * will only return properties that need to be updated along with their\n   * new value.\n   * @param {!Array<!BoundPropertyDef>} boundProperties\n   * @param {Object<string, BindExpressionResultDef>} results\n   * @return {!Array<{boundProperty: !BoundPropertyDef, newValue: BindExpressionResultDef}>}\n   * @private\n   */\n  calculateUpdates_(boundProperties, results) {\n    const updates = [];\n    boundProperties.forEach((boundProperty) => {\n      const {expressionString, previousResult} = boundProperty;\n      const newValue = results[expressionString];\n      // Support equality checks for arrays of objects containing arrays.\n      // Useful for rendering amp-list with amp-bind state via [src].\n      if (\n        newValue === undefined ||\n        deepEquals(newValue, previousResult, /* depth */ 20)\n      ) {\n      } else {\n        boundProperty.previousResult = newValue;\n        updates.push({boundProperty, newValue});\n      }\n    });\n    return updates;\n  }\n\n  /**\n   * Applies expression results to elements in the document.\n   *\n   * @param {Object<string, BindExpressionResultDef>} results\n   * @param {!ApplyOptionsDef} opts\n   * @return {!Promise}\n   * @private\n   */\n  apply_(results, opts) {\n    const promises = [];\n\n    this.boundElements_.forEach((boundElement) => {\n      // If this evaluation is triggered by an <amp-state> mutation, we must\n      // ignore updates to any <amp-state> element to prevent update cycles.\n      if (opts.skipAmpState && boundElement.element.tagName === 'AMP-STATE') {\n        return;\n      }\n\n      // If this is a constrained application, then restrict to specified\n      // elements and their subtrees.\n      if (\n        opts.constrain &&\n        !opts.constrain.some((el) => el.contains(boundElement.element))\n      ) {\n        return;\n      }\n\n      const {boundProperties, element} = boundElement;\n      const updates = this.calculateUpdates_(boundProperties, results);\n      // If this is a \"evaluate only\" application, skip the DOM mutations.\n      if (opts.evaluateOnly) {\n        return;\n      }\n      promises.push(this.applyUpdatesToElement_(element, updates));\n    });\n\n    return Promise.all(promises);\n  }\n\n  /**\n   * Applies expression results to a single BoundElementDef.\n   * @param {!Element} element\n   * @param {!Array<{boundProperty: !BoundPropertyDef, newValue: BindExpressionResultDef}>} updates\n   * @return {!Promise}\n   */\n  applyUpdatesToElement_(element, updates) {\n    if (updates.length === 0) {\n      return Promise.resolve();\n    }\n    return this.mutator_.mutateElement(element, () => {\n      const mutations = map();\n      let width, height;\n\n      updates.forEach((update) => {\n        const {boundProperty, newValue} = update;\n        const {property} = boundProperty;\n        const mutation = this.applyBinding_(boundProperty, element, newValue);\n\n        if (mutation) {\n          mutations[mutation.name] = mutation.value;\n          if (property == 'width') {\n            width = isFiniteNumber(newValue) ? Number(newValue) : width;\n          } else if (property == 'height') {\n            height = isFiniteNumber(newValue) ? Number(newValue) : height;\n          }\n        }\n\n        this.dispatchFormValueChangeEventIfNecessary_(element, property);\n      });\n\n      if (width !== undefined || height !== undefined) {\n        // request without scheduling vsync pass since `mutateElement()`\n        // will schedule a pass after a short delay anyways.\n        this.mutator_.forceChangeSize(element, height, width);\n      }\n\n      if (typeof element.mutatedAttributesCallback === 'function') {\n        // Prevent an exception in the callback from interrupting execution,\n        // instead wrap in user error and give a helpful message.\n        try {\n          element.mutatedAttributesCallback(mutations);\n        } catch (e) {\n          const error = user().createError(\n            '%s: Applying expression results (%s) failed with error,',\n            TAG,\n            JSON.stringify(mutations),\n            e\n          );\n          this.reportError_(error, element);\n        }\n      }\n    });\n  }\n\n  /**\n   * Dispatches an `AmpEvents.FORM_VALUE_CHANGE` if the element's changed\n   * property represents the value of a form field.\n   * @param {!Element} element\n   * @param {string} property\n   */\n  dispatchFormValueChangeEventIfNecessary_(element, property) {\n    const isPropertyAFormValue = FORM_VALUE_PROPERTIES[element.tagName];\n    if (!isPropertyAFormValue || !isPropertyAFormValue[property]) {\n      return;\n    }\n\n    // The native `InputEvent` is dispatched at the parent `<select>` when its\n    // selected `<option>` changes.\n    const dispatchAt =\n      element.tagName === 'OPTION'\n        ? closestAncestorElementBySelector(element, 'SELECT')\n        : element;\n\n    if (dispatchAt) {\n      const ampValueChangeEvent = createCustomEvent(\n        this.localWin_,\n        AmpEvents.FORM_VALUE_CHANGE,\n        /* detail */ null,\n        {bubbles: true}\n      );\n      dispatchAt.dispatchEvent(ampValueChangeEvent);\n    }\n  }\n\n  /**\n   * Mutates the bound property of `element` with `newValue`.\n   * @param {!BoundPropertyDef} boundProperty\n   * @param {!Element} element\n   * @param {BindExpressionResultDef} newValue\n   * @return {?{name: string, value:BindExpressionResultDef}}\n   * @private\n   */\n  applyBinding_(boundProperty, element, newValue) {\n    const {property} = boundProperty;\n    const tag = element.tagName;\n\n    switch (property) {\n      case 'defaulttext':\n        element.textContent = String(newValue);\n        break;\n\n      case 'text':\n        const stringValue = String(newValue);\n        // If <title> element in the <head>, also update the document title.\n        if (\n          tag === 'TITLE' &&\n          element.parentNode === this.localWin_.document.head\n        ) {\n          this.localWin_.document.title = stringValue;\n        }\n        // For <textarea>, [text] sets `value` (current value), while\n        // [defaultText] sets `textContent` (initial value).\n        if (tag === 'TEXTAREA') {\n          element.value = stringValue;\n        } else {\n          element.textContent = stringValue;\n        }\n        break;\n\n      case 'class':\n        // Preserve internal AMP classes.\n        const ampClasses = [];\n        for (let i = 0; i < element.classList.length; i++) {\n          const cssClass = element.classList[i];\n          if (AMP_CSS_RE.test(cssClass)) {\n            ampClasses.push(cssClass);\n          }\n        }\n        if (Array.isArray(newValue) || typeof newValue === 'string') {\n          element.setAttribute('class', ampClasses.concat(newValue).join(' '));\n        } else if (newValue === null) {\n          element.setAttribute('class', ampClasses.join(' '));\n        } else {\n          const err = user().createError(\n            '%s: \"%s\" is not a valid result for [class].',\n            TAG,\n            newValue\n          );\n          this.reportError_(err, element);\n        }\n        break;\n\n      default:\n        // For input elements, update both the attribute (initial value) and\n        // property (current value) for bindings e.g. [value].\n        // TODO(choumx): Investigate if splitting into [value] and\n        // [defaultValue] is possible without version bump.\n        const updateProperty = tag === 'INPUT' && property in element;\n        const oldValue = element.getAttribute(property);\n\n        let mutated = false;\n        if (typeof newValue === 'boolean') {\n          if (updateProperty && element[property] !== newValue) {\n            // Property value _must_ be read before the attribute is changed.\n            // Before user interaction, attribute updates affect the property.\n            element[property] = newValue;\n            mutated = true;\n          }\n          if (newValue && oldValue !== '') {\n            element.setAttribute(property, '');\n            mutated = true;\n          } else if (!newValue && oldValue !== null) {\n            element.removeAttribute(property);\n            mutated = true;\n          }\n          if (mutated) {\n            // Safari-specific workaround for updating <select> elements\n            // when a child option[selected] attribute changes.\n            this.updateSelectForSafari_(element, property, newValue);\n          }\n        } else if (typeof newValue === 'object' && newValue !== null) {\n          // If newValue is an object or array (e.g. amp-list[src] binding),\n          // don't bother updating the element since attribute values like\n          // \"[Object object]\" have no meaning in the DOM.\n          mutated = true;\n        } else if (newValue !== oldValue) {\n          mutated = this.rewriteAttributes_(\n            element,\n            property,\n            String(newValue),\n            updateProperty\n          );\n        }\n\n        if (mutated) {\n          return {name: property, value: newValue};\n        }\n        break;\n    }\n    return null;\n  }\n\n  /**\n   * Hopefully we can delete this with Safari 13+.\n   * @param {!Element} element\n   * @param {string} property\n   * @param {BindExpressionResultDef} newValue\n   */\n  updateSelectForSafari_(element, property, newValue) {\n    // We only care about option[selected].\n    if (element.tagName !== 'OPTION' || property !== 'selected') {\n      return;\n    }\n    // We only care if this option was selected, not deselected.\n    if (!newValue) {\n      return;\n    }\n    // Workaround only needed for Safari.\n    if (!Services.platformFor(this.win_).isSafari()) {\n      return;\n    }\n    const select = closestAncestorElementBySelector(element, 'select');\n    if (!select) {\n      return;\n    }\n    // Set corresponding selectedIndex on <select> parent.\n    const index = toArray(select.options).indexOf(element);\n    if (index >= 0) {\n      select.selectedIndex = index;\n    }\n  }\n\n  /**\n   * Performs CDN rewrites for the given mutation and updates the element.\n   * @see amp-cache-modifications.md#url-rewrites\n   * @param {!Element} element\n   * @param {string} attrName\n   * @param {string} value\n   * @param {boolean} updateProperty If the property with the same name should\n   *    be updated as well.\n   * @return {boolean} Whether or not the rewrite was successful.\n   * @private\n   */\n  rewriteAttributes_(element, attrName, value, updateProperty) {\n    // Rewrite attributes if necessary. Not done in worker since it relies on\n    // `url#parseUrl` which uses <a>. Worker has URL API but not on IE11.\n    try {\n      rewriteAttributesForElement(\n        element,\n        attrName,\n        value,\n        /* opt_location */ undefined,\n        updateProperty\n      );\n      return true;\n    } catch (e) {\n      const error = user().createError(\n        '%s: \"%s\" is not a valid result for [%]',\n        TAG,\n        value,\n        attrName,\n        e\n      );\n      this.reportError_(error, element);\n    }\n    return false;\n  }\n\n  /**\n   * If current state of `element` matches `expectedValue`, returns null.\n   * Otherwise, returns a tuple containing the expected and actual values.\n   * @param {!BoundPropertyDef} boundProperty\n   * @param {!Element} element\n   * @param {BindExpressionResultDef} expectedValue\n   * @return {?{expected: *, actual: *}}\n   * @private\n   */\n  verifyBinding_(boundProperty, element, expectedValue) {\n    const {property} = boundProperty;\n    const {tagName} = element;\n\n    // Don't show a warning for bind-only attributes,\n    // like 'slide' on amp-carousel.\n    const bindOnlyAttrs = BIND_ONLY_ATTRIBUTES[tagName];\n    if (bindOnlyAttrs && bindOnlyAttrs.includes(property)) {\n      return null;\n    }\n\n    let initialValue;\n    let match;\n\n    switch (property) {\n      case 'text':\n        initialValue = element.textContent;\n        expectedValue = String(expectedValue);\n        match = initialValue.trim() === expectedValue.trim();\n        break;\n\n      case 'class':\n        initialValue = [];\n        for (let i = 0; i < element.classList.length; i++) {\n          const cssClass = element.classList[i];\n          // Ignore internal AMP classes.\n          if (AMP_CSS_RE.test(cssClass)) {\n            continue;\n          }\n          initialValue.push(cssClass);\n        }\n        /** @type {!Array<string>} */\n        let classes = [];\n        if (Array.isArray(expectedValue)) {\n          classes = expectedValue;\n        } else if (typeof expectedValue === 'string') {\n          const trimmed = expectedValue.trim();\n          if (trimmed.length > 0) {\n            classes = trimmed.split(' ');\n          }\n        } else {\n          const err = user().createError(\n            '%s: \"%s\" is not a valid result for [class].',\n            TAG,\n            expectedValue\n          );\n          this.reportError_(err, element);\n        }\n        match = this.compareStringArrays_(initialValue, classes);\n        break;\n\n      default:\n        initialValue = element.getAttribute(property);\n        // Boolean attributes return values of either '' or null.\n        if (expectedValue === true) {\n          match = initialValue === '';\n        } else if (expectedValue === false) {\n          match = initialValue === null;\n        } else if (typeof expectedValue === 'number') {\n          match = Number(initialValue) === expectedValue;\n        } else {\n          match = initialValue === expectedValue;\n        }\n        break;\n    }\n\n    return match ? null : {expected: expectedValue, actual: initialValue};\n  }\n\n  /**\n   * @param {!Event} event\n   */\n  onDomUpdate_(event) {\n    const target = dev().assertElement(event.target);\n    // TODO(choumx): Consider removing this check now that slowScan_() skips\n    // FAST_RESCAN_TAGS internally, and because this makes an assumption about\n    // the DOM structure of the EventTarget.\n    const parent = target.parentNode;\n    if (parent && FAST_RESCAN_TAGS.includes(parent.nodeName)) {\n      return;\n    }\n    dev().info(TAG, 'dom_update:', target);\n    this.slowScan_([target], [target], 'dom_update.end').then(() => {\n      this.dispatchEventForTesting_(BindEvents.RESCAN_TEMPLATE);\n    });\n  }\n\n  /**\n   * Removes bindings for nodes in `remove`, then scans for bindings in `add`.\n   * Return promise that resolves upon completion with struct containing number\n   * of removed and added bindings.\n   * @param {!Array<!Node>} addedNodes\n   * @param {!Array<!Node>} removedNodes\n   * @param {string=} label\n   * @return {!Promise}\n   * @private\n   */\n  slowScan_(addedNodes, removedNodes, label = 'rescan.slow') {\n    let removed = 0;\n    return this.removeBindingsForNodes_(removedNodes)\n      .then((r) => {\n        removed = r;\n        return this.addBindingsForNodes_(addedNodes);\n      })\n      .then((added) => {\n        dev().info(\n          TAG,\n          '%s: delta=%s, total=%s',\n          label,\n          added - removed,\n          this.numberOfBindings()\n        );\n      });\n  }\n\n  /**\n   * Helper for invoking a method on web worker.\n   * @param {string} method\n   * @param {!Array=} opt_args\n   * @return {!Promise}\n   */\n  ww_(method, opt_args) {\n    return invokeWebWorker(this.win_, method, opt_args, this.localWin_);\n  }\n\n  /**\n   * @param {{message: string, stack:string}} e\n   * @param {string} message\n   * @param {!Element=} opt_element\n   * @return {!Error}\n   * @private\n   */\n  reportWorkerError_(e, message, opt_element) {\n    const userError = user().createError('%s %s', message, e.message);\n    userError.stack = e.stack;\n    this.reportError_(userError, opt_element);\n    return userError;\n  }\n\n  /**\n   * @param {!Error} error\n   * @param {!Element=} opt_element\n   */\n  reportError_(error, opt_element) {\n    if (getMode().test) {\n      return;\n    }\n    reportError(error, opt_element);\n  }\n\n  /**\n   * Returns true if both arrays contain the same strings.\n   * @param {!(IArrayLike<string>|Array<string>)} a\n   * @param {!(IArrayLike<string>|Array<string>)} b\n   * @return {boolean}\n   * @private\n   */\n  compareStringArrays_(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    const sortedA = (isArray(a) ? a : toArray(a)).sort();\n    const sortedB = (isArray(b) ? b : toArray(b)).sort();\n    for (let i = 0; i < a.length; i++) {\n      if (sortedA[i] !== sortedB[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Copies an object containing JSON data and returns it.\n   * Returns null if input object contains invalid JSON (e.g. undefined or\n   * circular references).\n   * @param {?JsonObject|undefined} o\n   * @return {?JsonObject}\n   */\n  copyJsonObject_(o) {\n    if (o === undefined) {\n      return null;\n    }\n    try {\n      return parseJson(JSON.stringify(o));\n    } catch (e) {\n      dev().error(TAG, 'Failed to copy JSON (' + o + ') with error: ' + e);\n    }\n    return null;\n  }\n\n  /**\n   * Print out the current state in the console.\n   * @param {(!Element|string)=} opt_elementOrExpr\n   * @private\n   */\n  debugPrintState_(opt_elementOrExpr) {\n    if (opt_elementOrExpr) {\n      if (typeof opt_elementOrExpr == 'string') {\n        const value = getValueForExpr(this.state_, opt_elementOrExpr);\n        user().info(TAG, value);\n      } else if (opt_elementOrExpr.nodeType == Node.ELEMENT_NODE) {\n        const element = user().assertElement(opt_elementOrExpr);\n        this.debugPrintElement_(element);\n      } else {\n        user().info(\n          TAG,\n          'Invalid argument. Pass a JSON expression or an ' +\n            'element instead e.g. AMP.printState(\"foo.bar\") or ' +\n            'AMP.printState($0) after selecting an element.'\n        );\n      }\n    } else {\n      user().info(TAG, this.state_);\n    }\n  }\n\n  /**\n   * Print out the element's bound attributes and respective expression values.\n   * @param {!Element} element\n   * @private\n   */\n  debugPrintElement_(element) {\n    const index = findIndex(this.boundElements_, (boundElement) => {\n      return boundElement.element == element;\n    });\n    if (index < 0) {\n      user().info(TAG, 'Element has no bindings:', element);\n      return;\n    }\n    // Evaluate expressions in bindings in `element`.\n    const promises = [];\n    const {boundProperties} = this.boundElements_[index];\n    boundProperties.forEach((boundProperty) => {\n      const {expressionString} = boundProperty;\n      promises.push(this.evaluateExpression_(expressionString, this.state_));\n    });\n    // Print the map of attribute to expression value for `element`.\n    Promise.all(promises).then((results) => {\n      const output = map();\n      boundProperties.forEach((boundProperty, i) => {\n        const {property} = boundProperty;\n        output[property] = results[i];\n      });\n      user().info(TAG, output);\n    });\n  }\n\n  /**\n   * @param {string} expression\n   */\n  debugEvaluate_(expression) {\n    this.evaluateExpression_(expression, this.state_).then((result) => {\n      user().info(TAG, result);\n    });\n  }\n\n  /**\n   * Wait for bind scan to finish for testing.\n   *\n   * @return {?Promise}\n   * @visibleForTesting\n   */\n  initializePromiseForTesting() {\n    return this.initializePromise_;\n  }\n\n  /**\n   * Wait for bindings to evaluate and apply for testing. Should\n   * be called once for each event that changes bindings.\n   *\n   * @return {?Promise}\n   * @visibleForTesting\n   */\n  setStatePromiseForTesting() {\n    return this.setStatePromise_;\n  }\n\n  /**\n   * @param {string} name\n   * @private\n   */\n  dispatchEventForTesting_(name) {\n    if (getMode().test) {\n      let event;\n      if (typeof this.localWin_.Event === 'function') {\n        event = new Event(name, {bubbles: true, cancelable: true});\n      } else {\n        event = this.localWin_.document.createEvent('Event');\n        event.initEvent(name, /* bubbles */ true, /* cancelable */ true);\n      }\n      this.localWin_.dispatchEvent(event);\n    }\n  }\n}\n\nclass BindWalker {\n  /**\n   * @param {!Node} root\n   */\n  constructor(root) {\n    const doc = devAssert(\n      root.nodeType == Node.DOCUMENT_NODE ? root : root.ownerDocument,\n      'ownerDocument is null.'\n    );\n\n    const useQuerySelector =\n      doc.documentElement.hasAttribute('i-amphtml-binding');\n    /** @private @const {boolean} */\n    this.useQuerySelector_ = useQuerySelector;\n\n    /** @type {!Node} */\n    this.currentNode = root;\n\n    /** @private {number} */\n    this.index_ = 0;\n\n    /** @private @const {!Array<!Element>} */\n    this.nodeList_ = useQuerySelector\n      ? toArray(root.querySelectorAll('[i-amphtml-binding]'))\n      : [];\n\n    // Confusingly, the old TreeWalker hit the root node. We need to match that behavior.\n    if (\n      useQuerySelector &&\n      root.nodeType === Node.ELEMENT_NODE &&\n      root.hasAttribute('i-amphtml-binding')\n    ) {\n      this.nodeList_.unshift(root);\n    }\n\n    /**\n     * Third and fourth params of `createTreeWalker` are not optional on IE11.\n     * @private @const {?TreeWalker}\n     */\n    this.treeWalker_ = useQuerySelector\n      ? null\n      : doc.createTreeWalker(\n          root,\n          NodeFilter.SHOW_ELEMENT,\n          null,\n          /* entityReferenceExpansion */ false\n        );\n  }\n\n  /**\n   * Finds the next node in document order, if it exists. Returns that node, or null if it doesn't exist.\n   * Updates currentNode, if it exists, else currentNode stays the same.\n   *\n   * @return {?Node}\n   */\n  nextNode() {\n    if (this.useQuerySelector_) {\n      if (this.index_ == this.nodeList_.length) {\n        return null;\n      }\n      const next = this.nodeList_[this.index_++];\n      this.currentNode = next;\n      return next;\n    }\n\n    const walker = this.treeWalker_;\n    const next = walker.nextNode();\n    // This matches the TreeWalker's behavior.\n    if (next !== null) {\n      this.currentNode = next;\n    }\n    return next;\n  }\n\n  /**\n   * Skips the remaining sibling nodes in the current parent. Returns the next node in document order.\n   * @return {?Node}\n   */\n  skipSubtree() {\n    if (this.useQuerySelector_) {\n      const {currentNode} = this;\n      let next = null;\n      do {\n        next = this.nextNode();\n      } while (next !== null && currentNode.contains(next));\n      return next;\n    }\n\n    const walker = this.treeWalker_;\n    for (let n = walker.currentNode; n; n = walker.parentNode()) {\n      const sibling = walker.nextSibling();\n      if (sibling !== null) {\n        this.currentNode = sibling;\n        return sibling;\n      }\n    }\n    return null;\n  }\n}\n", "import {AmpBindMacro} from './amp-bind-macro';\nimport {AmpState} from './amp-state';\nimport {Bind} from './bind-impl';\n\n/** @const {string} */\nconst TAG = 'amp-bind';\n\nAMP.extension(TAG, '0.1', function (AMP) {\n  AMP.registerServiceForDoc('bind', Bind);\n  AMP.registerElement('amp-state', AmpState);\n  AMP.registerElement('amp-bind-macro', AmpBindMacro);\n});\n"],
  "mappings": "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",
  "names": []
}
