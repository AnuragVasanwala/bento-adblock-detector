{
  "version": 3,
  "sources": ["../../src/core/data-structures/promise.js", "../../src/core/mode/prod.js", "../../src/core/mode/test.js", "../../src/core/mode/local-dev.js", "../../src/core/mode/minified.js", "../../src/core/mode/version.js", "../../src/core/mode/esm.js", "../../src/core/types/array.js", "../../src/core/types/object/index.js", "../../src/core/types/index.js", "../../src/core/error/message-helpers.js", "../../src/core/assert/base.js", "../../src/core/assert/dev.js", "../../src/core/constants/action-constants.js", "../../src/core/constants/amp-events.js", "../../src/core/constants/async-input.js", "../../src/core/constants/key-codes.js", "../../src/core/document/format.js", "../../src/core/types/object/json.js", "../../src/core/window/index.js", "../../third_party/css-escape/css-escape.js", "../../src/core/dom/css-selectors.js", "../../src/core/dom/query.js", "../../src/core/dom/index.js", "../../src/core/dom/form.js", "../../src/core/types/string/url.js", "../../src/config.js", "../../src/mode.js", "../../src/service/extension-script.js", "../../src/core/types/function/index.js", "../../src/utils/log.js", "../../src/service-helpers.js", "../../src/element-service.js", "../../src/service/index.js", "../../src/utils/analytics.js", "../../src/core/dom/event-helper-listen.js", "../../src/utils/event-helper.js", "../../src/form-data-wrapper.js", "../../src/core/data-structures/lru-cache.js", "../../src/url.js", "../../src/utils/xhr-utils.js", "../../src/core/dom/style.js", "../../extensions/amp-form/0.1/amp-form-textarea.js", "../../extensions/amp-form/0.1/form-dirtiness.js", "../../extensions/amp-form/0.1/form-events.js", "../../extensions/amp-form/0.1/form-proxy.js", "../../src/core/data-structures/observable.js", "../../extensions/amp-form/0.1/form-submit-service.js", "../../extensions/amp-form/0.1/validation-bubble.js", "../../extensions/amp-form/0.1/form-validators.js", "../../extensions/amp-form/0.1/form-verifiers.js", "../../build/amp-form-0.1.css.js", "../../src/ssr-template-helper.js", "../../src/style-installer.js", "../../extensions/amp-form/0.1/amp-form.js"],
  "sourcesContent": ["let resolved;\n\n/**\n * Returns a cached resolved promise.\n * Babel converts direct calls to Promise.resolve() (with no arguments) into\n * calls to this.\n *\n * @return {!Promise<undefined>}\n */\nexport function resolvedPromise() {\n  if (resolved) {\n    return resolved;\n  }\n\n  // It's important that we call with `undefined` here, to prevent a transform\n  // recursion. If we didn't pass an arg, then the transformer would replace\n  // this callsite with a call to `resolvedPromise()`.\n  resolved = Promise.resolve(undefined);\n  return resolved;\n}\n\n/**\n * Returns a Deferred struct, which holds a pending promise and its associated\n * resolve and reject functions.\n *\n * This is preferred instead of creating a Promise instance to extract the\n * resolve/reject functions yourself:\n *\n * ```\n * // Avoid doing\n * let resolve;\n * const promise = new Promise(res => {\n *   resolve = res;\n * });\n *\n * // Good\n * const deferred = new Deferred();\n * const { promise, resolve } = deferred;\n * ```\n *\n * @template T\n */\nexport class Deferred {\n  /** Constructor. */\n  constructor() {\n    /** @const {!Promise<T>} */\n    this.promise = new /*OK*/ Promise((res, rej) => {\n      /** @const {function(T=)} */\n      this.resolve = res;\n      /** @const {function(*=)} */\n      this.reject = rej;\n    });\n  }\n}\n\n/**\n * Creates a promise resolved to the return value of fn.\n * If fn sync throws, it will cause the promise to reject.\n *\n * @param {function():T} fn\n * @return {!Promise<T>}\n * @template T\n */\nexport function tryResolve(fn) {\n  return new Promise((resolve) => {\n    resolve(fn());\n  });\n}\n\n/**\n * Resolves with the result of the last promise added.\n * @implements {IThenable}\n */\nexport class LastAddedResolver {\n  /**\n   * @param {!Array<!IThenable>=} opt_promises\n   */\n  constructor(opt_promises) {\n    /** @private @const {!Deferred} */\n    this.deferred_ = new Deferred();\n\n    /** @private */\n    this.count_ = 0;\n\n    if (opt_promises) {\n      for (const promise of opt_promises) {\n        this.add(promise);\n      }\n    }\n  }\n\n  /**\n   * Add a promise to possibly be resolved.\n   * @param {!IThenable} promise\n   * @return {!Promise}\n   */\n  add(promise) {\n    const countAtAdd = ++this.count_;\n    promise.then(\n      (result) => {\n        if (this.count_ === countAtAdd) {\n          this.deferred_.resolve(result);\n        }\n      },\n      (error) => {\n        // Don't follow behavior of Promise.all and Promise.race error so that\n        // this will only reject when most recently added promise fails.\n        if (this.count_ === countAtAdd) {\n          this.deferred_.reject(error);\n        }\n      }\n    );\n    return this.deferred_.promise;\n  }\n\n  /** @override */\n  then(opt_resolve, opt_reject) {\n    return this.deferred_.promise.then(opt_resolve, opt_reject);\n  }\n}\n", "/**\n * Returns true when the build is meant for distribution.\n * This means `amp dist` was called _without_ the --fortesting flag.\n *\n * This is a magic constant replaced by babel.\n *\n * Calls are DCE'd when compiled.\n * @return {boolean}\n */\nexport function isProd() {\n  return IS_PROD;\n}\n", "import {isProd} from './prod';\n\n/**\n * Returns true if executing in a testing environment. Calls may be DCE'd when\n * compiled based on isForDistribution.\n * @param {!Window=} opt_win\n * @return {boolean}\n */\nexport function isTest(opt_win) {\n  if (isProd()) {\n    return false;\n  }\n  const win = opt_win || self;\n  return !!(win.AMP_CONFIG?.test || win.__AMP_TEST || win['__karma__']);\n}\n", "import {isProd} from './prod';\nimport {isTest} from './test';\n\n/**\n * Returns true if executing in a local development or testing environment.\n * Calls may be DCE'd when compiled based on isForDistribution and isTest.\n *\n * @param {!Window=} opt_win\n * @return {boolean}\n */\nexport function isLocalDev(opt_win) {\n  if (isProd()) {\n    return false;\n  }\n\n  return !!self.AMP_CONFIG?.localDev || isTest(opt_win);\n}\n", "/**\n * Returns true whenever closure compiler is used.\n * This is a magic constant that is replaced by babel.\n *\n * @return {boolean}\n */\nexport function isMinified() {\n  return IS_MINIFIED;\n}\n", "/**\n * Returns the internal AMP runtime version. Note that this is not the RTV,\n * which is a prefix and the runtime version.\n *\n * The call sites for this function are replaced with a compile time constant\n * string.\n *\n * @return {string}\n */\nexport function version() {\n  return INTERNAL_RUNTIME_VERSION;\n}\n", "/**\n * Copyright 2021 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {isProd} from './prod';\n\n/**\n * Returns true when compiling an esm binary.\n * This is a magic constant that is replaced by babel.\n *\n * @return {boolean}\n */\nexport function isEsm() {\n  if (isProd()) {\n    return IS_ESM;\n  }\n\n  return self?.__AMP_MODE?.esm ?? IS_ESM;\n}\n", "/**\n * Converts an array-like object to an array.\n * @param {?IArrayLike<T>|string} arrayLike\n * @return {!Array<T>}\n * @template T\n */\nexport function toArray(arrayLike) {\n  return arrayLike ? Array.prototype.slice.call(arrayLike) : [];\n}\n\n/**\n * Determines if value is actually an Array.\n * @param {*} value\n * @return {boolean}\n */\nexport const {isArray} = Array;\n\n/**\n * If the specified argument is an array, it's returned as is. If it's a\n * single item, the array containing this item is created and returned.\n *\n * The double-template pattern here solves a bug where CC can be passed a value\n * with declared type {string|!Array<string>} and return a value with a type of\n * {!Array<string|Array<string>>}.\n *\n * @param {!Array<T>|S} arrayOrSingleItem\n * @return {!Array<T>|!Array<S>}\n * @template S\n * @template T\n */\nexport function arrayOrSingleItemToArray(arrayOrSingleItem) {\n  return isArray(arrayOrSingleItem)\n    ? /** @type {!Array<T>} */ (arrayOrSingleItem)\n    : [/** @type {!S} */ (arrayOrSingleItem)];\n}\n\n/**\n * Compares if two arrays contains exactly same elements of same number\n * of same order. Note that it does NOT handle NaN case as expected.\n *\n * @param {!Array<T>} arr1\n * @param {!Array<T>} arr2\n * @return {boolean}\n * @template T\n */\nexport function areEqualOrdered(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Removes elements that shouldRemove returns true for from the array.\n *\n * @param {!Array<T>} array\n * @param {function(T, number, !Array<T>):boolean} shouldRemove\n * @return {!Array<T>}\n * @template T\n */\nexport function remove(array, shouldRemove) {\n  const removed = [];\n  let index = 0;\n  for (let i = 0; i < array.length; i++) {\n    const item = array[i];\n    if (shouldRemove(item, i, array)) {\n      removed.push(item);\n    } else {\n      if (index < i) {\n        array[index] = item;\n      }\n      index++;\n    }\n  }\n  if (index < array.length) {\n    array.length = index;\n  }\n  return removed;\n}\n\n/**\n * Returns the index of the first element matching the predicate.\n * Like Array#findIndex.\n *\n * @param {!Array<T>} array\n * @param {function(T, number, !Array<T>):boolean} predicate\n * @return {number}\n * @template T\n */\nexport function findIndex(array, predicate) {\n  for (let i = 0; i < array.length; i++) {\n    if (predicate(array[i], i, array)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Converts the given iterator to an array.\n *\n * @param {!Iterator<T>} iterator\n * @return {Array<T>}\n * @template T\n */\nexport function fromIterator(iterator) {\n  const array = [];\n  for (let e = iterator.next(); !e.done; e = iterator.next()) {\n    array.push(e.value);\n  }\n  return array;\n}\n\n/**\n * Adds item to array if it is not already present.\n *\n * @param {Array<T>} array\n * @param {T} item\n * @return {boolean}\n * @template T\n */\nexport function pushIfNotExist(array, item) {\n  if (array.indexOf(item) < 0) {\n    array.push(item);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes the first matching item in the array. Returns `true` if the array\n * has changed.\n *\n * @param {!Array<T>} array\n * @param {T} item\n * @return {boolean}\n * @template T\n */\nexport function removeItem(array, item) {\n  const index = array.indexOf(item);\n  if (index == -1) {\n    return false;\n  }\n  array.splice(index, 1);\n  return true;\n}\n\n/**\n * Returns the last item in an array.\n *\n * @param {Array<T>} array\n * @template T\n * @return {?T}\n */\nexport function lastItem(array) {\n  return array[array.length - 1];\n}\n", "/* @const */\nconst {hasOwnProperty: hasOwn_, toString: toString_} = Object.prototype;\n\n/**\n * Determines if value is actually an Object.\n * @param {*} value\n * @return {boolean}\n */\nexport function isObject(value) {\n  return toString_.call(value) === '[object Object]';\n}\n\n/**\n * Returns a map-like object.\n * If opt_initial is provided, copies its own properties into the\n * newly created object.\n * @param {T=} opt_initial This should typically be an object literal.\n * @return {T}\n * @template T\n */\nexport function map(opt_initial) {\n  const obj = Object.create(null);\n  if (opt_initial) {\n    Object.assign(obj, opt_initial);\n  }\n  return obj;\n}\n\n/**\n * Return an empty JsonObject or makes the passed in object literal\n * an JsonObject.\n * The JsonObject type is just a simple object that is at-dict.\n * See\n * https://github.com/google/closure-compiler/wiki/@struct-and-@dict-Annotations\n * for what a dict is type-wise.\n * The linter enforces that the argument is, in fact, at-dict like.\n * @param {!Object=} opt_initial\n * @return {!JsonObject}\n */\nexport function dict(opt_initial) {\n  // We do not copy. The linter enforces that the passed in object is a literal\n  // and thus the caller cannot have a reference to it.\n  return /** @type {!JsonObject} */ (opt_initial || {});\n}\n\n/**\n * Checks if the given key is a property in the map.\n *\n * @param {T}  obj a map like property.\n * @param {string}  key\n * @return {boolean}\n * @template T\n */\nexport function hasOwn(obj, key) {\n  return hasOwn_.call(obj, key);\n}\n\n/**\n * Returns obj[key] iff key is obj's own property (is not inherited).\n * Otherwise, returns undefined.\n *\n * @param {Object} obj\n * @param {string} key\n * @return {*}\n */\nexport function ownProperty(obj, key) {\n  if (hasOwn(obj, key)) {\n    return obj[key];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Deep merges source into target.\n *\n * @param {!Object} target\n * @param {!Object} source\n * @param {number} depth The maximum merge depth. If exceeded, Object.assign\n *                       will be used instead.\n * @return {!Object}\n * @throws {Error} If source contains a circular reference.\n * Note: Only nested objects are deep-merged, primitives and arrays are not.\n */\nexport function deepMerge(target, source, depth = 10) {\n  // Keep track of seen objects to detect recursive references.\n  const seen = [];\n\n  /** @type {!Array<{t: !Object, s: !Object, d: number}>} */\n  const queue = [];\n  queue.push({t: target, s: source, d: 0});\n\n  // BFS to ensure objects don't have recursive references at shallower depths.\n  while (queue.length > 0) {\n    const {d, s, t} = queue.shift();\n    if (seen.includes(s)) {\n      throw new Error('Source object has a circular reference.');\n    }\n    seen.push(s);\n    if (t === s) {\n      continue;\n    }\n    if (d > depth) {\n      Object.assign(t, s);\n      continue;\n    }\n    for (const key of Object.keys(s)) {\n      const newValue = s[key];\n      // Perform a deep merge IFF both target and source have the same key\n      // whose corresponding values are objects.\n      if (hasOwn(t, key)) {\n        const oldValue = t[key];\n        if (isObject(newValue) && isObject(oldValue)) {\n          queue.push({t: oldValue, s: newValue, d: d + 1});\n          continue;\n        }\n      }\n      t[key] = newValue;\n    }\n  }\n  return target;\n}\n\n/**\n * @param {!Object} o An object to remove properties from\n * @param {!Array<string>} props A list of properties to remove from the Object\n * @return {!Object} An object with the given properties removed\n */\nexport function omit(o, props) {\n  return Object.keys(o).reduce((acc, key) => {\n    if (!props.includes(key)) {\n      acc[key] = o[key];\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * @param {!Object|null|undefined} o1\n * @param {!Object|null|undefined} o2\n * @return {boolean}\n */\nexport function objectsEqualShallow(o1, o2) {\n  if (o1 == null || o2 == null) {\n    // Null is only equal to null, and undefined to undefined.\n    return o1 === o2;\n  }\n\n  for (const k in o1) {\n    if (o1[k] !== o2[k]) {\n      return false;\n    }\n  }\n  for (const k in o2) {\n    if (o2[k] !== o1[k]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @param {T} obj\n * @param {string} prop\n * @param {function(T, string):R} factory\n * @return {R}\n * @template T,R\n */\nexport function memo(obj, prop, factory) {\n  let result = /** @type {?R} */ (obj[prop]);\n  if (result === undefined) {\n    result = factory(obj, prop);\n    obj[prop] = result;\n  }\n  return result;\n}\n\n/**\n * Recreates objects with prototype-less copies.\n * @param {!JsonObject} obj\n * @return {!JsonObject}\n */\nexport function recreateNonProtoObject(obj) {\n  const copy = map();\n  for (const k in obj) {\n    if (!hasOwn(obj, k)) {\n      continue;\n    }\n    const v = obj[k];\n    copy[k] = isObject(v) ? recreateNonProtoObject(v) : v;\n  }\n  return /** @type {!JsonObject} */ (copy);\n}\n\n/**\n * Returns a value from an object for a field-based expression. The expression\n * is a simple nested dot-notation of fields, such as `field1.field2`. If any\n * field in a chain does not exist or is not an object or array, the returned\n * value will be `undefined`.\n *\n * @param {!JsonObject} obj\n * @param {string} expr\n * @return {*}\n */\nexport function getValueForExpr(obj, expr) {\n  // The `.` indicates \"the object itself\".\n  if (expr == '.') {\n    return obj;\n  }\n  // Otherwise, navigate via properties.\n  const parts = expr.split('.');\n  let value = obj;\n  for (const part of parts) {\n    if (\n      part &&\n      value &&\n      value[part] !== undefined &&\n      typeof value == 'object' &&\n      hasOwn(value, part)\n    ) {\n      value = value[part];\n      continue;\n    }\n    value = undefined;\n    break;\n  }\n  return value;\n}\n", "// Export all type-checking helpers for convenience\nexport {isArray} from './array';\nexport {isEnumValue} from './enum';\nexport {isString} from './string';\nexport {isObject} from './object';\n\n/**\n * Determines if value is an ELement\n * @param {*} value\n * @return {boolean}\n */\nexport function isElement(value) {\n  return value?.nodeType == /* Node.ELEMENT_NODE */ 1;\n}\n\n/**\n * Determines if value is of number type and finite.\n * NaN and Infinity are not considered a finite number.\n * String numbers are not considered numbers.\n * @param {*} value\n * @return {boolean}\n */\nexport function isFiniteNumber(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n", "import {isElement} from '#core/types';\n\n/**\n * Triple zero width space.\n *\n * This is added to user error messages, so that we can later identify\n * them, when the only thing that we have is the message. This is the\n * case in many browsers when the global exception handler is invoked.\n *\n * @const {string}\n */\nexport const USER_ERROR_SENTINEL = '\\u200B\\u200B\\u200B';\n/**\n * Four zero width space.\n *\n * @const {string}\n */\nexport const USER_ERROR_EMBED_SENTINEL = '\\u200B\\u200B\\u200B\\u200B';\n\n/**\n * Converts an element to a readable string; all other types are unchanged.\n * TODO(rcebulko): Unify with log.js\n * @param {*} val\n * @return {*}\n */\nexport function elementStringOrPassThru(val) {\n  // Do check equivalent to `val instanceof Element` without cross-window bug\n  if (isElement(val)) {\n    val = /** @type {Element} */ (val);\n    return val.tagName.toLowerCase() + (val.id ? `#${val.id}` : '');\n  }\n  return val;\n}\n\n/**\n * Tests if an error message contains the user sentinel.\n * @param {string} message\n * @return {boolean} Whether this message was a user error.\n */\nexport function isUserErrorMessage(message) {\n  return message.indexOf(USER_ERROR_SENTINEL) >= 0;\n}\n\n/**\n * @param {string} message\n * @return {boolean} Whether this message was a a user error from an iframe embed.\n */\nexport function isUserErrorEmbedMessage(message) {\n  return message.indexOf(USER_ERROR_EMBED_SENTINEL) >= 0;\n}\n\n/**\n * Strips the user error sentinel from an error message.\n * @param {string} message\n * @return {string} The new message without USER_ERROR_SENTINEL\n */\nexport function stripUserError(message) {\n  return message.replace(USER_ERROR_SENTINEL, '');\n}\n", "import {elementStringOrPassThru} from '#core/error/message-helpers';\nimport {isArray, isElement, isString} from '#core/types';\nimport {remove} from '#core/types/array';\n\n/**\n * @fileoverview This file provides the base implementation for assertion\n * functions. Most files should never import from this; instead, import from\n * `dev` or `user`. It is also used by the Log class for its assertions.\n */\n\n/**\n * A base assertion function, provided to various assertion helpers.\n * @typedef {function(?, string=, ...*):?|function(?, !Array<*>)}\n */\nexport let AssertionFunctionDef;\n\n/**\n * Throws an error if the second argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n * @param {?string} sentinel\n * @param {T} shouldBeTruthy\n * @param {string} opt_message\n * @param {...*} var_args Arguments substituted into %s in the message\n * @return {T}\n * @template T\n * @throws {Error} when shouldBeTruthy is not truthy.\n */\nexport function assert(\n  sentinel,\n  shouldBeTruthy,\n  opt_message = 'Assertion failed',\n  var_args\n) {\n  if (shouldBeTruthy) {\n    return shouldBeTruthy;\n  }\n\n  // Include the sentinel string if provided and not already present\n  if (sentinel && opt_message.indexOf(sentinel) == -1) {\n    opt_message += sentinel;\n  }\n\n  // Skip the first 3 arguments to isolate format params\n  // const messageArgs = Array.prototype.slice.call(arguments, 3);\n  // Index at which message args start\n  let i = 3;\n\n  // Substitute provided values into format string in message\n  const splitMessage = opt_message.split('%s');\n  let message = splitMessage.shift();\n  const messageArray = [message];\n\n  while (splitMessage.length) {\n    const subValue = arguments[i++];\n    const nextConstant = splitMessage.shift();\n\n    message += elementStringOrPassThru(subValue) + nextConstant;\n    messageArray.push(subValue, nextConstant.trim());\n  }\n\n  const error = new Error(message);\n  error.messageArray = remove(messageArray, (x) => x !== '');\n  // __AMP_REPORT_ERROR is installed globally per window in the entry point in\n  // AMP documents. It may not be present for Bento/Preact elements on non-AMP\n  // pages.\n  self.__AMP_REPORT_ERROR?.(error);\n  throw error;\n}\n\n/**\n * Asserts types, backbone of `assertNumber`, `assertString`, etc.\n *\n * It understands array-based \"id\"-contracted messages.\n *\n * Otherwise creates a sprintf syntax string containing the optional message or the\n * default. The `subject` of the assertion is added at the end.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {T} subject\n * @param {*} shouldBeTruthy\n * @param {string} defaultMessage\n * @param {!Array<*>|string=} opt_message\n * @return {T}\n * @template T\n * @private\n */\nfunction assertType_(\n  assertFn,\n  subject,\n  shouldBeTruthy,\n  defaultMessage,\n  opt_message\n) {\n  if (isArray(opt_message)) {\n    assertFn(\n      shouldBeTruthy,\n      /** @type {!Array} */ (opt_message).concat([subject])\n    );\n  } else {\n    assertFn(shouldBeTruthy, `${opt_message || defaultMessage}: %s`, subject);\n  }\n\n  return subject;\n}\n\n/**\n * Throws an error if the first argument isn't an Element.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeElement\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Element} The value of shouldBeTrueish.\n * @throws {Error} when shouldBeElement is not an Element\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertElement(assertFn, shouldBeElement, opt_message) {\n  return /** @type {!Element} */ (\n    assertType_(\n      assertFn,\n      shouldBeElement,\n      isElement(shouldBeElement),\n      'Element expected',\n      opt_message\n    )\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a string. The string can\n * be empty.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeString\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {string} The string value. Can be an empty string.\n * @throws {Error} when shouldBeString is not an String\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertString(assertFn, shouldBeString, opt_message) {\n  return /** @type {string} */ (\n    assertType_(\n      assertFn,\n      shouldBeString,\n      isString(shouldBeString),\n      'String expected',\n      opt_message\n    )\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a number. The allowed values\n * include `0` and `NaN`.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeNumber\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {number} The number value. The allowed values include `0`\n *   and `NaN`.\n * @throws {Error} when shouldBeNumber is not an Number\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertNumber(assertFn, shouldBeNumber, opt_message) {\n  return /** @type {number} */ (\n    assertType_(\n      assertFn,\n      shouldBeNumber,\n      typeof shouldBeNumber == 'number',\n      'Number expected',\n      opt_message\n    )\n  );\n}\n\n/**\n * Throws an error if the first argument is not an array.\n * The array can be empty.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeArray\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Array} The array value\n * @throws {Error} when shouldBeArray is not an Array\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertArray(assertFn, shouldBeArray, opt_message) {\n  return /** @type {!Array} */ (\n    assertType_(\n      assertFn,\n      shouldBeArray,\n      isArray(shouldBeArray),\n      'Array expected',\n      opt_message\n    )\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a boolean.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeBoolean\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {boolean} The boolean value.\n * @throws {Error} when shouldBeBoolean is not an Boolean\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertBoolean(assertFn, shouldBeBoolean, opt_message) {\n  return /** @type {boolean} */ (\n    assertType_(\n      assertFn,\n      shouldBeBoolean,\n      !!shouldBeBoolean === shouldBeBoolean,\n      'Boolean expected',\n      opt_message\n    )\n  );\n}\n", "import * as mode from '#core/mode';\n\nimport * as assertions from './base';\n\n/**\n * @fileoverview This file provides the entrypoint for dev assertions. It's\n * designed so all functions are pure function calls to improve inlining. All\n * functions in this file get DCE'd away during compilation.\n */\n\n/**\n * This will never execute regardless, but will be included on unminified builds\n * builds. It will be DCE'd away from minified builds, and so can be used to\n * validate that Babel is properly removing dev assertions in minified builds.\n */\nfunction devAssertDceCheck() {\n  if (self.__AMP_ASSERTION_CHECK) {\n    console /*OK*/\n      .log('__devAssert_sentinel__');\n  }\n}\n\n/**\n * Throws an error if the first argument isn't trueish. Mirrors devAssert in\n * src/log.js.\n * @param {T} shouldBeTruthy\n * @param {string=} opt_message\n * @param {*=} opt_1 Optional argument (var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {T}\n * @template T\n * @throws {Error} when shouldBeTruthy is not truthy.\n * @closurePrimitive {asserts.truthy}\n */\nexport function devAssert(\n  shouldBeTruthy,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  if (mode.isMinified()) {\n    return shouldBeTruthy;\n  }\n  devAssertDceCheck();\n\n  return assertions.assert(\n    '',\n    shouldBeTruthy,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n\n/**\n * Throws an error if the first argument isn't an Element.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeElement\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Element} The value of shouldBeTrueish.\n * @throws {Error} when shouldBeElement is not an Element\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertElement(shouldBeElement, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {!Element} */ (shouldBeElement);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertElement(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeElement,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a string. The string can\n * be empty.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeString\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {string} The string value. Can be an empty string.\n * @throws {Error} when shouldBeString is not an String\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertString(shouldBeString, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {string} */ (shouldBeString);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertString(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeString,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a number. The allowed values\n * include `0` and `NaN`.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeNumber\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {number} The number value. The allowed values include `0`\n *   and `NaN`.\n * @throws {Error} when shouldBeNumber is not an Number\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertNumber(shouldBeNumber, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {number} */ (shouldBeNumber);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertNumber(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeNumber,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument is not an array.\n * The array can be empty.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeArray\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Array} The array value\n * @throws {Error} when shouldBeArray is not an Array\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertArray(shouldBeArray, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {!Array} */ (shouldBeArray);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertArray(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeArray,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a boolean.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeBoolean\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {boolean} The boolean value.\n * @throws {Error} when shouldBeBoolean is not an Boolean\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertBoolean(shouldBeBoolean, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {boolean} */ (shouldBeBoolean);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertBoolean(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeBoolean,\n    opt_message\n  );\n}\n", "import {devAssert} from '#core/assert';\n\n/**\n * Key string in an action arguments map for an unparsed object literal string.\n *\n * E.g. for the action in <p on=\"tap:AMP.setState({foo: 'bar'})\",\n * then `args[RAW_OBJECT_ARGS_KEY]` is the string \"{foo: 'bar'}\".\n *\n * The action service delegates parsing of object literals to the corresponding\n * extension (in the example above, amp-bind).\n *\n * @see ./service/action-impl.ActionInfoDef\n * @const {string}\n */\nexport const RAW_OBJECT_ARGS_KEY = '__AMP_OBJECT_STRING__';\n\n/**\n * Identifier for an element's default action.\n *\n * @const {string}\n */\nexport const DEFAULT_ACTION = 'activate';\n\n/**\n * Corresponds to degree of user intent, i.e. events triggered with strong\n * user intent have high trust.\n *\n * @enum {number}\n */\nexport const ActionTrust = {\n  /**\n   * Events that are triggered without a user gesture, or triggered by a user\n   * gesture with weak intent (e.g. scroll) are \"low trust\".\n   *\n   * Actions that have low impact on the page's visual state should require\n   * \"low trust\" (e.g. pausing a video).\n   */\n  LOW: 1,\n  /**\n   * Events that are triggered nearly immediately (up to a few seconds) after\n   * a user gesture with strong intent (e.g. tap or swipe) are \"default trust\".\n   *\n   * Actions that can modify the page's visual state (e.g. content jumping)\n   * should require \"default trust\". This is the default required trust level\n   * for actions.\n   */\n  DEFAULT: 2,\n  /**\n   * Events that are triggered immediately after a user gesture with\n   * strong intent (e.g. tap or swipe) are \"high trust\".\n   *\n   * There are no actions yet that require high trust.\n   */\n  HIGH: 3,\n};\n\n/**\n * @param {!ActionTrust} actionTrust\n * @return {string}\n */\nexport function actionTrustToString(actionTrust) {\n  switch (actionTrust) {\n    case ActionTrust.LOW:\n      return 'low';\n    case ActionTrust.HIGH:\n      return 'high';\n    default:\n      devAssert(actionTrust === ActionTrust.DEFAULT);\n      return 'default';\n  }\n}\n", "/**\n * Common AMP events.\n * @enum {string}\n */\nexport const AmpEvents = {\n  DOM_UPDATE: 'amp:dom-update',\n  FORM_DIRTINESS_CHANGE: 'amp:form-dirtiness-change',\n  FORM_VALUE_CHANGE: 'amp:form-value-change',\n  VISIBILITY_CHANGE: 'amp:visibilitychange', // https://github.com/ampproject/amphtml/blob/main/ads/README.md#page-visibility\n  // The following codes are only used for testing.\n  // TODO(choumx): Move these to a separate enum so they can be DCE'd.\n  ATTACHED: 'amp:attached',\n  STUBBED: 'amp:stubbed',\n  LOAD_START: 'amp:load-start',\n  LOAD_END: 'amp:load-end',\n  ERROR: 'amp:error',\n  SIZE_CHANGED: 'amp:size-changed',\n  UNLOAD: 'amp:unload',\n};\n", "/**\n * Interface for all AMP Async Input Elements.\n * enforces the overridable function, getValue().\n * Async Input should be implemented\n * by components like AMP form, to async request\n * a value from a component, and then be used for\n * some other action. For examples, this can be used\n * by reCAPTCHA to request tokens for the form.\n *\n * NOTE: Elements that implemented AsyncInput must\n * Also add and follow the other exported constants.\n * See amp-recaptcha-input as an example.\n *\n * @interface\n */\nexport class AsyncInput {\n  /**\n   * Called to get the asynchronous value of an\n   * AsyncInput field.\n   * @return {!Promise<string>}\n   */\n  getValue() {}\n}\n\n/**\n * Attributes\n *\n * Components implementing the AsyncInput,\n * are expected to assert these attributes\n * at the appropriate time.\n *\n * @enum {string}\n */\nexport const AsyncInputAttributes = {\n  /**\n   * data-name\n   *\n   * Required attribute that must be asserted by every async-input\n   * Element. This is used by AMP form to add the key\n   * for the form submission request\n   */\n  NAME: 'name',\n};\n\n/**\n * Classes\n *\n * Components implementing the AsyncInput,\n * are expected to add the following classes\n * at the appropriate time.\n *\n * @enum {string}\n */\nexport const AsyncInputClasses = {\n  /**\n   * i-amphtml-async-input\n   *\n   * Required base class that must be added to the async-input\n   * element on buildCallback or layoutCallback.\n   * This will be used by other amp components to find\n   * and use async-input elements.\n   */\n  'ASYNC_INPUT': 'i-amphtml-async-input',\n  /**\n   * i-async-require-action\n   *\n   * Class that is added when the async call should be treated\n   * as a required action for the form. These calls will be\n   * executed before the presubmit calls of all async inputs.\n   */\n  'ASYNC_REQUIRED_ACTION': 'i-async-require-action',\n};\n", "/**\n * @enum {number}\n */\nexport const KeyCodes = {\n  ENTER: 13,\n  ESCAPE: 27,\n  SPACE: 32,\n  LEFT_ARROW: 37,\n  UP_ARROW: 38,\n  RIGHT_ARROW: 39,\n  DOWN_ARROW: 40,\n};\n\n/**\n * @enum {string}\n */\nexport const Keys = {\n  ENTER: 'Enter',\n  ESCAPE: 'Escape',\n  SPACE: ' ',\n  LEFT_ARROW: 'ArrowLeft',\n  UP_ARROW: 'ArrowUp',\n  RIGHT_ARROW: 'ArrowRight',\n  DOWN_ARROW: 'ArrowDown',\n  TAB: 'Tab',\n  BACKSPACE: 'Backspace',\n  HOME: 'Home',\n  END: 'End',\n};\n", "/**\n * Checks that the document is of an AMP format type.\n * @param {!Array<string>} formats\n * @param {!Document} doc\n * @return {boolean}\n */\nfunction isAmpFormatType(formats, doc) {\n  const html = doc.documentElement;\n  const isFormatType = formats.some((format) => html.hasAttribute(format));\n  return isFormatType;\n}\n\n/**\n * @param {!Document} doc\n * @return {boolean}\n */\nexport function isAmp4Email(doc) {\n  return isAmpFormatType(['\u26A14email', 'amp4email'], doc);\n}\n\n/**\n * @param {!Document} doc\n * @return {boolean}\n */\nexport function isAmphtml(doc) {\n  return isAmpFormatType(['\u26A1', 'amp'], doc);\n}\n", "import {isArray} from '#core/types/array';\n\n/**\n * @fileoverview This module declares JSON types as defined in the\n * {@link http://json.org/}.\n */\n\n// NOTE Type are changed to {*} because of\n// https://github.com/google/closure-compiler/issues/1999\n\n/**\n * JSON scalar. It's either string, number or boolean.\n * @typedef {string|number|boolean|null}\n */\nlet JSONScalarDef;\n\n/**\n * JSON object. It's a map with string keys and JSON values.\n * @typedef {!Object<string, ?*>} (* should be JSONValueDef)\n */\nlet JSONObjectDef;\n\n/**\n * JSON array. It's an array with JSON values.\n * @typedef {!Array<?*>} (* should be JSONValueDef)\n */\nlet JSONArrayDef;\n\n/**\n * JSON value. It's either a scalar, an object or an array.\n * @typedef {!JSONScalarDef|!JSONObjectDef|!JSONArrayDef}\n */\nlet JSONValueDef;\n\n/**\n * @typedef {{\n *   YOU_MUST_USE: string,\n *   jsonLiteral: function(),\n *   TO_MAKE_THIS_TYPE: string,\n * }}\n */\nlet InternalJsonLiteralTypeDef;\n\n/**\n * Simple wrapper around JSON.parse that casts the return value\n * to JsonObject.\n * Create a new wrapper if an array return value is desired.\n * @param {string} json JSON string to parse\n * @return {?JsonObject} May be extend to parse arrays.\n */\nexport function parseJson(json) {\n  return /** @type {?JsonObject} */ (JSON.parse(json));\n}\n\n/**\n * Parses the given `json` string without throwing an exception if not valid.\n * Returns `undefined` if parsing fails.\n * Returns the `Object` corresponding to the JSON string when parsing succeeds.\n * @param {string} json JSON string to parse\n * @param {function(!Error)=} opt_onFailed Optional function that will be called\n *     with the error if parsing fails.\n * @return {?JsonObject} May be extend to parse arrays.\n */\nexport function tryParseJson(json, opt_onFailed) {\n  try {\n    return parseJson(json);\n  } catch (e) {\n    opt_onFailed?.(e);\n    return null;\n  }\n}\n\n/**\n * Deeply checks strict equality of items in nested arrays and objects.\n *\n * @param {JSONValueDef} a\n * @param {JSONValueDef} b\n * @param {number} depth The maximum depth. Must be finite.\n * @return {boolean}\n * @throws {Error} If depth argument is not finite.\n */\nexport function deepEquals(a, b, depth = 5) {\n  if (!isFinite(depth) || depth < 0) {\n    throw new Error('Invalid depth: ' + depth);\n  }\n  if (a === b) {\n    return true;\n  }\n  /** @type {!Array<{a: JSONValueDef, b: JSONValueDef, depth: number}>} */\n  const queue = [{a, b, depth}];\n  while (queue.length > 0) {\n    const {a, b, depth} = queue.shift();\n    // Only check deep equality if depth > 0.\n    if (depth > 0) {\n      if (typeof a !== typeof b) {\n        return false;\n      } else if (isArray(a) && isArray(b)) {\n        if (a.length !== b.length) {\n          return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n          queue.push({a: a[i], b: b[i], depth: depth - 1});\n        }\n        continue;\n      } else if (a && b && typeof a === 'object' && typeof b === 'object') {\n        const keysA = Object.keys(a);\n        const keysB = Object.keys(b);\n        if (keysA.length !== keysB.length) {\n          return false;\n        }\n        for (const k of keysA) {\n          queue.push({a: a[k], b: b[k], depth: depth - 1});\n        }\n        continue;\n      }\n    }\n    // If we get here, then depth == 0 or (a, b) are primitives.\n    if (a !== b) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * This helper function handles configurations specified in a JSON format.\n *\n * It allows the configuration is to be written in plain JS (which has better\n * dev ergonomics like comments and trailing commas), and allows the\n * configuration to be transformed into an efficient JSON-parsed representation\n * in the dist build. See https://v8.dev/blog/cost-of-javascript-2019#json\n *\n * @param {!Object} obj\n * @return {!JsonObject}\n */\nexport function jsonConfiguration(obj) {\n  return /** @type {!JsonObject} */ (obj);\n}\n\n/**\n * This converts an Object into a suitable type to be used in `includeJsonLiteral`.\n * This doesn't actually do any conversion, it only changes the closure type.\n *\n * @param {?JSONValueDef} value\n * @return {!InternalJsonLiteralTypeDef}\n */\nexport function jsonLiteral(value) {\n  return /** @type {!InternalJsonLiteralTypeDef} */ (value);\n}\n\n/**\n * Allows inclusion of a variable (that's wrapped in a jsonLiteral\n * call) to be included inside a jsonConfiguration.\n *\n * @param {!InternalJsonLiteralTypeDef} value\n * @return {*}\n */\nexport function includeJsonLiteral(value) {\n  return value;\n}\n", "/**\n * Externs declare that access `defaultView` from `document` or\n * `ownerDocument` is of type `(Window|null)` but most of our parameter types\n * assume that it is never null. This is OK in practice as we ever only get\n * null on disconnected documents or old IE.\n * This helper function casts it into just a simple Window return type.\n *\n * @param {?Window} winOrNull\n * @return {!Window}\n */\nexport function toWin(winOrNull) {\n  return /** @type {!Window} */ (winOrNull);\n}\n\n/**\n * Returns the associated Window for a node.\n *\n * @param {!Node} node\n * @return {!Window}\n */\nexport function getWin(node) {\n  return toWin(\n    (node.ownerDocument || /** @type {!Document} */ (node)).defaultView\n  );\n}\n", "/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */\n\n\n/**\n * This regex consists of 4 matching capture groups and one (non-matching) fallback:\n *\n * - (\\0), catch the null terminator character so it may be replaced by UTF\n *   Replacement Char\n * - ^(-)$, catch a solitary dash char, so that it may be backslash escaped.\n *   This is a separate capture group so that the legal-chars (group 4) doesn't\n *   capture it first, since that group doesn't need to escape its dash.\n * - ([\\x01-\\x1f\\x7f]|^-?[0-9]), catch a UTF control char, or any leading\n *   number (with an optional leading dash). The control or the number (but not\n *   the leading dash) must be hex-escaped,.\n * - ([\\x80-\\uffff0-9a-zA-Z_-]+), catch legal-chars, with the exception of a\n *   solitary dash, which will already have matched in group 1.\n * - [^], finally, a catch-all that allows us to backslash escape the char.\n *\n * Together, this matches everything necessary for CSS.escape.\n */\nvar regex = /(\\0)|^(-)$|([\\x01-\\x1f\\x7f]|^-?[0-9])|([\\x80-\\uffff0-9a-zA-Z_-]+)|[^]/g;\n\nfunction escaper(match, nil, dash, hexEscape, chars) {\n  // Chars is the legal-chars (group 4) capture\n  if (chars) {\n    return chars;\n  }\n  // Nil is the null terminator (group 1) capture\n  if (nil) {\n    return '\\uFFFD';\n  }\n  // Both UTF control chars, and leading numbers (with optional leading dash)\n  // (group 3) must be backslash escaped with a trailing space.  Funnily, the\n  // leading dash must not be escaped, but the number. :shrug:\n  if (hexEscape) {\n    return match.slice(0, -1) + '\\\\' + match.slice(-1).charCodeAt(0).toString(16) + ' '\n  }\n  // Finally, the solitary dash and the catch-all chars require backslash\n  // escaping.\n  return '\\\\' + match;\n}\n\n/**\n * https://drafts.csswg.org/cssom/#serialize-an-identifier\n * @param {string} value\n * @return {string}\n */\nexport function cssEscape(value) {\n  return String(value).replace(regex, escaper);\n}\n", "import {devAssert} from '#core/assert';\nimport * as mode from '#core/mode';\n\nimport {cssEscape} from '#third_party/css-escape/css-escape';\n\n/**\n * @type {boolean|undefined}\n */\nlet scopeSelectorSupported;\n\n/**\n * @param {boolean|undefined} val\n * @visibleForTesting\n */\nexport function setScopeSelectorSupportedForTesting(val) {\n  scopeSelectorSupported = val;\n}\n\n/**\n * Test that the :scope selector is supported and behaves correctly.\n * @param {!Element|!ShadowRoot} el\n * @return {boolean}\n */\nexport function isScopeSelectorSupported(el) {\n  if (scopeSelectorSupported !== undefined) {\n    return scopeSelectorSupported;\n  }\n\n  return (scopeSelectorSupported = testScopeSelector(el));\n}\n\n/**\n * Test that the :scope selector is supported and behaves correctly.\n * @param {!Element|!ShadowRoot} el\n * @return {boolean}\n */\nfunction testScopeSelector(el) {\n  try {\n    const doc = el.ownerDocument;\n    const testElement = doc.createElement('div');\n    const testChild = doc.createElement('div');\n    testElement.appendChild(testChild);\n    // NOTE(cvializ, #12383): Firefox's implementation is incomplete,\n    // therefore we test actual functionality of`:scope` as well.\n    return testElement./*OK*/ querySelector(':scope div') === testChild;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Prefixes a selector for ancestor selection. Splits in subselectors and\n * applies prefix to each.\n *\n * e.g.\n * ```\n *   prependSelectorsWith('div', '.i-amphtml-scoped');\n *   // => '.i-amphtml-scoped div'\n *   prependSelectorsWith('div, ul', ':scope');\n *   // => ':scope div, :scope ul'\n *   prependSelectorsWith('div, ul', 'article >');\n *   // => 'article > div, article > ul'\n * ```\n *\n * @param {string} selector\n * @param {string} distribute\n * @return {string}\n */\nexport function prependSelectorsWith(selector, distribute) {\n  return selector.replace(/^|,/g, `$&${distribute} `);\n}\n\n/**\n * Escapes an ident (ID or a class name) to be used as a CSS selector.\n *\n * See https://drafts.csswg.org/cssom/#serialize-an-identifier.\n *\n * @param {string} ident\n * @return {string}\n * @suppress {uselessCode}\n */\nexport function escapeCssSelectorIdent(ident) {\n  // This gets rewritten to true/false during compilation. It will trigger an\n  // JSC_UNREACHABLE_CODE warning, but that's intentional for DCE.\n  if (mode.isEsm()) {\n    return CSS.escape(ident);\n  }\n  return cssEscape(ident);\n}\n\n/**\n * Escapes an ident in a way that can be used by :nth-child() psuedo-class.\n *\n * See https://github.com/w3c/csswg-drafts/issues/2306.\n *\n * @param {string|number} ident\n * @return {string}\n */\nexport function escapeCssSelectorNth(ident) {\n  const escaped = String(ident);\n  // Ensure it doesn't close the nth-child psuedo class.\n  devAssert(escaped.indexOf(')') === -1);\n  return escaped;\n}\n", "import {devAssert, devAssertElement} from '#core/assert';\nimport * as mode from '#core/mode';\n\nimport {isScopeSelectorSupported, prependSelectorsWith} from './css-selectors';\n\n/** @fileoverview Helper functions for DOM queries. */\n\n/**\n * Asserts that name is just an alphanumeric word, and does not contain\n * advanced CSS selector features like attributes, psuedo-classes, class names,\n * nor ids.\n * @param {string} name\n */\nfunction assertIsName(name) {\n  devAssert(\n    /^[\\w-]+$/.test(name),\n    `Expected \"${name}\" to be a CSS name composed of alphanumerics and hyphens.`\n  );\n}\n\n/**\n * Finds all elements that matche `selector`, scoped inside `root`\n * for user-agents that do not support native scoping.\n *\n * This method isn't required for modern builds, can be removed.\n *\n * @param {!Element|!ShadowRoot} root\n * @param {string} selector\n * @return {!NodeList<!Element>}\n */\nfunction scopedQuerySelectionFallback(root, selector) {\n  const unique = 'i-amphtml-scoped';\n  root.classList.add(unique);\n  const scopedSelector = prependSelectorsWith(selector, `.${unique}`);\n  const elements = root./*OK*/ querySelectorAll(scopedSelector);\n  root.classList.remove(unique);\n  return elements;\n}\n\n/**\n * Finds the first element that matches `selector`, scoped inside `root`.\n * Note: in IE, this causes a quick mutation of the element's class list.\n * @param {!Element|!ShadowRoot} root\n * @param {string} selector\n * @return {?Element}\n *\n * @suppress {suspiciousCode}\n */\nexport function scopedQuerySelector(root, selector) {\n  if (mode.isEsm() || isScopeSelectorSupported(root)) {\n    return root./*OK*/ querySelector(prependSelectorsWith(selector, ':scope'));\n  }\n\n  // Only IE.\n  const fallbackResult = scopedQuerySelectionFallback(root, selector);\n  return fallbackResult[0] === undefined ? null : fallbackResult[0];\n}\n\n/**\n * Finds every element that matches `selector`, scoped inside `root`.\n * Note: in IE, this causes a quick mutation of the element's class list.\n * @param {!Element|!ShadowRoot} root\n * @param {string} selector\n * @return {!NodeList<!Element>}\n *\n * @suppress {suspiciousCode}\n */\nexport function scopedQuerySelectorAll(root, selector) {\n  if (mode.isEsm() || isScopeSelectorSupported(root)) {\n    return root./*OK*/ querySelectorAll(\n      prependSelectorsWith(selector, ':scope')\n    );\n  }\n\n  // Only IE.\n  return scopedQuerySelectionFallback(root, selector);\n}\n\n/**\n * Checks if the given element matches the selector\n * @param  {!Element} el The element to verify\n * @param  {string} selector The selector to check against\n * @return {boolean} True if the element matched the selector. False otherwise.\n */\nexport function matches(el, selector) {\n  const matcher =\n    el.matches ||\n    el.webkitMatchesSelector ||\n    el.mozMatchesSelector ||\n    el.msMatchesSelector ||\n    el.oMatchesSelector;\n  if (matcher) {\n    return matcher.call(el, selector);\n  }\n  return false; // IE8 always returns false.\n}\n\n/**\n * Finds the closest element that satisfies the callback from this element\n * up the DOM subtree.\n * @param {!Element} element\n * @param {function(!Element):boolean} callback\n * @param {Element=} opt_stopAt optional elemnt to stop the search at.\n * @return {?Element}\n */\nexport function closest(element, callback, opt_stopAt) {\n  for (let el = element; el && el !== opt_stopAt; el = el.parentElement) {\n    if (callback(el)) {\n      return el;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds the closest node that satisfies the callback from this node\n * up the DOM subtree.\n * @param {!Node} node\n * @param {function(!Node):boolean} callback\n * @return {?Node}\n */\nexport function closestNode(node, callback) {\n  for (let n = node; n; n = n.parentNode) {\n    if (callback(n)) {\n      return n;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds the closest ancestor element with the specified selector from this\n * element.\n * @param {!Element} element\n * @param {string} selector\n * @return {?Element} closest ancestor if found.\n */\nexport function closestAncestorElementBySelector(element, selector) {\n  return element.closest\n    ? element.closest(selector)\n    : closest(element, (el) => matches(el, selector));\n}\n\n/**\n * Finds all ancestor elements that satisfy predicate.\n * @param {!Element} child\n * @param {function(!Element):boolean} predicate\n * @return {!Array<!Element>}\n */\nexport function ancestorElements(child, predicate) {\n  const ancestors = [];\n  for (\n    let ancestor = child.parentElement;\n    ancestor;\n    ancestor = ancestor.parentElement\n  ) {\n    if (predicate(ancestor)) {\n      ancestors.push(ancestor);\n    }\n  }\n  return ancestors;\n}\n\n/**\n * Finds all ancestor elements that has the specified tag name.\n * @param {!Element} child\n * @param {string} tagName\n * @return {!Array<!Element>}\n */\nexport function ancestorElementsByTag(child, tagName) {\n  assertIsName(tagName);\n  tagName = tagName.toUpperCase();\n  return ancestorElements(child, (el) => el.tagName == tagName);\n}\n\n/**\n * Finds the first child element that satisfies the callback.\n * TODO(rcebulko): Can we start using generators in childElements and defer to\n * that here?\n * @param {!Element} parent\n * @param {function(!Element):boolean} callback\n * @return {?Element}\n */\nexport function childElement(parent, callback) {\n  for (\n    let child = parent.firstElementChild;\n    child;\n    child = child.nextElementSibling\n  ) {\n    if (callback(child)) {\n      return child;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds the last child element that satisfies the callback.\n * @param {!Element} parent\n * @param {function(!Element):boolean} callback\n * @return {?Element}\n */\nexport function lastChildElement(parent, callback) {\n  for (\n    let child = parent.lastElementChild;\n    child;\n    child = child.previousElementSibling\n  ) {\n    if (callback(child)) {\n      return child;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds all child elements that satisfy the callback.\n * @param {!Element} parent\n * @param {function(!Element):boolean} callback\n * @return {!Array<!Element>}\n */\nexport function childElements(parent, callback) {\n  const children = [];\n  for (\n    let child = parent.firstElementChild;\n    child;\n    child = child.nextElementSibling\n  ) {\n    if (callback(child)) {\n      children.push(child);\n    }\n  }\n  return children;\n}\n\n/**\n * Finds all child nodes that satisfy the callback.\n * These nodes can include Text, Comment and other child nodes.\n * @param {!Node} parent\n * @param {function(!Node):boolean} callback\n * @return {!Array<!Node>}\n */\nexport function childNodes(parent, callback) {\n  const nodes = [];\n  for (let child = parent.firstChild; child; child = child.nextSibling) {\n    if (callback(child)) {\n      nodes.push(child);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Finds the first child element that has the specified attribute.\n * @param {!Element|!ShadowRoot} parent\n * @param {string} attr\n * @return {?Element}\n */\nexport function childElementByAttr(parent, attr) {\n  assertIsName(attr);\n  return /*OK*/ scopedQuerySelector(parent, `> [${attr}]`);\n}\n\n/**\n * Finds the last child element that has the specified attribute.\n * @param {!Element} parent\n * @param {string} attr\n * @return {?Element}\n */\nexport function lastChildElementByAttr(parent, attr) {\n  assertIsName(attr);\n  return lastChildElement(parent, (el) => {\n    return el.hasAttribute(attr);\n  });\n}\n\n/**\n * Finds all child elements that has the specified attribute.\n * @param {!Element|!ShadowRoot} parent\n * @param {string} attr\n * @return {!NodeList<!Element>}\n */\nexport function childElementsByAttr(parent, attr) {\n  assertIsName(attr);\n  return /*OK*/ scopedQuerySelectorAll(parent, `> [${attr}]`);\n}\n\n/**\n * Finds the first child element that has the specified tag name.\n * @param {!Element|!ShadowRoot} parent\n * @param {string} tagName\n * @return {?Element}\n */\nexport function childElementByTag(parent, tagName) {\n  assertIsName(tagName);\n  return /*OK*/ scopedQuerySelector(parent, `> ${tagName}`);\n}\n\n/**\n * Finds all child elements with the specified tag name.\n * @param {!Element|!ShadowRoot} parent\n * @param {string} tagName\n * @return {!NodeList<!Element>}\n */\nexport function childElementsByTag(parent, tagName) {\n  assertIsName(tagName);\n  return /*OK*/ scopedQuerySelectorAll(parent, `> ${tagName}`);\n}\n\n/**\n * Finds the first descendant element with the specified name.\n * @param {!Element|!Document|!ShadowRoot} element\n * @param {string} tagName\n * @return {?Element}\n */\nexport function elementByTag(element, tagName) {\n  assertIsName(tagName);\n  return element./*OK*/ querySelector(tagName);\n}\n\n/**\n * Returns the original nodes of the custom element without any service\n * nodes that could have been added for markup. These nodes can include\n * Text, Comment and other child nodes.\n *\n * @param {!Node} element\n * @return {!Array<!Node>}\n */\nexport function realChildNodes(element) {\n  return childNodes(element, (node) => !isInternalOrServiceNode(node));\n}\n\n/**\n * Returns the original children of the custom element without any service\n * nodes that could have been added for markup.\n *\n * @param {!Element} element\n * @return {!Array<!Element>}\n */\nexport function realChildElements(element) {\n  return childElements(element, (element) => !isInternalOrServiceNode(element));\n}\n\n/**\n * Returns \"true\" for internal AMP nodes or for placeholder elements.\n * @param {!Node} node\n * @return {boolean}\n */\nexport function isInternalOrServiceNode(node) {\n  if (isInternalElement(node)) {\n    return true;\n  }\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return false;\n  }\n  devAssertElement(node);\n\n  return (\n    node.hasAttribute('placeholder') ||\n    node.hasAttribute('fallback') ||\n    node.hasAttribute('overflow')\n  );\n}\n\n/**\n * Whether the tag is an internal (service) AMP tag.\n * @param {!Node|string} nodeOrTagName\n * @return {boolean}\n */\nfunction isInternalElement(nodeOrTagName) {\n  /** @type string */\n  let tagName;\n  if (typeof nodeOrTagName == 'string') {\n    tagName = nodeOrTagName;\n  } else if (nodeOrTagName.nodeType === Node.ELEMENT_NODE) {\n    tagName = devAssertElement(nodeOrTagName).tagName;\n  }\n\n  return !!tagName && tagName.toLowerCase().startsWith('i-');\n}\n", "import * as mode from '#core/mode';\nimport {dict} from '#core/types/object';\nimport {parseJson} from '#core/types/object/json';\nimport {getWin} from '#core/window';\n\nimport {childElementsByTag, matches} from './query';\n\nconst HTML_ESCAPE_CHARS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '`': '&#x60;',\n};\nconst HTML_ESCAPE_REGEX = /(&|<|>|\"|'|`)/g;\n\n/**\n * @typedef {{\n *   bubbles: (boolean|undefined),\n *   cancelable: (boolean|undefined),\n * }}\n */\nexport let CustomEventOptionsDef;\n\n/** @const {!CustomEventOptionsDef} */\nconst DEFAULT_CUSTOM_EVENT_OPTIONS = {bubbles: true, cancelable: true};\n\n/**\n * Waits until the child element is constructed. Once the child is found, the\n * callback is executed.\n * @param {!Element} parent\n * @param {function(!Element):boolean} checkFunc\n * @param {function()} callback\n */\nexport function waitForChild(parent, checkFunc, callback) {\n  if (checkFunc(parent)) {\n    callback();\n    return;\n  }\n  const win = getWin(parent);\n  if (mode.isEsm() || win.MutationObserver) {\n    const observer = new win.MutationObserver(() => {\n      if (checkFunc(parent)) {\n        observer.disconnect();\n        callback();\n      }\n    });\n    observer.observe(parent, {childList: true});\n  } else {\n    const interval = win.setInterval(() => {\n      if (checkFunc(parent)) {\n        win.clearInterval(interval);\n        callback();\n      }\n    }, /* milliseconds */ 5);\n  }\n}\n\n/**\n * Waits until the child element is constructed. Once the child is found, the\n * promise is resolved.\n * @param {!Element} parent\n * @param {function(!Element):boolean} checkFunc\n * @return {!Promise}\n */\nexport function waitForChildPromise(parent, checkFunc) {\n  return new Promise((resolve) => {\n    waitForChild(parent, checkFunc, resolve);\n  });\n}\n\n/**\n * Waits for document's body to be available and ready.\n * @param {!Document} doc\n * @param {function()} callback\n */\nexport function waitForBodyOpen(doc, callback) {\n  waitForChild(doc.documentElement, () => !!doc.body, callback);\n}\n\n/**\n * Waits for document's body to be available.\n * @param {!Document} doc\n * @return {!Promise}\n */\nexport function waitForBodyOpenPromise(doc) {\n  return new Promise((resolve) => waitForBodyOpen(doc, resolve));\n}\n\n/**\n * Removes the element.\n * @param {!Element} element\n */\nexport function removeElement(element) {\n  element.parentElement?.removeChild(element);\n}\n\n/**\n * Removes all child nodes of the specified element.\n * @param {!Element|!DocumentFragment} parent\n */\nexport function removeChildren(parent) {\n  while (parent.firstChild) {\n    parent.removeChild(parent.firstChild);\n  }\n}\n\n/**\n * Copies all children nodes of element \"from\" to element \"to\". Child nodes\n * are deeply cloned. Notice, that this method should be used with care and\n * preferably on smaller subtrees.\n * @param {!Element} from\n * @param {!Element|!DocumentFragment} to\n */\nexport function copyChildren(from, to) {\n  const frag = to.ownerDocument.createDocumentFragment();\n  for (let n = from.firstChild; n; n = n.nextSibling) {\n    frag.appendChild(n.cloneNode(true));\n  }\n  to.appendChild(frag);\n}\n\n/**\n * Insert the element in the root after the element named after or\n * if that is null at the beginning.\n * @param {!Element|!ShadowRoot} root\n * @param {!Element} element\n * @param {?Node=} after\n */\nexport function insertAfterOrAtStart(root, element, after = null) {\n  if (!after) {\n    insertAtStart(root, element);\n    return;\n  }\n  const before = after.nextSibling;\n  root.insertBefore(element, before);\n}\n\n/**\n * Insert the element in the root after the element named after or\n * if that is null at the beginning.\n * @param {!Element|!ShadowRoot} root\n * @param {!Element} element\n */\nexport function insertAtStart(root, element) {\n  root.insertBefore(element, root.firstChild);\n}\n\n/**\n * Add attributes to an element.\n * @param {!Element} element\n * @param {!JsonObject<string, string>} attributes\n * @return {!Element} created element\n */\nexport function addAttributesToElement(element, attributes) {\n  for (const attr in attributes) {\n    element.setAttribute(attr, attributes[attr]);\n  }\n  return element;\n}\n\n/**\n * Create a new element on document with specified tagName and attributes.\n * @param {!Document} doc\n * @param {string} tagName\n * @param {!JsonObject<string, string>} attributes\n * @return {!Element} created element\n */\nexport function createElementWithAttributes(doc, tagName, attributes) {\n  const element = doc.createElement(tagName);\n  return addAttributesToElement(element, attributes);\n}\n\n/**\n * Returns true if node is connected (attached).\n * @param {!Node} node\n * @return {boolean}\n * @see https://dom.spec.whatwg.org/#connected\n */\nexport function isConnectedNode(node) {\n  const connected = node.isConnected;\n  if (connected !== undefined) {\n    return connected;\n  }\n\n  // \"An element is connected if its shadow-including root is a document.\"\n  let n = node;\n  do {\n    n = rootNodeFor(n);\n    if (n.host) {\n      n = n.host;\n    } else {\n      break;\n    }\n  } while (true);\n  return n.nodeType === Node.DOCUMENT_NODE;\n}\n\n/**\n * Returns the root for a given node. Does not cross shadow DOM boundary.\n * @param {!Node} node\n * @return {!Node}\n */\nexport function rootNodeFor(node) {\n  if (Node.prototype.getRootNode) {\n    // Type checker says `getRootNode` may return null.\n    return node.getRootNode() || node;\n  }\n  let n;\n  // Check isShadowRoot() is only needed for the polyfill case.\n  for (\n    n = node;\n    !!n.parentNode && !isShadowRoot(/** @type {HTMLElement} */ (n));\n    n = n.parentNode\n  ) {}\n  return n;\n}\n\n/**\n * Determines if value is actually a `ShadowRoot` node.\n * @param {?HTMLElement} value\n * @return {boolean}\n */\nexport function isShadowRoot(value) {\n  if (!value) {\n    return false;\n  }\n  // Node.nodeType == DOCUMENT_FRAGMENT to speed up the tests. Unfortunately,\n  // nodeType of DOCUMENT_FRAGMENT is used currently for ShadowRoot nodes.\n  if (value.tagName == 'I-AMPHTML-SHADOW-ROOT') {\n    return true;\n  }\n  return (\n    value.nodeType == /* DOCUMENT_FRAGMENT */ 11 &&\n    Object.prototype.toString.call(value) === '[object ShadowRoot]'\n  );\n}\n\n/**\n * Returns element data-param- attributes as url parameters key-value pairs.\n * e.g. data-param-some-attr=value -> {someAttr: value}.\n * @param {!HTMLElement} element\n * @param {function(string):string=} opt_computeParamNameFunc to compute the\n *    parameter name, get passed the camel-case parameter name.\n * @param {!RegExp=} opt_paramPattern Regex pattern to match data attributes.\n * @return {!JsonObject}\n */\nexport function getDataParamsFromAttributes(\n  element,\n  opt_computeParamNameFunc,\n  opt_paramPattern\n) {\n  const computeParamNameFunc = opt_computeParamNameFunc || ((key) => key);\n  const {dataset} = element;\n  const params = dict();\n  const paramPattern = opt_paramPattern || /^param(.+)/;\n  for (const key in dataset) {\n    const matches = key.match(paramPattern);\n    if (matches) {\n      const param = matches[1][0].toLowerCase() + matches[1].substr(1);\n      params[computeParamNameFunc(param)] = dataset[key];\n    }\n  }\n  return params;\n}\n\n/**\n * Whether the element have a next node in the document order.\n * This means either:\n *  a. The element itself has a nextSibling.\n *  b. Any of the element ancestors has a nextSibling.\n * @param {!Element} element\n * @param {?Node} opt_stopNode\n * @return {boolean}\n */\nexport function hasNextNodeInDocumentOrder(element, opt_stopNode) {\n  let currentElement = element;\n  do {\n    if (currentElement.nextSibling) {\n      return true;\n    }\n  } while (\n    (currentElement = currentElement.parentNode) &&\n    currentElement != opt_stopNode\n  );\n  return false;\n}\n\n/**\n * Returns a clone of the content of a template element.\n *\n * Polyfill to replace .content access for browsers that do not support\n * HTMLTemplateElements natively.\n *\n * @param {!HTMLTemplateElement|!Element} template\n * @return {!DocumentFragment}\n */\nexport function templateContentClone(template) {\n  if ('content' in template) {\n    return template.content.cloneNode(true);\n  } else {\n    const content = template.ownerDocument.createDocumentFragment();\n    copyChildren(template, content);\n    return content;\n  }\n}\n\n/**\n * Iterate over an array-like.\n * Test cases: https://jsbench.github.io/#f638cacc866a1b2d6e517e6cfa900d6b\n * @param {!IArrayLike<T>} iterable\n * @param {function(T, number)} cb\n * @template T\n */\nexport function iterateCursor(iterable, cb) {\n  const {length} = iterable;\n  for (let i = 0; i < length; i++) {\n    cb(iterable[i], i);\n  }\n}\n\n/**\n * Whether the element is a script tag with application/json type.\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isJsonScriptTag(element) {\n  return (\n    element.tagName == 'SCRIPT' &&\n    element.getAttribute('type')?.toUpperCase() == 'APPLICATION/JSON'\n  );\n}\n\n/**\n * Whether the element is a script tag with application/json type.\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isJsonLdScriptTag(element) {\n  return (\n    element.tagName == 'SCRIPT' &&\n    element.getAttribute('type')?.toUpperCase() == 'APPLICATION/LD+JSON'\n  );\n}\n\n/**\n * Whether the page's direction is right to left or not.\n * @param {!Document} doc\n * @return {boolean}\n */\nexport function isRTL(doc) {\n  const dir =\n    doc.body.getAttribute('dir') ||\n    doc.documentElement.getAttribute('dir') ||\n    'ltr';\n  return dir == 'rtl';\n}\n\n/**\n * Escapes `<`, `>` and other HTML charcaters with their escaped forms.\n * @param {string} text\n * @return {string}\n */\nexport function escapeHtml(text) {\n  if (!text) {\n    return text;\n  }\n  return text.replace(HTML_ESCAPE_REGEX, escapeHtmlChar);\n}\n\n/**\n * @param {string} c\n * @return {string}\n */\nfunction escapeHtmlChar(c) {\n  return HTML_ESCAPE_CHARS[c];\n}\n\n/**\n * Tries to focus on the given element; fails silently if browser throws an\n * exception.\n * @param {!Element} element\n */\nexport function tryFocus(element) {\n  try {\n    element./*OK*/ focus();\n  } catch (e) {\n    // IE <= 7 may throw exceptions when focusing on hidden items.\n  }\n}\n\n/**\n * Whether the given window is in an iframe or not.\n * @param {!Window} win\n * @return {boolean}\n */\nexport function isIframed(win) {\n  return win.parent && win.parent != win;\n}\n\n/**\n * Returns true if node is not disabled.\n *\n * IE8 can return false positives, see {@link matches}.\n * @param {!HTMLInputElement} element\n * @return {boolean}\n * @see https://www.w3.org/TR/html5/forms.html#concept-fe-disabled\n */\nexport function isEnabled(element) {\n  return !(element.disabled || matches(element, ':disabled'));\n}\n\n/**\n * A sorting comparator that sorts elements in DOM tree order.\n * A first sibling is sorted to be before its nextSibling.\n * A parent node is sorted to be before a child.\n * See https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {!Element} element1\n * @param {!Element} element2\n * @return {number}\n */\nexport function domOrderComparator(element1, element2) {\n  if (element1 === element2) {\n    return 0;\n  }\n\n  const pos = element1.compareDocumentPosition(element2);\n  const precedingOrContains =\n    Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS;\n\n  // if fe2 is preceding or contains fe1 then, fe1 is after fe2\n  if (pos & precedingOrContains) {\n    return 1;\n  }\n\n  // if fe2 is following or contained by fe1, then fe1 is before fe2\n  return -1;\n}\n\n/**\n * Like `Element.prototype.toggleAttribute`. This either toggles an attribute\n * on by adding an attribute with an empty value, or toggles it off by removing\n * the attribute. This does not mutate the element if the new state matches\n * the existing state.\n * @param {!Element} element An element to toggle the attribute for.\n * @param {string} name The name of the attribute.\n * @param {boolean=} forced Whether the attribute should be forced on/off. If\n *    not specified, it will be toggled from the current state.\n * @return {boolean} Whether or not the element now has the attribute.\n */\nexport function toggleAttribute(element, name, forced) {\n  const hasAttribute = element.hasAttribute(name);\n  const enabled = forced !== undefined ? forced : !hasAttribute;\n\n  if (enabled !== hasAttribute) {\n    if (enabled) {\n      element.setAttribute(name, '');\n    } else {\n      element.removeAttribute(name);\n    }\n  }\n\n  return enabled;\n}\n\n/**\n * Parses a string as a boolean value using the expanded rules for DOM boolean\n * attributes:\n * - a `null` or `undefined` returns `null`;\n * - an empty string returns `true`;\n * - a \"false\" string returns `false`;\n * - otherwise, `true` is returned.\n *\n * @param {?string|undefined} s\n * @return {boolean|undefined}\n */\nexport function parseBooleanAttribute(s) {\n  return s == null ? undefined : s !== 'false';\n}\n\n/**\n * @param {!Window} win\n * @return {number} The width of the vertical scrollbar, in pixels.\n */\nexport function getVerticalScrollbarWidth(win) {\n  const {documentElement} = win.document;\n  const windowWidth = win./*OK*/ innerWidth;\n  const documentWidth = documentElement./*OK*/ clientWidth;\n  return windowWidth - documentWidth;\n}\n\n/**\n * Dispatches a custom event.\n *\n * @param {!Node} node\n * @param {string} name\n * @param {!Object=} opt_data Event data.\n * @param {!CustomEventOptionsDef=} opt_options\n */\nexport function dispatchCustomEvent(node, name, opt_data, opt_options) {\n  const data = opt_data || {};\n  // Constructors of events need to come from the correct window. Sigh.\n  const event = node.ownerDocument.createEvent('Event');\n\n  // Technically .data is not a property of Event.\n  event.data = data;\n\n  const {bubbles, cancelable} = opt_options || DEFAULT_CUSTOM_EVENT_OPTIONS;\n  event.initEvent(name, bubbles, cancelable);\n  node.dispatchEvent(event);\n}\n\n/**\n * Ensures the child is contained by the parent, but not the parent itself.\n *\n * @param {!Node} parent\n * @param {!Node} child\n * @return {boolean}\n */\nexport function containsNotSelf(parent, child) {\n  return child !== parent && parent.contains(child);\n}\n\n/**\n * Helper method to get the json config from an element <script> tag\n * @param {!Element} element\n * @return {?JsonObject}\n * @throws {!Error} If element does not have exactly one <script> child\n * with type=\"application/json\", or if the <script> contents are not valid JSON.\n */\nexport function getChildJsonConfig(element) {\n  const scripts = childElementsByTag(element, 'script');\n  const {length} = scripts;\n  if (length !== 1) {\n    throw new Error(`Found ${length} <script> children. Expected 1.`);\n  }\n\n  const script = scripts[0];\n  if (!isJsonScriptTag(script)) {\n    throw new Error('<script> child must have type=\"application/json\"');\n  }\n\n  try {\n    return parseJson(script.textContent);\n  } catch {\n    throw new Error('Failed to parse <script> contents. Is it valid JSON?');\n  }\n}\n", "import {iterateCursor} from '#core/dom';\nimport {ancestorElementsByTag} from '#core/dom/query';\nimport {toArray} from '#core/types/array';\nimport {dict} from '#core/types/object';\n\n/**\n * Stub type until an AmpForm interface is available in typechecked-land.\n * Should be satisfied by `#extensions/amp-form/0.1/amp-form.AmpForm`\n * @typedef {?}\n */\nlet AmpFormDef;\n\n/** @const {string} */\nconst FORM_PROP_ = '__AMP_FORM';\n\n/**\n * @param {!Element} element\n * @return {AmpFormDef}\n */\nexport function formOrNullForElement(element) {\n  return element[FORM_PROP_] || null;\n}\n\n/**\n * @param {!Element} element\n * @param {!AmpFormDef} form\n */\nexport function setFormForElement(element, form) {\n  element[FORM_PROP_] = form;\n}\n\n/**\n * Returns form data in the passed-in form as an object.\n * Includes focused submit buttons.\n * @param {!HTMLFormElement} form\n * @return {!JsonObject}\n */\nexport function getFormAsObject(form) {\n  const {elements} = form;\n  const data = dict();\n  // <button> is handled separately\n  const submittableTagsRegex = /^(?:input|select|textarea)$/i;\n  // type=submit is handled separately\n  const unsubmittableTypesRegex = /^(?:submit|button|image|file|reset)$/i;\n  const checkableType = /^(?:checkbox|radio)$/i;\n\n  for (let i = 0; i < elements.length; i++) {\n    /**\n     * Real type is one of several, but we treat as any old object since we're\n     * testing which (if any) it matches\n     * https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/elements\n     * @type {?}\n     */\n    const input = elements[i];\n    const {checked, multiple, name, options, tagName, type, value} = input;\n    if (\n      !name ||\n      isDisabled(input) ||\n      !submittableTagsRegex.test(tagName) ||\n      unsubmittableTypesRegex.test(type) ||\n      (checkableType.test(type) && !checked)\n    ) {\n      continue;\n    }\n\n    if (data[name] === undefined) {\n      data[name] = [];\n    }\n\n    if (multiple) {\n      iterateCursor(options, (option) => {\n        if (option.selected) {\n          data[name].push(option.value);\n        }\n      });\n      continue;\n    }\n    data[name].push(value);\n  }\n\n  const submitButton = getSubmitButtonUsed(form);\n  if (submitButton?.name) {\n    const {name, value} = submitButton;\n    if (data[name] === undefined) {\n      data[name] = [];\n    }\n    data[name].push(value);\n  }\n\n  // Wait until the end to remove the empty values, since\n  // we don't know when evaluating any one input whether\n  // there will be or have already been inputs with the same names.\n  // e.g. We want to remove empty <select multiple name=x> but\n  // there could also be an <input name=x>. At the end we know if an empty name\n  // can be deleted.\n  Object.keys(data).forEach((key) => {\n    if (data[key].length == 0) {\n      delete data[key];\n    }\n  });\n\n  return data;\n}\n\n/**\n * Gets the submit button used to submit the form.\n * This searches through the form elements to find:\n * 1. The first submit button element OR\n * 2. a focused submit button, indicating it was specifically used to submit.\n * 3. null, if neither of the above is found.\n * @param {!HTMLFormElement} form\n * @return {?HTMLButtonElement}\n */\nexport function getSubmitButtonUsed(form) {\n  const {elements} = form;\n  const {activeElement} = form.ownerDocument;\n\n  const submitBtns = /** @type {!Array<!HTMLButtonElement>} */ (\n    toArray(elements).filter(isSubmitButton)\n  );\n  return submitBtns.includes(/** @type {?} */ (activeElement))\n    ? /** @type {HTMLButtonElement} */ (activeElement)\n    : submitBtns[0] || null;\n}\n\n/**\n * True if the given button can submit a form.\n * @param {!Element} element\n * @return {boolean}\n */\nfunction isSubmitButton(element) {\n  const {tagName, type} = /** @type {!HTMLButtonElement} */ (element);\n  return tagName == 'BUTTON' || type == 'submit';\n}\n\n/**\n * Checks if a field is disabled.\n * @param {!HTMLInputElement} element\n * @return {boolean}\n */\nexport function isDisabled(element) {\n  return (\n    element.disabled ||\n    ancestorElementsByTag(element, 'fieldset').some(\n      (el) => /** @type {!HTMLFieldSetElement} */ (el).disabled\n    )\n  );\n}\n\n/**\n * Checks if a form field is in its default state.\n * @param {!HTMLInputElement|!HTMLSelectElement} field\n * @return {boolean}\n */\nexport function isFieldDefault(field) {\n  switch (field.type) {\n    case 'select-multiple':\n    case 'select-one':\n      return toArray(/** @type {!HTMLSelectElement} */ (field).options).every(\n        ({defaultSelected, selected}) => selected === defaultSelected\n      );\n    case 'checkbox':\n    case 'radio':\n      return field.checked === field.defaultChecked;\n    default:\n      return field.value === field.defaultValue;\n  }\n}\n\n/**\n * Checks if a form field is empty. It expects a form field element,\n * i.e. `<input>`, `<textarea>`, or `<select>`.\n * @param {!HTMLInputElement} field\n * @throws {Error}\n * @return {boolean}\n */\nexport function isFieldEmpty(field) {\n  switch (field.tagName) {\n    case 'INPUT':\n      if (field.type == 'checkbox' || field.type == 'radio') {\n        return !field.checked;\n      } else {\n        return !field.value;\n      }\n    case 'TEXTAREA':\n      return !field.value;\n    case 'SELECT':\n      // dropdown menu has at least one option always selected\n      return false;\n    default:\n      throw new Error(\n        `isFieldEmpty: ${field.tagName} is not a supported field element.`\n      );\n  }\n}\n", "import {map} from '#core/types/object';\n\nconst QUERY_STRING_REGEX = /(?:^[#?]?|&)([^=&]+)(?:=([^&]*))?/g;\n\n/**\n * Tries to decode a URI component, falling back to opt_fallback (or an empty\n * string)\n *\n * @param {string} component\n * @param {string=} fallback\n * @return {string}\n */\nexport function tryDecodeUriComponent(component, fallback = '') {\n  try {\n    return decodeURIComponent(component);\n  } catch (e) {\n    return fallback;\n  }\n}\n\n/**\n * Parses the query string of an URL. This method returns a simple key/value\n * map. If there are duplicate keys the latest value is returned.\n *\n * @param {string} queryString\n * @return {!JsonObject}\n */\nexport function parseQueryString(queryString) {\n  const params = map();\n  if (!queryString) {\n    return params;\n  }\n\n  let match;\n  while ((match = QUERY_STRING_REGEX.exec(queryString))) {\n    const name = tryDecodeUriComponent(match[1], match[1]);\n    const value = match[2]\n      ? tryDecodeUriComponent(match[2].replace(/\\+/g, ' '), match[2])\n      : '';\n    params[name] = value;\n  }\n  return params;\n}\n\n/**\n * Parses the query # params.\n * @param {!Window=} opt_win\n * @return {!JsonObject}\n */\nexport function getHashParams(opt_win) {\n  const {location} = opt_win || self;\n  // location.originalHash is set by the viewer when it removes the fragment\n  // from the URL.\n  return parseQueryString(location['originalHash'] || location.hash);\n}\n", "/**\n * Allows for runtime configuration. Internally, the runtime should\n * use the src/config.js module for various constants. We can use the\n * AMP_CONFIG global to translate user-defined configurations to this\n * module.\n * @type {!Object<string, string>}\n */\nconst env = self.AMP_CONFIG || {};\n\nconst thirdPartyFrameRegex =\n  (typeof env['thirdPartyFrameRegex'] == 'string'\n    ? new RegExp(env['thirdPartyFrameRegex'])\n    : env['thirdPartyFrameRegex']) || /^d-\\d+\\.ampproject\\.net$/;\n\nconst cdnProxyRegex =\n  (typeof env['cdnProxyRegex'] == 'string'\n    ? new RegExp(env['cdnProxyRegex'])\n    : env['cdnProxyRegex']) ||\n  /^https:\\/\\/([a-zA-Z0-9_-]+\\.)?cdn\\.ampproject\\.org$/;\n\n/**\n * Check for a custom URL definition in special <meta> tags. Note that this does\n * not allow for distinct custom URLs in AmpDocShadow instances. The shell is\n * allowed to define one set of custom URLs via AMP_CONFIG (recommended) or by\n * including <meta> tags in the shell <head>. Those custom URLs then apply to\n * all AMP documents loaded in the shell.\n * @param {string} name\n * @return {?string}\n * @private\n */\nfunction getMetaUrl(name) {\n  // Avoid exceptions in unit tests\n  if (!self.document || !self.document.head) {\n    return null;\n  }\n\n  // Disallow on proxy origins\n  if (self.location && cdnProxyRegex.test(self.location.origin)) {\n    return null;\n  }\n\n  const metaEl = self.document.head./*OK*/ querySelector(\n    `meta[name=\"${name}\"]`\n  );\n  return (metaEl && metaEl.getAttribute('content')) || null;\n}\n\n/**\n * @typedef {{\n *   thirdParty: string,\n *   thirdPartyFrameHost: string,\n *   thirdPartyFrameRegex: !RegExp,\n *   cdn: string,\n *   cdnProxyRegex: !RegExp,\n *   localhostRegex: !RegExp,\n *   errorReporting: string,\n *   betaErrorReporting: string,\n *   localDev: boolean,\n *   trustedViewerHosts: !Array<!RegExp>,\n *   geoApi: ?string,\n * }}\n */\nexport const urls = {\n  thirdParty: env['thirdPartyUrl'] || 'https://3p.ampproject.net',\n  thirdPartyFrameHost: env['thirdPartyFrameHost'] || 'ampproject.net',\n  thirdPartyFrameRegex,\n  cdn:\n    env['cdnUrl'] || getMetaUrl('runtime-host') || 'https://cdn.ampproject.org',\n  /* Note that cdnProxyRegex is only ever checked against origins\n   * (proto://host[:port]) so does not need to consider path\n   */\n  cdnProxyRegex,\n  localhostRegex: /^https?:\\/\\/localhost(:\\d+)?$/,\n  errorReporting:\n    env['errorReportingUrl'] ||\n    'https://us-central1-amp-error-reporting.cloudfunctions.net/r',\n  betaErrorReporting:\n    env['betaErrorReportingUrl'] ||\n    'https://us-central1-amp-error-reporting.cloudfunctions.net/r-beta',\n  localDev: env['localDev'] || false,\n  /**\n   * These domains are trusted with more sensitive viewer operations such as\n   * propagating the referrer. If you believe your domain should be here,\n   * file the issue on GitHub to discuss. The process will be similar\n   * (but somewhat more stringent) to the one described in the [3p/README.md](\n   * https://github.com/ampproject/amphtml/blob/main/3p/README.md)\n   *\n   * {!Array<!RegExp>}\n   */\n  trustedViewerHosts: [\n    /(^|\\.)google\\.(com?|[a-z]{2}|com?\\.[a-z]{2}|cat)$/,\n    /(^|\\.)gmail\\.(com|dev)$/,\n  ],\n  // Optional fallback API if amp-geo is left unpatched\n  geoApi: env['geoApiUrl'] || getMetaUrl('amp-geo-api'),\n};\n\nexport const config = {\n  urls,\n};\n", "import * as coreMode from '#core/mode';\nimport {getHashParams} from '#core/types/string/url';\n\n/**\n * @typedef {{\n *   localDev: boolean,\n *   development: boolean,\n *   esm: boolean,\n *   test: boolean,\n *   rtvVersion: string,\n *   runtime: (null|string|undefined),\n *   a4aId: (null|string|undefined)\n * }}\n */\nexport let ModeDef;\n\n/**\n * `rtvVersion` is the prefixed version we serve off of the cdn.\n * The prefix denotes canary(00) or prod(01) or an experiment version ( > 01).\n * @type {string}\n */\nlet rtvVersion = '';\n\n/**\n * Provides info about the current app.\n * @param {?Window=} opt_win\n * @return {!ModeDef}\n */\nexport function getMode(opt_win) {\n  const win = opt_win || self;\n  if (win.__AMP_MODE) {\n    return win.__AMP_MODE;\n  }\n  return (win.__AMP_MODE = getMode_(win));\n}\n\n/**\n * Provides info about the current app.\n * @param {!Window} win\n * @return {!ModeDef}\n */\nfunction getMode_(win) {\n  const hashParams = getHashParams(win);\n\n  // The `minified`, `test` and `localDev` properties are replaced\n  // as boolean literals when we run `amp dist` without the `--fortesting`\n  // flags. This improved DCE on the production file we deploy as the code\n  // paths for localhost/testing/development are eliminated.\n  return {\n    localDev: coreMode.isLocalDev(win),\n    development: isModeDevelopment(win, hashParams),\n    esm: coreMode.isEsm(),\n    test: coreMode.isTest(win),\n    rtvVersion: getRtvVersion(win),\n  };\n}\n\n/**\n * Retrieve the `rtvVersion` which will have a numeric prefix\n * denoting canary/prod/experiment (unless `isLocalDev` is true).\n *\n * @param {!Window} win\n * @return {string}\n */\nfunction getRtvVersion(win) {\n  // Ignore memoized copy during testing to allow override.\n  if (!rtvVersion || coreMode.isTest(win)) {\n    // Currently `internalRuntimeVersion` and thus `mode.version` contain only\n    // major version. The full version however must also carry the minor version.\n    // We will default to production default `01` minor version for now.\n    // TODO(erwinmombay): decide whether internalRuntimeVersion should contain\n    // minor version.\n    rtvVersion = win.AMP_CONFIG?.v || `01${coreMode.version()}`;\n  }\n  return rtvVersion;\n}\n\n/**\n * Triggers validation or enable pub level logging. Validation can be\n * bypassed via #validate=0.\n * Note that AMP_DEV_MODE flag is used for testing purposes.\n * @param {!Window} win\n * @param {!JsonObject=} opt_hashParams\n * @return {boolean}\n */\nexport function isModeDevelopment(win, opt_hashParams) {\n  const devModes = ['1', 'actions', 'amp', 'amp4ads', 'amp4email'];\n  const devParam = opt_hashParams || getHashParams(win);\n  return devModes.includes(devParam['development']) || !!win.AMP_DEV_MODE;\n}\n\n/**\n * @param {!Window} win\n * @return {string}\n * @visibleForTesting\n */\nexport function getRtvVersionForTesting(win) {\n  return getRtvVersion(win);\n}\n\n/** @visibleForTesting */\nexport function resetRtvVersionForTesting() {\n  rtvVersion = '';\n}\n", "import * as mode from '#core/mode';\n\nimport {urls} from '../config';\nimport {getMode} from '../mode';\n\nconst CUSTOM_TEMPLATES = ['amp-mustache'];\nconst LATEST_VERSION = 'latest';\n\n/**\n * Calculate the base url for any scripts.\n * @param {!Location} location The window's location\n * @param {boolean=} opt_isLocalDev\n * @return {string}\n */\nexport function calculateScriptBaseUrl(location, opt_isLocalDev) {\n  if (opt_isLocalDev) {\n    let prefix = `${location.protocol}//${location.host}`;\n    if (\n      location.protocol == 'about:' ||\n      location.protocol == 'blob:' ||\n      location.protocol == 'data:'\n    ) {\n      prefix = '';\n    }\n    return `${prefix}/dist`;\n  }\n  return urls.cdn;\n}\n\n/**\n * Calculate script url for an extension.\n * @param {!Location} location The window's location\n * @param {string} extensionId\n * @param {string} version\n * @param {boolean=} opt_isLocalDev\n * @return {string}\n */\nexport function calculateExtensionScriptUrl(\n  location,\n  extensionId,\n  version,\n  opt_isLocalDev\n) {\n  const fileExtension = mode.isEsm() ? '.mjs' : '.js';\n  const base = calculateScriptBaseUrl(location, opt_isLocalDev);\n  const rtv = getMode().rtvVersion;\n  const extensionVersion = version ? '-' + version : '';\n  return `${base}/rtv/${rtv}/v0/${extensionId}${extensionVersion}${fileExtension}`;\n}\n\n/**\n * Calculate script url for an entry point.\n * If `opt_rtv` is true, returns the URL matching the current RTV.\n * @param {!Location} location The window's location\n * @param {string} entryPoint\n * @param {boolean=} isLocalDev\n * @param {boolean=} opt_rtv\n * @return {string}\n */\nexport function calculateEntryPointScriptUrl(\n  location,\n  entryPoint,\n  isLocalDev,\n  opt_rtv\n) {\n  const fileExtension = mode.isEsm() ? '.mjs' : '.js';\n  const base = calculateScriptBaseUrl(location, isLocalDev);\n  if (isLocalDev) {\n    return `${base}/${entryPoint}${fileExtension}`;\n  }\n  if (opt_rtv) {\n    return `${base}/rtv/${getMode().rtvVersion}/${entryPoint}${fileExtension}`;\n  }\n  return `${base}/${entryPoint}${fileExtension}`;\n}\n\n/**\n * Parse the extension version from a given script URL.\n * @param {string} scriptUrl\n * @return {?{extensionId: string, extensionVersion: string}}\n */\nexport function parseExtensionUrl(scriptUrl) {\n  if (!scriptUrl) {\n    return null;\n  }\n  // Note that the \"(\\.max)?\" group only applies to local dev.\n  const matches = scriptUrl.match(\n    /^(.*)\\/(.*)-([0-9.]+|latest)(\\.max)?\\.(?:js|mjs)$/i\n  );\n  const extensionId = matches ? matches[2] : undefined;\n  const extensionVersion = matches ? matches[3] : undefined;\n  if (!extensionId || !extensionVersion) {\n    return null;\n  }\n  return {extensionId, extensionVersion};\n}\n\n/**\n * Create the missing amp extension HTML script element.\n * @param {!Window} win\n * @param {string} extensionId\n * @param {string} version\n * @return {!Element} Script object\n */\nexport function createExtensionScript(win, extensionId, version) {\n  const scriptElement = win.document.createElement('script');\n  scriptElement.async = true;\n  if (isIntermediateExtension(extensionId)) {\n    version = '';\n  } else {\n    scriptElement.setAttribute(\n      CUSTOM_TEMPLATES.indexOf(extensionId) >= 0\n        ? 'custom-template'\n        : 'custom-element',\n      extensionId\n    );\n  }\n  scriptElement.setAttribute('data-script', extensionId);\n  scriptElement.setAttribute('i-amphtml-inserted', '');\n  if (mode.isEsm()) {\n    scriptElement.setAttribute('type', 'module');\n  }\n\n  // Propagate nonce to all generated script tags.\n  const currentScript = win.document.head.querySelector('script[nonce]');\n  if (currentScript) {\n    scriptElement.setAttribute('nonce', currentScript.getAttribute('nonce'));\n  }\n\n  // Allow error information to be collected\n  // https://github.com/ampproject/amphtml/issues/7353\n  scriptElement.setAttribute('crossorigin', 'anonymous');\n  let loc = win.location;\n  if (getMode(win).test && win.testLocation) {\n    loc = win.testLocation;\n  }\n  const scriptSrc = calculateExtensionScriptUrl(\n    loc,\n    extensionId,\n    version,\n    getMode(win).localDev\n  );\n  scriptElement.src = scriptSrc;\n  return scriptElement;\n}\n\n/**\n * Returns the extension <script> element and attribute for the given\n * extension ID, if it exists. Otherwise, returns null.\n * @param {!Window} win\n * @param {string} extensionId\n * @param {string} version\n * @param {boolean} latest\n * @param {boolean=} includeInserted If true, includes script elements that\n *   are inserted by the runtime dynamically. Default is true.\n * @return {!Array<!Element>}\n */\nexport function getExtensionScripts(\n  win,\n  extensionId,\n  version,\n  latest,\n  includeInserted = true\n) {\n  // Always ignore <script> elements that have a mismatched RTV.\n  const modifier =\n    ':not([i-amphtml-loaded-new-version])' +\n    (includeInserted ? '' : ':not([i-amphtml-inserted])');\n  // We have to match against \"src\" because a few extensions, such as\n  // \"amp-viewer-integration\", do not have \"custom-element\" attribute.\n  const matches = win.document.head./*OK*/ querySelectorAll(\n    `script[src*=\"/${extensionId}-\"]${modifier}`\n  );\n  const filtered = [];\n  for (let i = 0; i < matches.length; i++) {\n    const match = matches[i];\n    const urlParts = parseExtensionUrl(match.src);\n    if (!urlParts) {\n      continue;\n    }\n    const {\n      extensionId: scriptExtensionId,\n      extensionVersion: scriptExtensionVersion,\n    } = urlParts;\n    if (\n      scriptExtensionId == extensionId &&\n      (isIntermediateExtension(extensionId) ||\n        scriptExtensionVersion == version ||\n        (scriptExtensionVersion == LATEST_VERSION && latest))\n    ) {\n      filtered.push(match);\n    }\n  }\n  return filtered;\n}\n\n/**\n * Get list of all the extension JS files.\n * @param {HTMLHeadElement|Element|ShadowRoot|Document} head\n * @return {!Array<{script: HTMLScriptElement, extensionId: string, extensionVersion: string}>}\n */\nexport function extensionScriptsInNode(head) {\n  // ampdoc.getHeadNode() can return null.\n  if (!head) {\n    return [];\n  }\n  // Note: Some extensions don't have [custom-element] or [custom-template]\n  // e.g. amp-viewer-integration.\n  const list = head.querySelectorAll(\n    'script[custom-element],script[custom-template]'\n  );\n  const scripts = [];\n  for (let i = 0; i < list.length; i++) {\n    const script = list[i];\n    const extensionId =\n      script.getAttribute('custom-element') ||\n      script.getAttribute('custom-template');\n    const urlParts = parseExtensionUrl(script.src);\n    if (extensionId && urlParts) {\n      scripts.push({\n        script,\n        extensionId,\n        extensionVersion: urlParts.extensionVersion,\n      });\n    }\n  }\n  return scripts;\n}\n\n/**\n * Verifies that an extension script is present in head for\n * installation.\n * @param {!Window} win\n * @param {string} id\n * @param {string} version\n * @return {boolean}\n */\nexport function extensionScriptInNode(win, id, version) {\n  return extensionScriptsInNode(win.document.head).some(\n    ({extensionId, extensionVersion}) =>\n      id == extensionId && version == extensionVersion\n  );\n}\n\n/**\n * @param {string} extensionId\n * @return {boolean}\n */\nfunction isIntermediateExtension(extensionId) {\n  return extensionId.startsWith('_');\n}\n", "/** @fileoverview Helpers to wrap functions. */\n\n/**\n * Creates a function that is evaluated only once and returns the cached result\n * subsequently.\n *\n * Please note that `once` only takes the function definition into account,\n * so it will return the same cached value even when the arguments are\n * different.\n *\n * @param {function(...):T} fn\n * @return {function(...):T}\n * @template T\n */\nexport function once(fn) {\n  let evaluated = false;\n  let retValue = null;\n  let callback = fn;\n  return (...args) => {\n    if (!evaluated) {\n      retValue = callback.apply(self, args);\n      evaluated = true;\n      callback = null; // GC\n    }\n    return retValue;\n  };\n}\n\n/**\n * Wraps a given callback and applies a rate limit.\n * It throttles the calls so that no consequent calls have time interval\n * smaller than the given minimal interval.\n *\n * @param {!Window} win\n * @param {function(...T):R} callback\n * @param {number} minInterval the minimum time interval in millisecond\n * @return {function(...T)}\n * @template T\n * @template R\n */\nexport function throttle(win, callback, minInterval) {\n  let locker = 0;\n  let nextCallArgs = null;\n\n  /**\n   * @param {!Object} args\n   */\n  function fire(args) {\n    nextCallArgs = null;\n    // Lock the fire for minInterval milliseconds\n    locker = win.setTimeout(waiter, minInterval);\n\n    callback.apply(null, args);\n  }\n\n  /**\n   * Waiter function\n   */\n  function waiter() {\n    locker = 0;\n    // If during the period there're invocations queued up, fire once.\n    if (nextCallArgs) {\n      fire(nextCallArgs);\n    }\n  }\n\n  return function (...args) {\n    if (locker) {\n      nextCallArgs = args;\n    } else {\n      fire(args);\n    }\n  };\n}\n\n/**\n * Wraps a given callback and applies a wait timer, so that minInterval\n * milliseconds must pass since the last call before the callback is actually\n * invoked.\n *\n * @param {!Window} win\n * @param {function(...T):R} callback\n * @param {number} minInterval the minimum time interval in millisecond\n * @return {function(...T)}\n * @template T\n * @template R\n */\nexport function debounce(win, callback, minInterval) {\n  let locker = 0;\n  let timestamp = 0;\n  let nextCallArgs = null;\n\n  /**\n   * @param {?Array} args\n   */\n  function fire(args) {\n    nextCallArgs = null;\n    callback.apply(null, args);\n  }\n\n  /**\n   * Wait function for debounce\n   */\n  function waiter() {\n    locker = 0;\n    const remaining = minInterval - (win.Date.now() - timestamp);\n    if (remaining > 0) {\n      locker = win.setTimeout(waiter, remaining);\n    } else {\n      fire(nextCallArgs);\n    }\n  }\n\n  return function (...args) {\n    timestamp = win.Date.now();\n    nextCallArgs = args;\n    if (!locker) {\n      locker = win.setTimeout(waiter, minInterval);\n    }\n  };\n}\n", "import * as assertions from '#core/assert/base';\nimport {\n  createError,\n  createExpectedError,\n  duplicateErrorIfNecessary,\n} from '#core/error';\nimport {\n  USER_ERROR_EMBED_SENTINEL,\n  USER_ERROR_SENTINEL,\n  elementStringOrPassThru,\n  isUserErrorMessage,\n  stripUserError,\n} from '#core/error/message-helpers';\nimport * as mode from '#core/mode';\nimport {isArray, isString} from '#core/types';\nimport {once} from '#core/types/function';\nimport {getHashParams} from '#core/types/string/url';\n\nimport {urls} from '../config';\nimport {getMode} from '../mode';\n\nconst noop = () => {};\n\n// These are exported here despite being defined elswhere to avoid updating\n// imports across many files for now.\nexport {USER_ERROR_SENTINEL, isUserErrorMessage};\n\n/**\n * Sets reportError function. Called from error-reporting.js to break cyclic\n * dependency.\n * @param {function(this:Window, Error, (?Element)=): ?|undefined} fn\n */\nexport function setReportError(fn) {\n  self.__AMP_REPORT_ERROR = fn;\n}\n\n/**\n * @enum {number}\n */\nexport const LogLevel = {\n  OFF: 0,\n  ERROR: 1,\n  WARN: 2,\n  INFO: 3,\n  FINE: 4,\n};\n\n/**\n * @type {!LogLevel|undefined}\n * @private\n */\nlet levelOverride_ = undefined;\n\n/**\n * @param {!LogLevel} level\n */\nexport function overrideLogLevel(level) {\n  levelOverride_ = level;\n}\n\n/**\n * Prefixes `internalRuntimeVersion` with the `01` channel signifier (for prod.) for\n * extracted message URLs.\n * (Specific channel is irrelevant: message tables are invariant on internal version.)\n * @return {string}\n */\nconst messageUrlRtv = () => `01${mode.version()}`;\n\n/**\n * Gets a URL to display a message on amp.dev.\n * @param {string} id\n * @param {!Array} interpolatedParts\n * @return {string}\n */\nconst externalMessageUrl = (id, interpolatedParts) =>\n  interpolatedParts.reduce(\n    (prefix, arg) => `${prefix}&s[]=${messageArgToEncodedComponent(arg)}`,\n    `https://log.amp.dev/?v=${messageUrlRtv()}&id=${encodeURIComponent(id)}`\n  );\n\n/**\n * URL to simple log messages table JSON file, which contains an Object<string, string>\n * which maps message id to full message template.\n * @return {string}\n */\nconst externalMessagesSimpleTableUrl = () =>\n  `${urls.cdn}/rtv/${messageUrlRtv()}/log-messages.simple.json`;\n\n/**\n * @param {*} arg\n * @return {string}\n */\nconst messageArgToEncodedComponent = (arg) =>\n  encodeURIComponent(String(elementStringOrPassThru(arg)));\n\n/**\n * @param {!Window=} opt_win\n * @return {number}\n */\nexport const logHashParam = (opt_win) =>\n  parseInt(getHashParams(opt_win)['log'], 10);\n\n/**\n * Logging class. Use of sentinel string instead of a boolean to check user/dev\n * errors because errors could be rethrown by some native code as a new error,\n * and only a message would survive. Also, some browser don\u2019t support a 5th\n * error object argument in window.onerror. List of supporting browser can be\n * found here:\n * https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html\n * @final\n * @private Visible for testing only.\n */\nexport class Log {\n  /**\n   * opt_suffix will be appended to error message to identify the type of the\n   * error message. We can't rely on the error object to pass along the type\n   * because some browsers do not have this param in its window.onerror API.\n   * See:\n   * https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html\n   *\n   * @param {!Window} win\n   * @param {function(number, boolean):!LogLevel} levelFunc\n   * @param {string=} opt_suffix\n   */\n  constructor(win, levelFunc, opt_suffix = '') {\n    /**\n     * In tests we use the main test window instead of the iframe where\n     * the tests runs because only the former is relayed to the console.\n     * @const {!Window}\n     */\n    this.win = getMode().test && win.__AMP_TEST_IFRAME ? win.parent : win;\n\n    /** @private @const {function(number, boolean):!LogLevel} */\n    this.levelFunc_ = levelFunc;\n\n    /** @private @const {!LogLevel} */\n    this.level_ = this.defaultLevel_();\n\n    /** @private @const {string} */\n    this.suffix_ = opt_suffix;\n\n    /** @private {?JsonObject} */\n    this.messages_ = null;\n\n    this.fetchExternalMessagesOnce_ = once(() => {\n      win\n        .fetch(externalMessagesSimpleTableUrl())\n        .then((response) => response.json(), noop)\n        .then((opt_messages) => {\n          if (opt_messages) {\n            this.messages_ = /** @type {!JsonObject} */ (opt_messages);\n          }\n        });\n    });\n\n    // This bound assertion function is capable of handling the format used when\n    // error/assertion messages are extracted. This logic hasn't yet been\n    // migrated to an AMP-independent form for use in core. This binding allows\n    // Log assertion helpers to maintain message-extraction capabilities until\n    // that logic can be moved to core.\n    this.boundAssertFn_ = /** @type {!assertions.AssertionFunctionDef} */ (\n      this.assert.bind(this)\n    );\n  }\n\n  /**\n   * @return {!LogLevel}\n   * @private\n   */\n  defaultLevel_() {\n    const {win} = this;\n    // No console - can't enable logging.\n    if (\n      !win.console?.log ||\n      // Logging has been explicitly disabled.\n      logHashParam(win) == 0\n    ) {\n      return LogLevel.OFF;\n    }\n\n    // Logging is enabled for tests directly.\n    if (getMode().test && win.ENABLE_LOG) {\n      return LogLevel.FINE;\n    }\n\n    // LocalDev by default allows INFO level, unless overriden by `#log`.\n    if (getMode().localDev) {\n      return LogLevel.INFO;\n    }\n\n    return this.defaultLevelWithFunc_();\n  }\n\n  /**\n   * @param {!Window=} opt_win provided for testing\n   * @return {!LogLevel}\n   * @private\n   */\n  defaultLevelWithFunc_(opt_win) {\n    // Delegate to the specific resolver.\n    return this.levelFunc_(logHashParam(opt_win), getMode().development);\n  }\n\n  /**\n   * @param {string} tag\n   * @param {!LogLevel} level\n   * @param {!Array} messages\n   * @return {boolean} true if a the message was logged\n   */\n  msg_(tag, level, messages) {\n    if (level > (levelOverride_ ?? this.level_)) {\n      return false;\n    }\n\n    const cs = this.win.console;\n    const fn =\n      {\n        [LogLevel.ERROR]: cs.error,\n        [LogLevel.INFO]: cs.info,\n        [LogLevel.WARN]: cs.warn,\n      }[level] ?? cs.log;\n\n    const args = this.maybeExpandMessageArgs_(messages);\n    // Prefix console message with \"[tag]\".\n    const prefix = `[${tag}]`;\n    if (isString(args[0])) {\n      // Prepend string to avoid breaking string substitutions e.g. %s.\n      args[0] = prefix + ' ' + args[0];\n    } else {\n      args.unshift(prefix);\n    }\n    fn.apply(cs, args);\n\n    return true;\n  }\n\n  /**\n   * Reports a fine-grained message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  fine(tag, ...args) {\n    this.msg_(tag, LogLevel.FINE, args);\n  }\n\n  /**\n   * Reports a informational message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  info(tag, ...args) {\n    this.msg_(tag, LogLevel.INFO, args);\n  }\n\n  /**\n   * Reports a warning message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  warn(tag, ...args) {\n    this.msg_(tag, LogLevel.WARN, args);\n  }\n\n  /**\n   * Reports an error message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  error(tag, ...args) {\n    if (!this.msg_(tag, LogLevel.ERROR, args)) {\n      const error = this.createError.apply(this, args);\n      error.name = tag || error.name;\n      self.__AMP_REPORT_ERROR?.(error);\n    }\n  }\n\n  /**\n   * Reports an error message and marks with an expected property. If the\n   * logging is disabled, the error is rethrown asynchronously.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  expectedError(tag, ...args) {\n    if (!this.msg_(tag, LogLevel.ERROR, args)) {\n      self.__AMP_REPORT_ERROR?.(this.createExpectedError.apply(this, args));\n    }\n  }\n\n  /**\n   * Creates an error object.\n   * @param {...*} var_args\n   * @return {!Error}\n   */\n  createError(var_args) {\n    return this.setErrorSuffix_(createError.apply(null, arguments));\n  }\n\n  /**\n   * Creates an error object with its expected property set to true.\n   * @param {...*} var_args\n   * @return {!Error}\n   */\n  createExpectedError(var_args) {\n    return this.setErrorSuffix_(createExpectedError.apply(null, arguments));\n  }\n\n  /**\n   * @param {!Error} error\n   * @return {!Error}\n   * @private\n   */\n  setErrorSuffix_(error) {\n    error = duplicateErrorIfNecessary(error);\n\n    if (this.suffix_) {\n      if (!error.message) {\n        error.message = this.suffix_;\n      } else if (error.message.indexOf(this.suffix_) == -1) {\n        error.message += this.suffix_;\n      }\n    } else if (isUserErrorMessage(error.message)) {\n      error.message = stripUserError(error.message);\n    }\n\n    return error;\n  }\n\n  /**\n   * @param {!Array} args\n   * @return {!Array}\n   * @private\n   */\n  maybeExpandMessageArgs_(args) {\n    return isArray(args[0])\n      ? this.expandMessageArgs_(/** @type {!Array} */ (args[0]))\n      : args;\n  }\n\n  /**\n   * Either redirects a pair of (errorId, ...args) to a URL where the full\n   * message is displayed, or displays it from a fetched table.\n   *\n   * This method is used by the output of the `transform-log-methods` babel\n   * plugin. It should not be used directly. Use the (*error|assert*|info|warn)\n   * methods instead.\n   *\n   * @param {!Array} parts\n   * @return {!Array}\n   * @private\n   */\n  expandMessageArgs_(parts) {\n    // First value should exist.\n    const id = parts.shift();\n    // Best effort fetch of message template table.\n    // Since this is async, the first few logs might be indirected to a URL even\n    // if in development mode. Message table is ~small so this should be a short\n    // gap.\n    if (getMode(this.win).development) {\n      this.fetchExternalMessagesOnce_();\n    }\n\n    return this.messages_?.[id]\n      ? [this.messages_[id]].concat(parts)\n      : [`More info at ${externalMessageUrl(id, parts)}`];\n  }\n\n  /**\n   * Throws an error if the first argument isn't trueish.\n   *\n   * Supports argument substitution into the message via %s placeholders.\n   *\n   * Throws an error object that has two extra properties:\n   * - associatedElement: This is the first element provided in the var args.\n   *   It can be used for improved display of error messages.\n   * - messageArray: The elements of the substituted message as non-stringified\n   *   elements in an array. When e.g. passed to console.error this yields\n   *   native displays of things like HTML elements.\n   *\n   * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n   *     not evaluate to true.\n   * @param {!Array|string=} opt_message The assertion message\n   * @param {...*} var_args Arguments substituted into %s in the message.\n   * @return {T} The value of shouldBeTrueish.\n   * @throws {!Error} When `value` is falsey.\n   * @template T\n   * @closurePrimitive {asserts.truthy}\n   */\n  assert(shouldBeTrueish, opt_message, var_args) {\n    if (isArray(opt_message)) {\n      return this.assert.apply(\n        this,\n        [shouldBeTrueish].concat(\n          this.expandMessageArgs_(/** @type {!Array} */ (opt_message))\n        )\n      );\n    }\n\n    return assertions.assert.apply(\n      null,\n      [this.suffix_].concat(Array.prototype.slice.call(arguments))\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't an Element\n   *\n   * Otherwise see `assert` for usage\n   *\n   * @param {*} shouldBeElement\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {!Element} The value of shouldBeTrueish.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertElement(shouldBeElement, opt_message) {\n    return assertions.assertElement(\n      this.boundAssertFn_,\n      shouldBeElement,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't a string. The string can\n   * be empty.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeString\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {string} The string value. Can be an empty string.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertString(shouldBeString, opt_message) {\n    return assertions.assertString(\n      this.boundAssertFn_,\n      shouldBeString,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't a number. The allowed values\n   * include `0` and `NaN`.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeNumber\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {number} The number value. The allowed values include `0`\n   *   and `NaN`.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertNumber(shouldBeNumber, opt_message) {\n    return assertions.assertNumber(\n      this.boundAssertFn_,\n      shouldBeNumber,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument is not an array.\n   * The array can be empty.\n   *\n   * @param {*} shouldBeArray\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {!Array} The array value\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertArray(shouldBeArray, opt_message) {\n    return assertions.assertArray(\n      this.boundAssertFn_,\n      shouldBeArray,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't a boolean.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeBoolean\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {boolean} The boolean value.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertBoolean(shouldBeBoolean, opt_message) {\n    return assertions.assertBoolean(\n      this.boundAssertFn_,\n      shouldBeBoolean,\n      opt_message\n    );\n  }\n}\n\n/**\n * Cache for logs. We do not use a Service since the service module depends\n * on Log and closure literally can't even.\n * @type {{user: ?Log, dev: ?Log, userForEmbed: ?Log}}\n */\nself.__AMP_LOG = self.__AMP_LOG || {\n  user: null,\n  dev: null,\n  userForEmbed: null,\n};\n\nconst logs = self.__AMP_LOG;\n\n/**\n * Eventually holds a constructor for Log objects. Lazily initialized, so we\n * can avoid ever referencing the real constructor except in JS binaries\n * that actually want to include the implementation.\n * @type {?typeof Log}\n */\nlet logConstructor = null;\n\n/**\n * Initializes log constructor.\n */\nexport function initLogConstructor() {\n  logConstructor = Log;\n  // Initialize instances for use. If a binary (an extension for example) that\n  // does not call `initLogConstructor` invokes `dev()` or `user()` earlier than\n  // the binary that does call `initLogConstructor` (amp.js), the extension will\n  // throw an error as that extension will never be able to initialize the log\n  // instances and we also don't want it to call `initLogConstructor` either\n  // (since that will cause the Log implementation to be bundled into that\n  // binary). So we must initialize the instances eagerly so that they are ready\n  // for use (stored globally) after the main binary calls `initLogConstructor`.\n  dev();\n  user();\n}\n\n/**\n * Resets log constructor for testing.\n */\nexport function resetLogConstructorForTesting() {\n  logConstructor = null;\n}\n\n/**\n * Calls the log constructor with a given level function and suffix.\n * @param {function(number, boolean):!LogLevel} levelFunc\n * @param {string=} opt_suffix\n * @return {!Log}\n */\nfunction callLogConstructor(levelFunc, opt_suffix) {\n  if (!logConstructor) {\n    throw new Error('failed to call initLogConstructor');\n  }\n  return new logConstructor(self, levelFunc, opt_suffix);\n}\n\n/**\n * Publisher level log.\n *\n * Enabled in the following conditions:\n *  1. Not disabled using `#log=0`.\n *  2. Development mode is enabled via `#development=1` or logging is explicitly\n *     enabled via `#log=D` where D >= 1.\n *  3. AMP.setLogLevel(D) is called, where D >= 1.\n *\n * @param {!Element=} opt_element\n * @return {!Log}\n */\nexport function user(opt_element) {\n  // logs.user must exist first to perform the logs.user.win check below\n  if (!logs.user) {\n    logs.user = getUserLogger(USER_ERROR_SENTINEL);\n  }\n\n  if (isFromEmbed(logs.user.win, opt_element)) {\n    return (\n      logs.userForEmbed ||\n      (logs.userForEmbed = getUserLogger(USER_ERROR_EMBED_SENTINEL))\n    );\n  }\n  return logs.user;\n}\n\n/**\n * Getter for user logger\n * @param {string=} suffix\n * @return {!Log}\n */\nfunction getUserLogger(suffix) {\n  return callLogConstructor(\n    (logNum, development) =>\n      development || logNum >= 1 ? LogLevel.FINE : LogLevel.WARN,\n    suffix\n  );\n}\n\n/**\n * AMP development log. Calls to `devLog().assert` and `dev.fine` are stripped\n * in the PROD binary. However, `devLog().assert` result is preserved in either\n * case.\n *\n * Enabled in the following conditions:\n *  1. Not disabled using `#log=0`.\n *  2. Logging is explicitly enabled via `#log=D`, where D >= 2.\n *  3. AMP.setLogLevel(D) is called, where D >= 2.\n *\n * @return {!Log}\n */\nexport function dev() {\n  return (\n    logs.dev ||\n    (logs.dev = callLogConstructor((logNum) =>\n      logNum >= 3 ? LogLevel.FINE : logNum >= 2 ? LogLevel.INFO : LogLevel.OFF\n    ))\n  );\n}\n\n/**\n * @param {!Window} win\n * @param {!Element=} opt_element\n * @return {boolean} isEmbed\n */\nfunction isFromEmbed(win, opt_element) {\n  return opt_element && opt_element.ownerDocument.defaultView != win;\n}\n\n/**\n * Throws an error if the first argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - associatedElement: This is the first element provided in the var args.\n *   It can be used for improved display of error messages.\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n *\n * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n *     not evaluate to true.\n * @param {!Array|string=} opt_message The assertion message\n * @param {*=} opt_1 Optional argument (Var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {T} The value of shouldBeTrueish.\n * @throws {!Error} When `shouldBeTrueish` is falsey.\n * @template T\n * @closurePrimitive {asserts.truthy}\n */\nexport function devAssert(\n  shouldBeTrueish,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  if (mode.isMinified()) {\n    return shouldBeTrueish;\n  }\n  if (self.__AMP_ASSERTION_CHECK) {\n    // This will never execute regardless, but will be included on unminified\n    // builds. It will be DCE'd away from minified builds, and so can be used to\n    // validate that Babel is properly removing dev assertions in minified\n    // builds.\n    console /*OK*/\n      .log('__devAssert_sentinel__');\n  }\n\n  return dev()./*Orig call*/ assert(\n    shouldBeTrueish,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n\n/**\n * Throws an error if the first argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - associatedElement: This is the first element provided in the var args.\n *   It can be used for improved display of error messages.\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n *\n * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n *     not evaluate to true.\n * @param {!Array|string=} opt_message The assertion message\n * @param {*=} opt_1 Optional argument (Var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {T} The value of shouldBeTrueish.\n * @throws {!Error} When `shouldBeTrueish` is falsey.\n * @template T\n * @closurePrimitive {asserts.truthy}\n */\nexport function userAssert(\n  shouldBeTrueish,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  return user()./*Orig call*/ assert(\n    shouldBeTrueish,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n", "/**\n * @fileoverview Registration and getter functions for AMP services.\n *\n * Invariant: Service getters never return null for registered services.\n */\n\nimport {Deferred} from '#core/data-structures/promise';\nimport {getWin} from '#core/window';\n\nimport {dev, devAssert} from '#utils/log';\n\n/**\n * Holds info about a service.\n * - obj: Actual service implementation when available.\n * - promise: Promise for the obj.\n * - resolve: Function to resolve the promise with the object.\n * - context: Argument for ctor, either a window or an ampdoc.\n * - ctor: Function that constructs and returns the service.\n * @typedef {{\n *   obj: (?Object),\n *   promise: (?Promise),\n *   resolve: (?function(!Object)),\n *   reject: (?function((*))),\n *   context: (?Window|?./service/ampdoc-impl.AmpDoc),\n *   ctor: (function(new:Object, !Window)|\n *          function(new:Object, !./service/ampdoc-impl.AmpDoc)),\n * }}\n */\nlet ServiceHolderDef;\n\n/**\n * This interface provides a `dispose` method that will be called by\n * runtime when a service needs to be disposed of.\n * @interface\n */\nexport class Disposable {\n  /**\n   * Instructs the service to release any resources it might be holding. Can\n   * be called only once in the lifecycle of a service.\n   */\n  dispose() {}\n}\n\n/**\n * Installs a service override on amp-doc level.\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {string} id\n * @param {!Object} service The service.\n */\nexport function installServiceInEmbedDoc(ampdoc, id, service) {\n  registerServiceInternal(\n    getAmpdocServiceHolder(ampdoc),\n    ampdoc,\n    id,\n    function () {\n      return service;\n    },\n    /* override */ true\n  );\n}\n\n/**\n * Installs a service override in the scope of an embedded window.\n * @param {!Window} embedWin\n * @param {string} id\n * @param {function(new:Object, !Window)} constructor\n */\nexport function registerServiceBuilderInEmbedWin(embedWin, id, constructor) {\n  registerServiceInternal(\n    embedWin,\n    embedWin,\n    id,\n    constructor,\n    /* override */ true\n  );\n}\n\n/**\n * Registers a service given a class to be used as implementation.\n * @param {!Window} win\n * @param {string} id of the service.\n * @param {function(new:Object, !Window)} constructor\n * @param {boolean=} opt_instantiate Whether to immediately create the service\n */\nexport function registerServiceBuilder(win, id, constructor, opt_instantiate) {\n  win = getTopWindow(win);\n  registerServiceInternal(win, win, id, constructor);\n  if (opt_instantiate) {\n    getServiceInternal(win, id);\n  }\n}\n\n/**\n * Returns a service and registers it given a class to be used as\n * implementation.\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @param {string} id of the service.\n * @param {function(new:Object, !./service/ampdoc-impl.AmpDoc)} constructor\n * @param {boolean=} opt_instantiate Whether to immediately create the service\n */\nexport function registerServiceBuilderForDoc(\n  nodeOrDoc,\n  id,\n  constructor,\n  opt_instantiate\n) {\n  const ampdoc = getAmpdoc(nodeOrDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  registerServiceInternal(holder, ampdoc, id, constructor);\n  if (opt_instantiate) {\n    getServiceInternal(holder, id);\n  }\n}\n\n/**\n * Reject a service promise.\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @param {string} id\n * @param {*} error\n */\nexport function rejectServicePromiseForDoc(nodeOrDoc, id, error) {\n  const ampdoc = getAmpdoc(nodeOrDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  rejectServicePromiseInternal(holder, id, error);\n}\n\n/**\n * Returns a service for the given id and window (a per-window singleton). Users\n * should typically wrap this as a special purpose function (e.g.\n * `Services.vsyncFor(win)`) for type safety and because the factory should not\n * be passed around.\n * @param {!Window} win\n * @param {string} id of the service.\n * @template T\n * @return {T}\n */\nexport function getService(win, id) {\n  win = getTopWindow(win);\n  return getServiceInternal(win, id);\n}\n\n/**\n * Returns a service for the given id and window (a per-window singleton). But\n * it looks in the immediate window scope, not the top-level window.\n * @param {!Window} win\n * @param {string} id of the service.\n * @template T\n * @return {T}\n */\nexport function getServiceInEmbedWin(win, id) {\n  return getServiceInternal(win, id);\n}\n\n/**\n * Returns a promise for a service for the given id and window. Also expects an\n * element that has the actual implementation. The promise resolves when the\n * implementation loaded. Users should typically wrap this as a special purpose\n * function (e.g. `Services.vsyncFor(win)`) for type safety and because the\n * factory should not be passed around.\n * @param {!Window} win\n * @param {string} id of the service.\n * @return {!Promise<!Object>}\n */\nexport function getServicePromise(win, id) {\n  return getServicePromiseInternal(win, id);\n}\n\n/**\n * Returns a service or null with the given id.\n * @param {!Window} win\n * @param {string} id\n * @return {?Object} The service.\n */\nexport function getExistingServiceOrNull(win, id) {\n  win = getTopWindow(win);\n  if (isServiceRegistered(win, id)) {\n    return getServiceInternal(win, id);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Like getServicePromise but returns null if the service was never registered.\n * @param {!Window} win\n * @param {string} id\n * @return {?Promise<!Object>}\n */\nexport function getServicePromiseOrNull(win, id) {\n  return getServicePromiseOrNullInternal(win, id);\n}\n\n/**\n * Returns a service for the given id and ampdoc (a per-ampdoc singleton).\n * Expects service `id` to be registered.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {T}\n * @template T\n */\nexport function getServiceForDoc(elementOrAmpDoc, id) {\n  const ampdoc = getAmpdoc(elementOrAmpDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  return getServiceInternal(holder, id);\n}\n\n/**\n * Returns a service for the given id and ampdoc (a per-ampdoc singleton).\n * If service `id` is not registered, returns null.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {?Object}\n */\nexport function getServiceForDocOrNull(elementOrAmpDoc, id) {\n  const ampdoc = getAmpdoc(elementOrAmpDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  if (isServiceRegistered(holder, id)) {\n    return getServiceInternal(holder, id);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Returns a promise for a service for the given id and ampdoc. Also expects\n * a service that has the actual implementation. The promise resolves when\n * the implementation loaded.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {!Promise<!Object>}\n */\nexport function getServicePromiseForDoc(elementOrAmpDoc, id) {\n  return getServicePromiseInternal(getAmpdocServiceHolder(elementOrAmpDoc), id);\n}\n\n/**\n * Like getServicePromiseForDoc but returns null if the service was never\n * registered for this ampdoc.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {?Promise<!Object>}\n */\nexport function getServicePromiseOrNullForDoc(elementOrAmpDoc, id) {\n  return getServicePromiseOrNullInternal(\n    getAmpdocServiceHolder(elementOrAmpDoc),\n    id\n  );\n}\n\n/**\n * Set the parent and top windows on a child window (friendly iframe).\n * @param {!Window} win\n * @param {!Window} parentWin\n */\nexport function setParentWindow(win, parentWin) {\n  win.__AMP_PARENT = parentWin;\n  win.__AMP_TOP = getTopWindow(parentWin);\n}\n\n/**\n * Returns the parent window for a child window (friendly iframe).\n * @param {!Window} win\n * @return {!Window}\n */\nexport function getParentWindow(win) {\n  return win.__AMP_PARENT || win;\n}\n\n/**\n * Returns the top window where AMP Runtime is installed for a child window\n * (friendly iframe).\n * @param {!Window} win\n * @return {!Window}\n */\nexport function getTopWindow(win) {\n  return win.__AMP_TOP || (win.__AMP_TOP = win);\n}\n\n/**\n * Returns the parent \"friendly\" iframe if the node belongs to a child window.\n * @param {!Node} node\n * @param {!Window=} opt_topWin\n * @return {?HTMLIFrameElement}\n */\nexport function getParentWindowFrameElement(node, opt_topWin) {\n  const childWin = (node.ownerDocument || node).defaultView;\n  const topWin = opt_topWin || getTopWindow(childWin);\n  if (childWin && childWin != topWin && getTopWindow(childWin) == topWin) {\n    try {\n      return /** @type {?HTMLIFrameElement} */ (childWin.frameElement);\n    } catch (e) {\n      // Ignore the error.\n    }\n  }\n  return null;\n}\n\n/**\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @return {!./service/ampdoc-impl.AmpDoc}\n */\nexport function getAmpdoc(nodeOrDoc) {\n  if (nodeOrDoc.nodeType) {\n    const win = getWin(nodeOrDoc);\n    return getAmpdocService(win).getAmpDoc(/** @type {!Node} */ (nodeOrDoc));\n  }\n  return /** @type {!./service/ampdoc-impl.AmpDoc} */ (nodeOrDoc);\n}\n\n/**\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @return {!./service/ampdoc-impl.AmpDoc|!Window}\n */\nfunction getAmpdocServiceHolder(nodeOrDoc) {\n  const ampdoc = getAmpdoc(nodeOrDoc);\n  return ampdoc.isSingleDoc() ? ampdoc.win : ampdoc;\n}\n\n/**\n * This is essentially a duplicate of `ampdoc.js`, but necessary to avoid\n * circular dependencies.\n * @param {!Window} win\n * @return {!./service/ampdoc-impl.AmpDocService}\n */\nfunction getAmpdocService(win) {\n  return /** @type {!./service/ampdoc-impl.AmpDocService} */ (\n    getService(win, 'ampdoc')\n  );\n}\n\n/**\n * Get service `id` from `holder`. Assumes the service\n * has already been registered.\n * @param {!Object} holder Object holding the service instance.\n * @param {string} id of the service.\n * @return {Object}\n */\nfunction getServiceInternal(holder, id) {\n  devAssert(\n    isServiceRegistered(holder, id),\n    `Expected service ${id} to be registered`\n  );\n  const services = getServices(holder);\n  const s = services[id];\n  if (!s.obj) {\n    devAssert(s.ctor, `Service ${id} registered without ctor nor impl.`);\n    devAssert(s.context, `Service ${id} registered without context.`);\n    s.obj = new s.ctor(s.context);\n    devAssert(s.obj, `Service ${id} constructed to null.`);\n    s.context = null;\n    // The service may have been requested already, in which case we have a\n    // pending promise we need to fulfill.\n    if (s.resolve) {\n      s.resolve(s.obj);\n    }\n  }\n  return s.obj;\n}\n\n/**\n * @param {!Object} holder Object holding the service instance.\n * @param {!Window|!./service/ampdoc-impl.AmpDoc} context Win or AmpDoc.\n * @param {string} id of the service.\n * @param {?function(new:Object, !Window)|?function(new:Object, !./service/ampdoc-impl.AmpDoc)} ctor Constructor function to new the service. Called with context.\n * @param {boolean=} opt_override\n * @param {boolean=} opt_sharedInstance\n */\nfunction registerServiceInternal(\n  holder,\n  context,\n  id,\n  ctor,\n  opt_override,\n  opt_sharedInstance\n) {\n  const services = getServices(holder);\n  let s = services[id];\n\n  if (!s) {\n    s = services[id] = {\n      obj: null,\n      promise: null,\n      resolve: null,\n      reject: null,\n      context: null,\n      ctor: null,\n      sharedInstance: opt_sharedInstance || false,\n    };\n  }\n\n  if (!opt_override && s.ctor) {\n    // Service already registered.\n    return;\n  }\n\n  s.ctor = ctor;\n  s.context = context;\n  s.sharedInstance = opt_sharedInstance || false;\n\n  // The service may have been requested already, in which case there is a\n  // pending promise that needs to fulfilled.\n  if (s.resolve) {\n    // getServiceInternal will resolve the promise.\n    getServiceInternal(holder, id);\n  }\n}\n\n/**\n * @param {!Object} holder\n * @param {string} id of the service.\n * @return {!Promise<!Object>}\n */\nfunction getServicePromiseInternal(holder, id) {\n  const cached = getServicePromiseOrNullInternal(holder, id);\n  if (cached) {\n    return cached;\n  }\n  // Service is not registered.\n\n  // TODO(@cramforce): Add a check that if the element is eventually registered\n  // that the service is actually provided and this promise resolves.\n  const services = getServices(holder);\n  services[id] = emptyServiceHolderWithPromise();\n  return /** @type {!Promise<!Object>} */ (services[id].promise);\n}\n\n/**\n * @param {!Object} holder\n * @param {string} id of the service.\n * @param {*} error\n */\nfunction rejectServicePromiseInternal(holder, id, error) {\n  const services = getServices(holder);\n  const s = services[id];\n  if (s) {\n    if (s.reject) {\n      s.reject(error);\n    }\n    return;\n  }\n\n  services[id] = emptyServiceHolderWithPromise();\n  services[id].reject(error);\n}\n\n/**\n * Returns a promise for service `id` if the service has been registered\n * on `holder`.\n * @param {!Object} holder\n * @param {string} id of the service.\n * @return {?Promise<!Object>}\n */\nfunction getServicePromiseOrNullInternal(holder, id) {\n  const services = getServices(holder);\n  const s = services[id];\n  if (s) {\n    if (s.promise) {\n      return s.promise;\n    } else {\n      // Instantiate service if not already instantiated.\n      getServiceInternal(holder, id);\n      return (s.promise = Promise.resolve(/** @type {!Object} */ (s.obj)));\n    }\n  }\n  return null;\n}\n\n/**\n * Returns the object that holds the services registered in a holder.\n * @param {!Object} holder\n * @return {!Object<string,!ServiceHolderDef>}\n */\nfunction getServices(holder) {\n  let services = holder.__AMP_SERVICES;\n  if (!services) {\n    services = holder.__AMP_SERVICES = {};\n  }\n  return services;\n}\n\n/**\n * Whether the specified service implements `Disposable` interface.\n * @param {!Object} service\n * @return {boolean}\n */\nexport function isDisposable(service) {\n  return typeof service.dispose == 'function';\n}\n\n/**\n * Asserts that the specified service implements `Disposable` interface and\n * typecasts the instance to `Disposable`.\n * @param {!Object} service\n * @return {!Disposable}\n */\nexport function assertDisposable(service) {\n  devAssert(isDisposable(service), 'required to implement Disposable');\n  return /** @type {!Disposable} */ (service);\n}\n\n/**\n * Disposes all disposable (implements `Disposable` interface) services in\n * ampdoc scope.\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n */\nexport function disposeServicesForDoc(ampdoc) {\n  disposeServicesInternal(ampdoc);\n}\n\n/**\n * Disposes all disposable (implements `Disposable` interface) services in\n * embed scope.\n * @param {!Window} embedWin\n */\nexport function disposeServicesForEmbed(embedWin) {\n  disposeServicesInternal(embedWin);\n}\n\n/**\n * @param {!Object} holder Object holding the service instances.\n */\nfunction disposeServicesInternal(holder) {\n  const services = getServices(holder);\n  for (const id in services) {\n    if (!Object.prototype.hasOwnProperty.call(services, id)) {\n      continue;\n    }\n    const serviceHolder = services[id];\n    if (serviceHolder.sharedInstance) {\n      continue;\n    }\n    if (serviceHolder.obj) {\n      disposeServiceInternal(id, serviceHolder.obj);\n    } else if (serviceHolder.promise) {\n      serviceHolder.promise.then((instance) =>\n        disposeServiceInternal(id, instance)\n      );\n    }\n  }\n}\n\n/**\n * @param {string} id\n * @param {!Object} service\n */\nfunction disposeServiceInternal(id, service) {\n  if (!isDisposable(service)) {\n    return;\n  }\n  try {\n    assertDisposable(service).dispose();\n  } catch (e) {\n    // Ensure that a failure to dispose a service does not disrupt other\n    // services.\n    dev().error('SERVICE', 'failed to dispose service', id, e);\n  }\n}\n\n/**\n * This adopts the service **instance** from the parent.\n *\n * This function is dangerous! Sharing an instance means data can leak to and\n * from a child ampdoc.\n *\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {string} id\n */\nexport function adoptServiceForEmbedDoc(ampdoc, id) {\n  const service = getServiceInternal(\n    getAmpdocServiceHolder(devAssert(ampdoc.getParent())),\n    id\n  );\n  registerServiceInternal(\n    getAmpdocServiceHolder(ampdoc),\n    ampdoc,\n    id,\n    function () {\n      return service;\n    },\n    /* override */ false,\n    /* sharedInstance */ true\n  );\n}\n\n/**\n * This adopts the service **factory** from the parent.\n *\n * This function is safer than sharing the service instance, since each ampdoc\n * will create its own instance of the factory (and each instance will have its\n * own instance data). Note that static data is still shared, so it's not 100%\n * foolproof.\n *\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {string} id\n */\nexport function adoptServiceFactoryForEmbedDoc(ampdoc, id) {\n  const parentHolder = getAmpdocServiceHolder(devAssert(ampdoc.getParent()));\n  devAssert(\n    isServiceRegistered(parentHolder, id),\n    `Expected service ${id} to be registered`\n  );\n  const service = getServices(parentHolder)[id];\n  registerServiceInternal(\n    getAmpdocServiceHolder(ampdoc),\n    ampdoc,\n    id,\n    devAssert(service.ctor)\n  );\n}\n\n/**\n * Resets a single service, so it gets recreated on next getService invocation.\n * @param {!Object} holder\n * @param {string} id of the service.\n */\nexport function resetServiceForTesting(holder, id) {\n  if (holder.__AMP_SERVICES) {\n    holder.__AMP_SERVICES[id] = null;\n  }\n}\n\n/**\n * @param {!Object} holder Object holding the service instance.\n * @param {string} id of the service.\n * @return {boolean}\n */\nfunction isServiceRegistered(holder, id) {\n  const service = holder.__AMP_SERVICES && holder.__AMP_SERVICES[id];\n  // All registered services must have a constructor.\n  return !!(service && service.ctor);\n}\n\n/** @return {!ServiceHolderDef} */\nfunction emptyServiceHolderWithPromise() {\n  const deferred = new Deferred();\n  const {promise, reject, resolve} = deferred;\n  promise.catch(() => {}); // avoid uncaught exception when service gets rejected\n  return {\n    obj: null,\n    promise,\n    resolve,\n    reject,\n    context: null,\n    ctor: null,\n  };\n}\n", "import * as dom from '#core/dom';\n\nimport {extensionScriptInNode} from '#service/extension-script';\n\nimport {userAssert} from '#utils/log';\n\nimport {\n  getAmpdoc,\n  getService,\n  getServiceForDocOrNull,\n  getServicePromise,\n  getServicePromiseForDoc,\n  getServicePromiseOrNull,\n  getServicePromiseOrNullForDoc,\n} from './service-helpers';\n\n/**\n * Same as getElementService but produces null if the given element is not\n * actually available on the current page.\n * @param {!Window} win\n * @param {string} id of the service.\n * @param {string} extension Name of the custom extension that provides the\n *     implementation of this service.\n * @param {string} version The extension version.\n * @param {boolean=} opt_element Whether this service is provided by an\n *     element, not the extension.\n * @return {!Promise<?Object>}\n */\nexport function getElementServiceIfAvailable(\n  win,\n  id,\n  extension,\n  version,\n  opt_element\n) {\n  const s = getServicePromiseOrNull(win, id);\n  if (s) {\n    return /** @type {!Promise<?Object>} */ (s);\n  }\n  return getElementServicePromiseOrNull(\n    win,\n    id,\n    extension,\n    version,\n    opt_element\n  );\n}\n\n/**\n * Returns a promise for a service for the given id and window. Also expects an\n * element that has the actual implementation. The promise resolves when the\n * implementation loaded. Users should typically wrap this as a special purpose\n * function (e.g. Services.viewportForDoc(...)) for type safety and because the\n * factory should not be passed around.\n * @param {!Element|!ShadowRoot} element\n * @param {string} id of the service.\n * @param {string} extension Name of the custom extension that provides the\n *     implementation of this service.\n * @param {boolean=} opt_element Whether this service is provided by an element,\n *     not the extension.\n * @return {!Promise<*>}\n */\nexport function getElementServiceForDoc(element, id, extension, opt_element) {\n  return getElementServiceIfAvailableForDoc(\n    element,\n    id,\n    extension,\n    opt_element\n  ).then((service) => assertService(service, id, extension));\n}\n\n/**\n * Same as getElementService but produces null if the given element is not\n * actually available on the current page.\n * @param {!Element|!ShadowRoot} element\n * @param {string} id of the service.\n * @param {string} extension Name of the custom extension that provides the\n *     implementation of this service.\n * @param {boolean=} opt_element Whether this service is provided by an\n *     element, not the extension.\n * @return {!Promise<?Object>}\n */\nexport function getElementServiceIfAvailableForDoc(\n  element,\n  id,\n  extension,\n  opt_element\n) {\n  const s = getServicePromiseOrNullForDoc(element, id);\n  if (s) {\n    return /** @type {!Promise<?Object>} */ (s);\n  }\n  const ampdoc = getAmpdoc(element);\n  return ampdoc\n    .whenExtensionsKnown()\n    .then(() => {\n      const version = ampdoc.getExtensionVersion(extension);\n      if (!version) {\n        return null;\n      }\n      const extensions = getService(ampdoc.win, 'extensions');\n      return extensions.waitForExtension(extension, version);\n    })\n    .then((ext) => {\n      if (!ext) {\n        return null;\n      }\n      // If this service is provided by an element, then we can't depend on\n      // the service (they may not use the element).\n      if (opt_element) {\n        return getServicePromiseOrNullForDoc(element, id);\n      }\n      return getServicePromiseForDoc(element, id);\n    });\n}\n\n/**\n * Returns a promise for service for the given id in the embed scope of\n * a given element, if it exists. Falls back to ampdoc scope if the element\n * is not embedded.\n *\n * @param {!Element|!ShadowRoot} element\n * @param {string} id of the service.\n * @param {string} extension Name of the custom element that provides\n *     the implementation of this service.\n * @return {!Promise<?Object>}\n */\nexport function getElementServiceIfAvailableForDocInEmbedScope(\n  element,\n  id,\n  extension\n) {\n  const s = getServiceForDocOrNull(element, id);\n  if (s) {\n    return /** @type {!Promise<?Object>} */ (Promise.resolve(s));\n  }\n  return getElementServiceIfAvailableForDoc(element, id, extension);\n}\n\n/**\n * Throws user error if `service` is null.\n * @param {Object} service\n * @param {string} id\n * @param {string} extension\n * @return {!Object}\n * @private\n * @closurePrimitive {asserts.matchesReturn}\n */\nfunction assertService(service, id, extension) {\n  return /** @type {!Object} */ (\n    userAssert(\n      service,\n      'Service %s was requested to be provided through %s, ' +\n        'but %s is not loaded in the current page. To fix this ' +\n        'problem load the JavaScript file for %s in this page.',\n      id,\n      extension,\n      extension,\n      extension\n    )\n  );\n}\n\n/**\n * Returns the promise for service with `id` on the given window if available.\n * Otherwise, resolves with null (service was not registered).\n * @param {!Window} win\n * @param {string} id\n * @param {string} extension\n * @param {string} version\n * @param {boolean=} opt_element\n * @return {!Promise<Object>}\n * @private\n */\nfunction getElementServicePromiseOrNull(\n  win,\n  id,\n  extension,\n  version,\n  opt_element\n) {\n  return dom\n    .waitForBodyOpenPromise(win.document)\n    .then(() => {\n      // If there is an extension script wait for it to load before trying\n      // to get the service. Prevents a race condition when everything but\n      // the extensions is in cache. If there is no script then it's either\n      // not present, or the service was defined by a test. In those cases\n      // we don't wait around for an extension that does not exist.\n      const extensions = getService(win, 'extensions');\n\n      // TODO(jpettitt) investigate registerExtension to short circuit\n      // the dom call in extensionScriptsInNode()\n      if (!extensionScriptInNode(extensions.win, extension, version)) {\n        return null;\n      }\n      return extensions.waitForExtension(extension, version);\n    })\n    .then((ext) => {\n      if (!ext) {\n        return null;\n      }\n      // If this service is provided by an element, then we can't depend on\n      // the service (they may not use the element).\n      if (opt_element) {\n        return getServicePromiseOrNull(win, id);\n      }\n      return getServicePromise(win, id);\n    });\n}\n", "import {\n  getElementServiceForDoc,\n  getElementServiceIfAvailable,\n  getElementServiceIfAvailableForDoc,\n  getElementServiceIfAvailableForDocInEmbedScope,\n} from '../element-service';\nimport {\n  getAmpdoc,\n  getExistingServiceOrNull,\n  getService,\n  getServiceForDoc,\n  getServiceForDocOrNull,\n  getServiceInEmbedWin,\n  getServicePromiseForDoc,\n} from '../service-helpers';\n\n/** @typedef {!../extensions/amp-subscriptions/0.1/amp-subscriptions.SubscriptionService} */\nexport let SubscriptionService;\n\nexport class Services {\n  /**\n   * Hint: Add extensions folder path to compile.js with\n   * warnings cannot find modules.\n   */\n\n  /**\n   * Returns a promise for the Access service.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-access/0.1/amp-access.AccessService>}\n   */\n  static accessServiceForDoc(element) {\n    return /** @type {!Promise<!../extensions/amp-access/0.1/amp-access.AccessService>} */ (\n      getElementServiceForDoc(element, 'access', 'amp-access')\n    );\n  }\n\n  /**\n   * Returns a promise for the Access service or a promise for null if the\n   * service is not available on the current page.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-access/0.1/amp-access.AccessService>}\n   */\n  static accessServiceForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-access/0.1/amp-access.AccessService>} */ (\n      getElementServiceIfAvailableForDoc(element, 'access', 'amp-access')\n    );\n  }\n\n  /**\n   * Returns a promise for the Subscriptions service.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!SubscriptionService>}\n   */\n  static subscriptionsServiceForDoc(element) {\n    return /** @type {!Promise<!SubscriptionService>} */ (\n      getElementServiceForDoc(element, 'subscriptions', 'amp-subscriptions')\n    );\n  }\n\n  /**\n   * Returns a promise for the Subscriptions service.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?SubscriptionService>}\n   */\n  static subscriptionsServiceForDocOrNull(element) {\n    return /** @type {!Promise<?SubscriptionService>} */ (\n      getElementServiceIfAvailableForDoc(\n        element,\n        'subscriptions',\n        'amp-subscriptions'\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/action-impl.ActionService}\n   */\n  static actionServiceForDoc(element) {\n    return /** @type {!./service/action-impl.ActionService} */ (\n      getServiceForDocOrNull(element, 'action')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/standard-actions-impl.StandardActions}\n   */\n  static standardActionsForDoc(element) {\n    return /** @type {!./service/standard-actions-impl.StandardActions} */ (\n      getServiceForDocOrNull(element, 'standard-actions')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-analytics/0.1/activity-impl.Activity>}\n   */\n  static activityForDoc(element) {\n    return /** @type {!Promise<!../extensions/amp-analytics/0.1/activity-impl.Activity>} */ (\n      getElementServiceForDoc(element, 'activity', 'amp-analytics')\n    );\n  }\n\n  /**\n   * Returns the global instance of the `AmpDocService` service that can be\n   * used to resolve an ampdoc for any node: either in the single-doc or\n   * shadow-doc environment.\n   * @param {!Window} window\n   * @return {!./service/ampdoc-impl.AmpDocService}\n   */\n  static ampdocServiceFor(window) {\n    return /** @type {!./service/ampdoc-impl.AmpDocService} */ (\n      getService(window, 'ampdoc')\n    );\n  }\n\n  /**\n   * Returns the AmpDoc for the specified context node.\n   * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrAmpDoc\n   * @return {!./service/ampdoc-impl.AmpDoc}\n   */\n  static ampdoc(nodeOrAmpDoc) {\n    return getAmpdoc(nodeOrAmpDoc);\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @param {boolean=} loadAnalytics\n   * @return {!Promise<!../extensions/amp-analytics/0.1/instrumentation.InstrumentationService>}\n   */\n  static analyticsForDoc(element, loadAnalytics = false) {\n    if (loadAnalytics) {\n      // Get Extensions service and force load analytics extension.\n      const ampdoc = getAmpdoc(element);\n      Services.extensionsFor(ampdoc.win)./*OK*/ installExtensionForDoc(\n        ampdoc,\n        'amp-analytics'\n      );\n    }\n    return /** @type {!Promise<!../extensions/amp-analytics/0.1/instrumentation.InstrumentationService>} */ (\n      getElementServiceForDoc(\n        element,\n        'amp-analytics-instrumentation',\n        'amp-analytics'\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-analytics/0.1/instrumentation.InstrumentationService>}\n   */\n  static analyticsForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-analytics/0.1/instrumentation.InstrumentationService>} */ (\n      getElementServiceIfAvailableForDoc(\n        element,\n        'amp-analytics-instrumentation',\n        'amp-analytics'\n      )\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/batched-xhr-impl.BatchedXhr}\n   */\n  static batchedXhrFor(window) {\n    return /** @type {!./service/batched-xhr-impl.BatchedXhr} */ (\n      getService(window, 'batched-xhr')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-bind/0.1/bind-impl.Bind>}\n   */\n  static bindForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-bind/0.1/bind-impl.Bind>} */ (\n      getElementServiceIfAvailableForDocInEmbedScope(\n        element,\n        'bind',\n        'amp-bind'\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-script/0.1/amp-script.AmpScriptService>}\n   */\n  static scriptForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-script/0.1/amp-script.AmpScriptService>} */ (\n      getElementServiceIfAvailableForDocInEmbedScope(\n        element,\n        'amp-script',\n        'amp-script'\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/cid-impl.CidDef>}\n   */\n  static cidForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/cid-impl.CidDef>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'cid')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/navigation.Navigation}\n   */\n  static navigationForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/navigation.Navigation} */ (\n      getServiceForDoc(elementOrAmpDoc, 'navigation')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-loader/0.1/amp-loader.LoaderService>}\n   */\n  static loaderServiceForDoc(element) {\n    return /** @type {!Promise<!../extensions/amp-loader/0.1/amp-loader.LoaderService>} */ (\n      getElementServiceForDoc(element, 'loader', 'amp-loader')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-standalone/0.1/amp-standalone.StandaloneService>}\n   */\n  static standaloneServiceForDoc(element) {\n    return /** @type {!Promise<!../extensions/amp-standalone/0.1/amp-standalone.StandaloneService>} */ (\n      getElementServiceForDoc(element, 'standalone', 'amp-standalone')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/crypto-impl.Crypto}\n   */\n  static cryptoFor(window) {\n    return /** @type {!./service/crypto-impl.Crypto} */ (\n      getService(window, 'crypto')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/document-info-impl.DocumentInfoDef} Info about the doc\n   */\n  static documentInfoForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/document-info-impl.DocInfo} */ (\n      getServiceForDoc(elementOrAmpDoc, 'documentInfo')\n    ).get();\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/extensions-impl.Extensions}\n   */\n  static extensionsFor(window) {\n    return /** @type {!./service/extensions-impl.Extensions} */ (\n      getService(window, 'extensions')\n    );\n  }\n\n  /**\n   * Returns a service to register callbacks we wish to execute when an\n   * amp-form is submitted.\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<../extensions/amp-form/0.1/form-submit-service.FormSubmitService>}\n   */\n  static formSubmitForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<../extensions/amp-form/0.1/form-submit-service.FormSubmitService>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'form-submit-service')\n    );\n  }\n\n  /**\n   * Returns service to listen for `hidden` attribute mutations.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/hidden-observer-impl.HiddenObserver}\n   */\n  static hiddenObserverForDoc(element) {\n    return /** @type {!./service/hidden-observer-impl.HiddenObserver} */ (\n      getServiceForDocOrNull(element, 'hidden-observer')\n    );\n  }\n\n  /**\n   * Returns service implemented in service/history-impl.\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/history-impl.History}\n   */\n  static historyForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/history-impl.History} */ (\n      getServiceForDoc(elementOrAmpDoc, 'history')\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {!./input.Input}\n   */\n  static inputFor(win) {\n    return getService(win, 'input');\n  }\n\n  /**s\n   * Returns a promise for the Inputmask service.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-inputmask/0.1/amp-inputmask.AmpInputmaskService>}\n   */\n  static inputmaskServiceForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-inputmask/0.1/amp-inputmask.AmpInputmaskService>} */ (\n      getElementServiceIfAvailableForDoc(element, 'inputmask', 'amp-inputmask')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {?./service/loading-indicator.LoadingIndicatorImpl}\n   */\n  static loadingIndicatorOrNull(elementOrAmpDoc) {\n    return /** @type {?./service/loading-indicator.LoadingIndicatorImpl} */ (\n      getServiceForDocOrNull(elementOrAmpDoc, 'loadingIndicator')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!../extensions/amp-next-page/1.0/service.NextPageService}\n   */\n  static nextPageServiceForDoc(elementOrAmpDoc) {\n    return /** @type {!../extensions/amp-next-page/1.0/service.NextPageService} */ (\n      getServiceForDoc(elementOrAmpDoc, 'next-page')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/mutator-interface.MutatorInterface}\n   */\n  static mutatorForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/mutator-interface.MutatorInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'mutator')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/owners-interface.OwnersInterface}\n   */\n  static ownersForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/owners-interface.OwnersInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'owners')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/performance-impl.Performance}\n   */\n  static performanceFor(window) {\n    return /** @type {!./service/performance-impl.Performance}*/ (\n      getService(window, 'performance')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/performance-impl.Performance}\n   */\n  static performanceForOrNull(window) {\n    return /** @type {!./service/performance-impl.Performance}*/ (\n      getExistingServiceOrNull(window, 'performance')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/platform-impl.Platform}\n   */\n  static platformFor(window) {\n    return /** @type {!./service/platform-impl.Platform} */ (\n      getService(window, 'platform')\n    );\n  }\n\n  /**\n   * Not installed by default; must be installed in extension code before use.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/position-observer/position-observer-impl.PositionObserver}\n   * @throws If the service is not installed.\n   */\n  static positionObserverForDoc(element) {\n    return /** @type {!./service/position-observer/position-observer-impl.PositionObserver} */ (\n      getServiceForDoc(element, 'position-observer')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./preconnect.PreconnectService}\n   */\n  static preconnectFor(window) {\n    return getService(window, 'preconnect');\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/resources-interface.ResourcesInterface}\n   */\n  static resourcesForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/resources-interface.ResourcesInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'resources')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/resources-interface.ResourcesInterface>}\n   */\n  static resourcesPromiseForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/resources-interface.ResourcesInterface>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'resources')\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?Promise<?../extensions/amp-story/1.0/variable-service.AmpStoryVariableService>}\n   */\n  static storyVariableServiceForOrNull(win) {\n    return (\n      /** @type {!Promise<?../extensions/amp-story/1.0/variable-service.AmpStoryVariableService>} */\n      (getElementServiceIfAvailable(win, 'story-variable', 'amp-story', '1.0'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/variable-service.AmpStoryVariableService}\n   */\n  static storyVariableService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/variable-service.AmpStoryVariableService} */\n      (getExistingServiceOrNull(win, 'story-variable'))\n    );\n  }\n\n  /**\n   * Version of the story store service depends on which version of amp-story\n   * the publisher is loading. They all have the same implementation.\n   * @param {!Window} win\n   * @return {?Promise<?../extensions/amp-story/1.0/amp-story-store-service.AmpStoryStoreService>}\n   */\n  static storyStoreServiceForOrNull(win) {\n    return (\n      /** @type {!Promise<?../extensions/amp-story/1.0/amp-story-store-service.AmpStoryStoreService>} */\n      (getElementServiceIfAvailable(win, 'story-store', 'amp-story', '1.0'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/amp-story-store-service.AmpStoryStoreService}\n   */\n  static storyStoreService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/amp-story-store-service.AmpStoryStoreService} */\n      (getExistingServiceOrNull(win, 'story-store'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/amp-story-media-query-service.AmpStoryMediaQueryService}\n   */\n  static storyMediaQueryService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/amp-story-media-query-service.AmpStoryMediaQueryService} */\n      (getExistingServiceOrNull(win, 'story-media-query'))\n    );\n  }\n\n  /**\n   * Get promise with story request service\n   * @param {!Window} win\n   * @return {?Promise<?../extensions/amp-story/1.0/amp-story-request-service.AmpStoryRequestService>}\n   */\n  static storyRequestServiceForOrNull(win) {\n    return (\n      /** @type {!Promise<?../extensions/amp-story/1.0/amp-story-request-service.AmpStoryRequestService>} */\n      (getElementServiceIfAvailable(win, 'story-request', 'amp-story', '1.0'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/amp-story-request-service.AmpStoryRequestService}\n   */\n  static storyRequestService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/amp-story-request-service.AmpStoryRequestService} */\n      (getExistingServiceOrNull(win, 'story-request'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/media-performance-metrics-service.MediaPerformanceMetricsService}\n   */\n  static mediaPerformanceMetricsService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/media-performance-metrics-service.MediaPerformanceMetricsService} */\n      (getExistingServiceOrNull(win, 'media-performance-metrics'))\n    );\n  }\n\n  /**\n   * @param {!Element} el\n   * @return {!Promise<./service/localization.LocalizationService>}\n   */\n  static localizationServiceForOrNull(el) {\n    return /** @type {!Promise<?./service/localization.LocalizationService>} */ (\n      getServicePromiseForDoc(el, 'localization')\n    );\n  }\n\n  /**\n   * @param {!Element} element\n   * @return {?./service/localization.LocalizationService}\n   */\n  static localizationForDoc(element) {\n    return /** @type {?./service/localization.LocalizationService} */ (\n      getServiceForDocOrNull(element, 'localization')\n    );\n  }\n\n  /**\n   * TODO(#14357): Remove this when amp-story:0.1 is deprecated.\n   * @param {!Window} win\n   * @return {!Promise<?../extensions/amp-story/1.0/story-analytics.StoryAnalyticsService>}\n   */\n  static storyAnalyticsServiceForOrNull(win) {\n    return (\n      /** @type {!Promise<?../extensions/amp-story/1.0/story-analytics.StoryAnalyticsService>} */\n      (\n        getElementServiceIfAvailable(\n          win,\n          'story-analytics',\n          'amp-story',\n          '1.0',\n          true\n        )\n      )\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/story-analytics.StoryAnalyticsService}\n   */\n  static storyAnalyticsService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/story-analytics.StoryAnalyticsService} */\n      (getExistingServiceOrNull(win, 'story-analytics'))\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-animation/0.1/web-animation-service.WebAnimationService>}\n   */\n  static webAnimationServiceFor(element) {\n    return (\n      /** @type {!Promise<!../extensions/amp-animation/0.1/web-animation-service.WebAnimationService>} */\n      (getElementServiceForDoc(element, 'web-animation', 'amp-animation'))\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/real-time-config/real-time-config-impl.RealTimeConfigManager>}\n   */\n  static realTimeConfigForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/real-time-config/real-time-config-impl.RealTimeConfigManager>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'real-time-config')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/storage-impl.Storage>}\n   */\n  static storageForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/storage-impl.Storage>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'storage')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/storage-impl.Storage>}\n   * TODO(dmanek): Add tests for this method.\n   */\n  static storageForTopLevelDoc(elementOrAmpDoc) {\n    const thisAmpdoc = Services.ampdoc(elementOrAmpDoc);\n    const ampdocService = Services.ampdocServiceFor(thisAmpdoc.win);\n    const topAmpdoc = ampdocService.isSingleDoc()\n      ? ampdocService.getSingleDoc()\n      : null;\n    // We need to verify that ampdocs are on the same origin, therefore\n    // we compare the windows of both.\n    const ampdoc =\n      topAmpdoc && topAmpdoc.win == thisAmpdoc.win ? topAmpdoc : thisAmpdoc;\n    return /** @type {!Promise<!./service/storage-impl.Storage>} */ (\n      getServicePromiseForDoc(ampdoc, 'storage')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/template-impl.Templates}\n   */\n  static templatesForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/template-impl.Templates} */ (\n      getServiceForDoc(elementOrAmpDoc, 'templates')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/timer-impl.Timer}\n   */\n  static timerFor(window) {\n    // TODO(alabiaga): This will always return the top window's Timer service.\n    return /** @type {!./service/timer-impl.Timer} */ (\n      getServiceInEmbedWin(window, 'timer')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/url-replacements-impl.UrlReplacements}\n   */\n  static urlReplacementsForDoc(element) {\n    return /** @type {!./service/url-replacements-impl.UrlReplacements} */ (\n      getServiceForDocOrNull(element, 'url-replace')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-user-notification/0.1/amp-user-notification.UserNotificationManager>}\n   */\n  static userNotificationManagerForDoc(element) {\n    return (\n      /** @type {!Promise<!../extensions/amp-user-notification/0.1/amp-user-notification.UserNotificationManager>} */\n      (\n        getElementServiceForDoc(\n          element,\n          'userNotificationManager',\n          'amp-user-notification'\n        )\n      )\n    );\n  }\n\n  /**\n   * Returns a promise for the consentPolicy Service or a promise for null if\n   * the service is not available on the current page.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-consent/0.1/consent-policy-manager.ConsentPolicyManager>}\n   */\n  static consentPolicyServiceForDocOrNull(element) {\n    return (\n      /** @type {!Promise<?../extensions/amp-consent/0.1/consent-policy-manager.ConsentPolicyManager>} */\n      (\n        getElementServiceIfAvailableForDoc(\n          element,\n          'consentPolicyManager',\n          'amp-consent'\n        )\n      )\n    );\n  }\n\n  /**\n   * Returns a promise for the geo service or a promise for null if\n   * the service is not available on the current page.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-geo/0.1/amp-geo.GeoDef>}\n   */\n  static geoForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-geo/0.1/amp-geo.GeoDef>} */ (\n      getElementServiceIfAvailableForDoc(element, 'geo', 'amp-geo', true)\n    );\n  }\n\n  /**\n   * Unlike most service getters, passing `Node` is necessary for some FIE-scope\n   * services since sometimes we only have the FIE Document for context.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/url-impl.Url}\n   */\n  static urlForDoc(element) {\n    return /** @type {!./service/url-impl.Url} */ (\n      getServiceForDocOrNull(element, 'url')\n    );\n  }\n\n  /**\n   * Returns a promise for the experiment variants or a promise for null if it\n   * is not available on the current page.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-experiment/0.1/variant.Variants>}\n   */\n  static variantsForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-experiment/0.1/variant.Variants>} */ (\n      getElementServiceIfAvailableForDoc(\n        element,\n        'variant',\n        'amp-experiment',\n        true\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/video-manager-impl.VideoManager}\n   */\n  static videoManagerForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/video-manager-impl.VideoManager} */ (\n      getServiceForDoc(elementOrAmpDoc, 'video-manager')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/viewer-interface.ViewerInterface}\n   */\n  static viewerForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/viewer-interface.ViewerInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'viewer')\n    );\n  }\n\n  /**\n   * Returns promise for the viewer. This is an unusual case and necessary only\n   * for services that need reference to the viewer before it has been\n   * initialized. Most of the code, however, just should use `viewerForDoc`.\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/viewer-interface.ViewerInterface>}\n   */\n  static viewerPromiseForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/viewer-interface.ViewerInterface>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'viewer')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/vsync-impl.Vsync}\n   */\n  static vsyncFor(window) {\n    return /** @type {!./service/vsync-impl.Vsync} */ (\n      getService(window, 'vsync')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/viewport/viewport-interface.ViewportInterface}\n   */\n  static viewportForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/viewport/viewport-interface.ViewportInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'viewport')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/xhr-impl.Xhr}\n   */\n  static xhrFor(window) {\n    return /** @type {!./service/xhr-impl.Xhr} */ (getService(window, 'xhr'));\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<../amp-cache-url/amp-cache-url.AmpCacheUrlService>}\n   */\n  static cacheUrlServicePromiseForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<?../amp-cache-url/amp-cache-url.AmpCacheUrlService>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'cache-url')\n    );\n  }\n}\n", "import {dict} from '#core/types/object';\n\nimport {Services} from '#service';\n\n/**\n * Helper method to trigger analytics event if amp-analytics is available.\n * TODO: Do not expose this function\n * @param {!Element} target\n * @param {string} eventType\n * @param {!JsonObject} vars A map of vars and their values.\n * @param {boolean} enableDataVars A boolean to indicate if data-vars-*\n * attribute value from target element should be included.\n */\nexport function triggerAnalyticsEvent(\n  target,\n  eventType,\n  vars = dict(),\n  enableDataVars = true\n) {\n  Services.analyticsForDocOrNull(target).then((analytics) => {\n    if (!analytics) {\n      return;\n    }\n    analytics.triggerEventForTarget(target, eventType, vars, enableDataVars);\n  });\n}\n", "/**\n * Whether addEventListener supports options or only takes capture as a boolean\n * @type {boolean|undefined}\n * @visibleForTesting\n */\nlet optsSupported;\n\n/**\n * Whether addEventListener supports options or only takes passive as a boolean\n * @type {boolean|undefined}\n */\nlet passiveSupported;\n\n/**\n * Options supported by addEventListener\n * @typedef AddEventListenerOptsDef\n * @property {undefined|boolean} [capture]\n * @property {undefined|boolean} [once]\n * @property {undefined|boolean} [passive]\n * @property {undefined|!AbortSignal} [signal]\n * }}\n */\nlet AddEventListenerOptsDef;\n\n/**\n * Listens for the specified event on the element.\n *\n * Do not use this directly. This method is implemented as a shared\n * dependency. Use `listen()` in either `event-helper` or\n * `#core/3p-frame-messaging`, depending on your use case.\n *\n * @param {!EventTarget} element\n * @param {string} eventType\n * @param {function(!Event)} listener\n * @param {!AddEventListenerOptsDef=} opt_evtListenerOpts\n * @return {!UnlistenDef}\n */\nexport function internalListenImplementation(\n  element,\n  eventType,\n  listener,\n  opt_evtListenerOpts\n) {\n  let localElement = element;\n  let localListener = listener;\n  /** @type {?function(!Event)} */\n  let wrapped = (event) => {\n    try {\n      return localListener(event);\n    } catch (e) {\n      // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n      self.__AMP_REPORT_ERROR?.(e);\n      throw e;\n    }\n  };\n  const optsSupported = detectEvtListenerOptsSupport();\n  const capture = !!opt_evtListenerOpts?.capture;\n\n  localElement.addEventListener(\n    eventType,\n    wrapped,\n    optsSupported ? opt_evtListenerOpts : capture\n  );\n  return () => {\n    localElement?.removeEventListener(\n      eventType,\n      wrapped,\n      optsSupported ? opt_evtListenerOpts : capture\n    );\n    // Ensure these are GC'd\n    localListener = null;\n    localElement = null;\n    wrapped = null;\n  };\n}\n\n/**\n * Tests whether the browser supports options as an argument of addEventListener\n * or not.\n *\n * @return {boolean}\n */\nexport function detectEvtListenerOptsSupport() {\n  // Only run the test once\n  if (optsSupported !== undefined) {\n    return optsSupported;\n  }\n\n  optsSupported = false;\n  try {\n    // Test whether browser supports EventListenerOptions or not\n    const options = {\n      get capture() {\n        optsSupported = true;\n      },\n    };\n    self.addEventListener('test-options', null, options);\n    self.removeEventListener('test-options', null, options);\n  } catch (err) {\n    // EventListenerOptions are not supported\n  }\n  return optsSupported;\n}\n\n/**\n * Resets the test for whether addEventListener supports options or not.\n */\nexport function resetEvtListenerOptsSupportForTesting() {\n  optsSupported = undefined;\n}\n\n/**\n * Return boolean. if listener option is supported, return `true`.\n * if not supported, return `false`\n * @param {!Window} win\n * @return {boolean}\n */\nexport function supportsPassiveEventListener(win) {\n  if (passiveSupported !== undefined) {\n    return passiveSupported;\n  }\n\n  passiveSupported = false;\n  try {\n    const options = {\n      get passive() {\n        // This function will be called when the browser\n        // attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      },\n    };\n\n    win.addEventListener('test-options', null, options);\n    win.removeEventListener('test-options', null, options);\n  } catch (err) {\n    // EventListenerOptions are not supported\n  }\n  return passiveSupported;\n}\n\n/**\n * Resets the test for whether addEventListener supports passive options or not.\n */\nexport function resetPassiveSupportedForTesting() {\n  passiveSupported = undefined;\n}\n", "import {internalListenImplementation} from '#core/dom/event-helper-listen';\nimport {lastChildElement} from '#core/dom/query';\nimport * as mode from '#core/mode';\n\nimport {user} from '#utils/log';\n\n/** @const {string}  */\nconst LOAD_FAILURE_PREFIX = 'Failed to load:';\n\n/** @const {string} */\nexport const MEDIA_LOAD_FAILURE_SRC_PROPERTY = '__AMP_MEDIA_LOAD_FAILURE_SRC';\n\n/**\n * Returns a CustomEvent with a given type and detail; supports fallback for IE.\n * @param {!Window} win\n * @param {string} type\n * @param {!JsonObject|string|undefined|null} detail\n * @param {EventInit=} opt_eventInit\n * @return {!Event}\n */\nexport function createCustomEvent(win, type, detail, opt_eventInit) {\n  const eventInit = /** @type {!CustomEventInit} */ ({detail});\n  Object.assign(eventInit, opt_eventInit);\n  // win.CustomEvent is a function on Edge, Chrome, FF, Safari but\n  // is an object on IE 11.\n  if (mode.isEsm() || typeof win.CustomEvent == 'function') {\n    return new win.CustomEvent(type, eventInit);\n  } else {\n    // Deprecated fallback for IE.\n    const e = win.document.createEvent('CustomEvent');\n    e.initCustomEvent(\n      type,\n      !!eventInit.bubbles,\n      !!eventInit.cancelable,\n      detail\n    );\n    return e;\n  }\n}\n\n/**\n * Listens for the specified event on the element.\n * @param {!EventTarget} element\n * @param {string} eventType\n * @param {function(!Event)} listener\n * @param {Object=} opt_evtListenerOpts\n * @return {!UnlistenDef}\n */\nexport function listen(element, eventType, listener, opt_evtListenerOpts) {\n  return internalListenImplementation(\n    element,\n    eventType,\n    listener,\n    opt_evtListenerOpts\n  );\n}\n\n/**\n * Returns the data property of an event with the correct type.\n * @param {!Event|{data: !JsonObject}} event\n * @return {?JsonObject|string|undefined}\n */\nexport function getData(event) {\n  return /** @type {?JsonObject|string|undefined} */ (event.data);\n}\n\n/**\n * Returns the detail property of an event with the correct type.\n * @param {!Event|{detail: !JsonObject}} event\n * @return {?JsonObject|string|undefined}\n */\nexport function getDetail(event) {\n  return /** @type {?JsonObject|string|undefined} */ (event.detail);\n}\n\n/**\n * Listens for the specified event on the element and removes the listener\n * as soon as event has been received.\n * @param {!EventTarget} element\n * @param {string} eventType\n * @param {function(!Event)} listener\n * @param {Object=} opt_evtListenerOpts\n * @return {!UnlistenDef}\n */\nexport function listenOnce(element, eventType, listener, opt_evtListenerOpts) {\n  let localListener = listener;\n  const unlisten = internalListenImplementation(\n    element,\n    eventType,\n    (event) => {\n      try {\n        localListener(event);\n      } finally {\n        // Ensure listener is GC'd\n        localListener = null;\n        unlisten();\n      }\n    },\n    opt_evtListenerOpts\n  );\n  return unlisten;\n}\n\n/**\n * Returns  a promise that will resolve as soon as the specified event has\n * fired on the element.\n * @param {!EventTarget} element\n * @param {string} eventType\n * @param {Object=} opt_evtListenerOpts\n * @param {function(!UnlistenDef)=} opt_cancel An optional function that, when\n *     provided, will be called with the unlistener. This gives the caller\n *     access to the unlistener, so it may be called manually when necessary.\n * @return {!Promise<!Event>}\n */\nexport function listenOncePromise(\n  element,\n  eventType,\n  opt_evtListenerOpts,\n  opt_cancel\n) {\n  let unlisten;\n  const eventPromise = new Promise((resolve) => {\n    unlisten = listenOnce(element, eventType, resolve, opt_evtListenerOpts);\n  });\n  eventPromise.then(unlisten, unlisten);\n  if (opt_cancel) {\n    opt_cancel(unlisten);\n  }\n  return eventPromise;\n}\n\n/**\n * Whether the specified element/window has been loaded already.\n * @param {!Element|!Window} eleOrWindow\n * @return {boolean}\n */\nexport function isLoaded(eleOrWindow) {\n  return !!(\n    eleOrWindow.complete ||\n    eleOrWindow.readyState == 'complete' ||\n    (isHTMLMediaElement(eleOrWindow) && eleOrWindow.readyState > 0) ||\n    // If the passed in thing is a Window, infer loaded state from\n    //\n    (eleOrWindow.document && eleOrWindow.document.readyState == 'complete')\n  );\n}\n\n/**\n * Returns a promise that will resolve or fail based on the eleOrWindow's 'load'\n * and 'error' events. Optionally this method takes a timeout, which will reject\n * the promise if the resource has not loaded by then.\n * @param {T} eleOrWindow Supports both Elements and as a special case Windows.\n * @return {!Promise<T>}\n * @template T\n */\nexport function loadPromise(eleOrWindow) {\n  let unlistenLoad;\n  let unlistenError;\n  if (isLoaded(eleOrWindow)) {\n    return Promise.resolve(eleOrWindow);\n  }\n  const isMediaElement = isHTMLMediaElement(eleOrWindow);\n  if (\n    isMediaElement &&\n    eleOrWindow[MEDIA_LOAD_FAILURE_SRC_PROPERTY] === eleOrWindow.currentSrc\n  ) {\n    return Promise.reject(eleOrWindow);\n  }\n  const loadingPromise = new Promise((resolve, reject) => {\n    // Listen once since IE 5/6/7 fire the onload event continuously for\n    // animated GIFs.\n    if (isMediaElement) {\n      // The following event can be triggered by the media or one of its\n      // sources. Using capture is required as the media events do not bubble.\n      unlistenLoad = listenOnce(eleOrWindow, 'loadedmetadata', resolve, {\n        capture: true,\n      });\n    } else {\n      unlistenLoad = listenOnce(eleOrWindow, 'load', resolve);\n    }\n    // Don't unlisten on error for Windows.\n    if (!eleOrWindow.tagName) {\n      return;\n    }\n    let errorTarget = eleOrWindow;\n    // If the media element has no `src`, it will try to load the sources in\n    // document order. If the last source errors, then the media element\n    // loading errored.\n    if (isMediaElement && !eleOrWindow.hasAttribute('src')) {\n      errorTarget = lastChildElement(\n        eleOrWindow,\n        (child) => child.tagName === 'SOURCE'\n      );\n      if (!errorTarget) {\n        return reject(new Error('Media has no source.'));\n      }\n    }\n    unlistenError = listenOnce(errorTarget, 'error', reject);\n  });\n\n  return loadingPromise.then(\n    () => {\n      if (unlistenError) {\n        unlistenError();\n      }\n      return eleOrWindow;\n    },\n    () => {\n      if (unlistenLoad) {\n        unlistenLoad();\n      }\n      failedToLoad(eleOrWindow);\n    }\n  );\n}\n\n/**\n * Emit error on load failure.\n * @param {!Element|!Window} eleOrWindow Supports both Elements and as a special\n *     case Windows.\n */\nfunction failedToLoad(eleOrWindow) {\n  // Mark the element as errored since some elements - like HTMLMediaElement\n  // using HTMLSourceElement - do not provide any synchronous way to verify if\n  // they already errored, even though the error event was already dispatched.\n  if (isHTMLMediaElement(eleOrWindow)) {\n    eleOrWindow[MEDIA_LOAD_FAILURE_SRC_PROPERTY] =\n      eleOrWindow.currentSrc || true;\n  }\n\n  // Report failed loads as user errors so that they automatically go\n  // into the \"document error\" bucket.\n  let target = eleOrWindow;\n  if (target && target.src) {\n    target = target.src;\n  }\n  throw user().createError(LOAD_FAILURE_PREFIX, target);\n}\n\n/**\n * Returns true if the parameter is a HTMLMediaElement.\n * @param {!Element|!Window} eleOrWindow\n * @return {boolean}\n */\nfunction isHTMLMediaElement(eleOrWindow) {\n  return eleOrWindow.tagName === 'AUDIO' || eleOrWindow.tagName === 'VIDEO';\n}\n\n/**\n * Returns true if this error message is was created for a load error.\n * @param {string} message An error message\n * @return {boolean}\n */\nexport function isLoadErrorMessage(message) {\n  return message.indexOf(LOAD_FAILURE_PREFIX) != -1;\n}\n", "import {iterateCursor} from '#core/dom';\nimport {getFormAsObject, getSubmitButtonUsed} from '#core/dom/form';\nimport {map} from '#core/types/object';\n\nimport {Services} from '#service';\n\n/**\n * Create a form data wrapper. The wrapper is necessary to provide a common\n * API for FormData objects on all browsers. For example, not all browsers\n * support the FormData#entries or FormData#delete functions.\n *\n * @param {!Window} win\n * @param {!HTMLFormElement=} opt_form\n * @return {!FormDataWrapperInterface}\n */\nexport function createFormDataWrapper(win, opt_form) {\n  const platform = Services.platformFor(win);\n\n  if (platform.isIos() && platform.getMajorVersion() == 11) {\n    return new Ios11NativeFormDataWrapper(opt_form);\n  } else if (FormData.prototype.entries && FormData.prototype.delete) {\n    return new NativeFormDataWrapper(opt_form);\n  } else {\n    return new PolyfillFormDataWrapper(opt_form);\n  }\n}\n\n/**\n * Check if the given object is a FormDataWrapper instance\n * @param {*} o\n * @return {boolean} True if the object is a FormDataWrapper instance.\n */\nexport function isFormDataWrapper(o) {\n  // instanceof doesn't work as expected, so we detect with duck-typing.\n  return !!o && typeof o.getFormData == 'function';\n}\n\n/**\n * A polyfill wrapper for a `FormData` object.\n *\n * If there's no native `FormData#entries`, chances are there are no native\n * methods to read the content of the `FormData` after construction, so the\n * only way to implement `entries` in this class is to capture the fields in\n * the form passed to the constructor (and the arguments passed to the\n * `append` method).\n *\n * For more details on this, see http://mdn.io/FormData.\n *\n * @implements {FormDataWrapperInterface}\n * @visibleForTesting\n */\nexport class PolyfillFormDataWrapper {\n  /** @override */\n  constructor(opt_form = undefined) {\n    /** @private @const {!Object<string, !Array<string>>} */\n    this.fieldValues_ = opt_form ? getFormAsObject(opt_form) : map();\n  }\n\n  /**\n   * @param {string} name\n   * @param {string|!File} value\n   * @param {string=} opt_filename\n   * @override\n   */\n  append(name, value, opt_filename) {\n    // Coercion to string is required to match\n    // the native FormData.append behavior\n    const nameString = String(name);\n    this.fieldValues_[nameString] = this.fieldValues_[nameString] || [];\n    this.fieldValues_[nameString].push(String(value));\n  }\n\n  /** @override */\n  delete(name) {\n    delete this.fieldValues_[name];\n  }\n\n  /** @override */\n  entries() {\n    const fieldEntries = [];\n    Object.keys(this.fieldValues_).forEach((name) => {\n      const values = this.fieldValues_[name];\n      values.forEach((value) => fieldEntries.push([name, value]));\n    });\n\n    // Generator functions are not supported by the current Babel configuration,\n    // so we must manually implement the iterator interface.\n    let nextIndex = 0;\n    return /** @type {!Iterator<!Array<string>>} */ ({\n      next() {\n        return nextIndex < fieldEntries.length\n          ? {value: fieldEntries[nextIndex++], done: false}\n          : {value: undefined, done: true};\n      },\n    });\n  }\n\n  /** @override */\n  getFormData() {\n    const formData = new FormData();\n\n    Object.keys(this.fieldValues_).forEach((name) => {\n      const values = this.fieldValues_[name];\n      values.forEach((value) => formData.append(name, value));\n    });\n\n    return formData;\n  }\n}\n\n/**\n * Wrap the native `FormData` implementation.\n *\n * NOTE: This differs from the standard `FormData` constructor. This constructor\n * includes a submit button if it was used to submit the `opt_form`, where\n * the native `FormData` constructor does not include the submit button used to\n * submit the form.\n * {@link https://xhr.spec.whatwg.org/#dom-formdata}\n * @implements {FormDataWrapperInterface}\n */\nclass NativeFormDataWrapper {\n  /** @override */\n  constructor(opt_form) {\n    /** @private @const {!FormData} */\n    this.formData_ = new FormData(opt_form);\n\n    this.maybeIncludeSubmitButton_(opt_form);\n  }\n\n  /**\n   * If a submit button is focused (because it was used to submit the form),\n   * or was the first submit button present, add its name and value to the\n   * `FormData`, since publishers expect the submit button to be present.\n   * @param {!HTMLFormElement=} opt_form\n   * @private\n   */\n  maybeIncludeSubmitButton_(opt_form) {\n    // If a form is not passed to the constructor,\n    // we are not in a submitting code path.\n    if (!opt_form) {\n      return;\n    }\n\n    const button = getSubmitButtonUsed(opt_form);\n    if (button && button.name) {\n      this.append(button.name, button.value);\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {string|!File} value\n   * @param {string=} opt_filename\n   * @override\n   */\n  append(name, value, opt_filename) {\n    this.formData_.append(name, value);\n  }\n\n  /** @override */\n  delete(name) {\n    this.formData_.delete(name);\n  }\n\n  /** @override */\n  entries() {\n    return this.formData_.entries();\n  }\n\n  /** @override */\n  getFormData() {\n    return this.formData_;\n  }\n}\n\n/**\n * iOS 11 has a bug when submitting empty file inputs.\n * This works around the bug by replacing the empty files with Blob objects.\n */\nclass Ios11NativeFormDataWrapper extends NativeFormDataWrapper {\n  /** @override */\n  constructor(opt_form) {\n    super(opt_form);\n\n    if (opt_form) {\n      iterateCursor(opt_form.elements, (input) => {\n        if (input.type == 'file' && input.files.length == 0) {\n          this.formData_.delete(input.name);\n          this.formData_.append(input.name, new Blob([]), '');\n        }\n      });\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {string|!File} value\n   * @param {string=} opt_filename\n   * @override\n   */\n  append(name, value, opt_filename) {\n    // Safari 11 breaks on submitting empty File values.\n    if (value && typeof value == 'object' && isEmptyFile(value)) {\n      this.formData_.append(name, new Blob([]), opt_filename || '');\n    } else {\n      this.formData_.append(name, value);\n    }\n  }\n}\n\n/**\n * A wrapper for a native `FormData` object that allows the retrieval of entries\n * in the form data after construction even on browsers that don't natively\n * support `FormData.prototype.entries`.\n *\n * @interface\n * Subclassing `FormData` doesn't work in this case as the transpiler\n *     generates code that calls the super constructor directly using\n *     `Function.prototype.call`. WebKit (Safari) doesn't allow this and\n *     enforces that constructors be called with the `new` operator.\n */\nclass FormDataWrapperInterface {\n  /**\n   * Creates a new wrapper for a `FormData` object.\n   *\n   * If there's no native `FormData#entries`, chances are there are no native\n   * methods to read the content of the `FormData` after construction, so the\n   * only way to implement `entries` in this class is to capture the fields in\n   * the form passed to the constructor (and the arguments passed to the\n   * `append` method).\n   *\n   * This constructor should also add the submitter element as defined in the\n   * HTML spec for Form Submission Algorithm, but is not defined by the standard\n   * when using the `FormData` constructor directly.\n   *\n   * For more details on this, see http://mdn.io/FormData.\n   *\n   * @param {!HTMLFormElement=} opt_form An HTML `<form>` element \u2014 when\n   *     specified, the `FormData` object will be populated with the form's\n   *     current keys/values using the name property of each element for the\n   *     keys and their submitted value for the values. It will also encode file\n   *     input content.\n   */\n  constructor(opt_form) {}\n\n  /**\n   * Appends a new value onto an existing key inside a `FormData` object, or\n   * adds the key if it does not already exist.\n   *\n   * Appending a `File` object is not yet supported and the `filename`\n   * parameter is ignored for this wrapper.\n   *\n   * For more details on this, see http://mdn.io/FormData/append.\n   *\n   * TODO(cvializ): Update file support\n   *\n   * @param {string} unusedName The name of the field whose data is contained in\n   *     `value`.\n   * @param {string|!File} unusedValue The field's value.\n   * @param {string=} opt_filename The filename to use if the value is a file.\n   */\n  append(unusedName, unusedValue, opt_filename) {}\n\n  /**\n   * Remove the given value from the FormData.\n   *\n   * For more details on this, see http://mdn.io/FormData/delete.\n   *\n   * @param {string} unusedName The name of the field to remove from the FormData.\n   */\n  delete(unusedName) {}\n\n  /**\n   * Returns an iterator of all key/value pairs contained in this object.\n   *\n   * For more details on this, see http://mdn.io/FormData/entries.\n   *\n   * @return {!Iterator<!Array<string|!File>>}\n   */\n  entries() {}\n\n  /**\n   * Returns the wrapped native `FormData` object.\n   *\n   * @return {!FormData}\n   */\n  getFormData() {}\n}\n\n/**\n * Check if the given file is an empty file, which is the result of submitting\n * an empty `<input type=\"file\">`. These cause errors when submitting forms\n * in Safari 11.\n *\n * @param {!File} file\n * @return {boolean}\n */\nfunction isEmptyFile(file) {\n  return file.name == '' && file.size == 0;\n}\n", "import {map} from '#core/types/object';\n\n/**\n * @template T\n */\nexport class LruCache {\n  /**\n   * @param {number} capacity\n   */\n  constructor(capacity) {\n    /** @private @const {number} */\n    this.capacity_ = capacity;\n\n    /** @private {number} */\n    this.size_ = 0;\n\n    /**\n     * An incrementing counter to define the last access.\n     * @private {number}\n     */\n    this.access_ = 0;\n\n    /** @private {!Object<(number|string), {payload: T, access: number}>} */\n    this.cache_ = map();\n  }\n\n  /**\n   * Returns whether key is cached.\n   *\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  has(key) {\n    return !!this.cache_[key];\n  }\n\n  /**\n   * @param {number|string} key\n   * @return {T} The cached payload.\n   */\n  get(key) {\n    const cacheable = this.cache_[key];\n    if (cacheable) {\n      cacheable.access = ++this.access_;\n      return cacheable.payload;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {number|string} key\n   * @param {T} payload The payload to cache.\n   */\n  put(key, payload) {\n    if (!this.has(key)) {\n      this.size_++;\n    }\n    this.cache_[key] = {payload, access: this.access_};\n    this.evict_();\n  }\n\n  /**\n   * Evicts the oldest cache entry, if we've exceeded capacity.\n   */\n  evict_() {\n    if (this.size_ <= this.capacity_) {\n      return;\n    }\n\n    const cache = this.cache_;\n    let oldest = this.access_ + 1;\n    let oldestKey;\n    for (const key in cache) {\n      const {access} = cache[key];\n      if (access < oldest) {\n        oldest = access;\n        oldestKey = key;\n      }\n    }\n\n    if (oldestKey !== undefined) {\n      delete cache[oldestKey];\n      this.size_--;\n    }\n  }\n}\n", "import {LruCache} from '#core/data-structures/lru-cache';\nimport * as mode from '#core/mode';\nimport {arrayOrSingleItemToArray} from '#core/types/array';\nimport {dict, hasOwn} from '#core/types/object';\nimport {endsWith} from '#core/types/string';\nimport {parseQueryString} from '#core/types/string/url';\n\nimport {userAssert} from '#utils/log';\n\nimport {urls} from './config';\n\nconst SERVING_TYPE_PREFIX = new Set([\n  // No viewer\n  'c',\n  // In viewer\n  'v',\n  // Ad landing page\n  'a',\n  // Ad\n  'ad',\n]);\n\n/**\n * Cached a-tag to avoid memory allocation during URL parsing.\n * @type {HTMLAnchorElement}\n */\nlet cachedAnchorEl;\n\n/**\n * We cached all parsed URLs. As of now there are no use cases\n * of AMP docs that would ever parse an actual large number of URLs,\n * but we often parse the same one over and over again.\n * @type {LruCache}\n */\nlet urlCache;\n\n// eslint-disable-next-line no-script-url\nconst INVALID_PROTOCOLS = ['javascript:', 'data:', 'vbscript:'];\n\n/** @const {string} */\nexport const SOURCE_ORIGIN_PARAM = '__amp_source_origin';\n\n/**\n * Coerces a url into a location;\n * @function\n * @param {string|!Location} url\n * @return {!Location}\n */\nconst urlAsLocation = (url) =>\n  typeof url == 'string' ? parseUrlDeprecated(url) : url;\n\n/**\n * Returns the correct origin for a given window.\n * TODO(rcebulko): This really belongs under #core/window somewhere, not in url\n * @param {!Window} win\n * @return {string} origin\n */\nexport function getWinOrigin(win) {\n  return win.origin || parseUrlDeprecated(win.location.href).origin;\n}\n\n/**\n * Returns a Location-like object for the given URL. If it is relative,\n * the URL gets resolved.\n * Consider the returned object immutable. This is enforced during\n * testing by freezing the object.\n * TODO(#34453): The URL constructor isn't supported in IE11, but is supported\n * everywhere else. There's a lot of code paths (and all uses of the LruCache)\n * that are built around this polyfill. Once we can drop IE11 support and just\n * use the URL constructor, we can clear out all of parseWithA, all the URL\n * cache logic (incl. additional caches in other call-sites). Most is guarded by\n * isEsm() and is only included in nomodule builds, but still.\n * @param {string} url\n * @param {boolean=} opt_nocache\n *   Cache is always ignored on ESM builds, see https://go.amp.dev/pr/31594\n * @return {!Location}\n */\nexport function parseUrlDeprecated(url, opt_nocache) {\n  if (!cachedAnchorEl) {\n    cachedAnchorEl = /** @type {!HTMLAnchorElement} */ (\n      self.document.createElement('a')\n    );\n    urlCache = mode.isEsm()\n      ? null\n      : self.__AMP_URL_CACHE || (self.__AMP_URL_CACHE = new LruCache(100));\n  }\n\n  return parseUrlWithA(\n    cachedAnchorEl,\n    url,\n    mode.isEsm() || opt_nocache ? null : urlCache\n  );\n}\n\n/**\n * Returns a Location-like object for the given URL. If it is relative,\n * the URL gets resolved.\n * Consider the returned object immutable. This is enforced during\n * testing by freezing the object.\n * @param {!HTMLAnchorElement} anchorEl\n * @param {string} url\n * @param {LruCache=} opt_cache\n *   Cache is always ignored on ESM builds, see https://go.amp.dev/pr/31594\n * @return {!Location}\n * @restricted\n */\nexport function parseUrlWithA(anchorEl, url, opt_cache) {\n  if (mode.isEsm()) {\n    // Doing this causes the <a> to auto-set its own href to the resolved path,\n    // which would be the baseUrl for the URL constructor.\n    anchorEl.href = '';\n    return /** @type {?} */ (new URL(url, anchorEl.href));\n  }\n\n  if (opt_cache && opt_cache.has(url)) {\n    return opt_cache.get(url);\n  }\n\n  anchorEl.href = url;\n\n  // IE11 doesn't provide full URL components when parsing relative URLs.\n  // Assigning to itself again does the trick #3449.\n  if (!anchorEl.protocol) {\n    anchorEl.href = anchorEl.href;\n  }\n\n  const info = /** @type {!Location} */ ({\n    href: anchorEl.href,\n    protocol: anchorEl.protocol,\n    host: anchorEl.host,\n    hostname: anchorEl.hostname,\n    port: anchorEl.port == '0' ? '' : anchorEl.port,\n    pathname: anchorEl.pathname,\n    search: anchorEl.search,\n    hash: anchorEl.hash,\n    origin: null, // Set below.\n  });\n\n  // Some IE11 specific polyfills.\n  // 1) IE11 strips out the leading '/' in the pathname.\n  if (info.pathname[0] !== '/') {\n    info.pathname = '/' + info.pathname;\n  }\n\n  // 2) For URLs with implicit ports, IE11 parses to default ports while\n  // other browsers leave the port field empty.\n  if (\n    (info.protocol == 'http:' && info.port == 80) ||\n    (info.protocol == 'https:' && info.port == 443)\n  ) {\n    info.port = '';\n    info.host = info.hostname;\n  }\n\n  // For data URI anchorEl.origin is equal to the string 'null' which is not useful.\n  // We instead return the actual origin which is the full URL.\n  let origin;\n  if (anchorEl.origin && anchorEl.origin != 'null') {\n    origin = anchorEl.origin;\n  } else if (info.protocol == 'data:' || !info.host) {\n    origin = info.href;\n  } else {\n    origin = info.protocol + '//' + info.host;\n  }\n  info.origin = origin;\n\n  // Freeze during testing to avoid accidental mutation.\n  const frozen = mode.isTest() && Object.freeze ? Object.freeze(info) : info;\n\n  if (opt_cache) {\n    opt_cache.put(url, frozen);\n  }\n\n  return frozen;\n}\n\n/**\n * Appends the string just before the fragment part (or optionally\n * to the front of the query string) of the URL.\n * @param {string} url\n * @param {string} paramString\n * @param {boolean=} opt_addToFront\n * @return {string}\n */\nexport function appendEncodedParamStringToUrl(\n  url,\n  paramString,\n  opt_addToFront\n) {\n  if (!paramString) {\n    return url;\n  }\n  const mainAndFragment = url.split('#', 2);\n  const mainAndQuery = mainAndFragment[0].split('?', 2);\n\n  let newUrl =\n    mainAndQuery[0] +\n    (mainAndQuery[1]\n      ? opt_addToFront\n        ? `?${paramString}&${mainAndQuery[1]}`\n        : `?${mainAndQuery[1]}&${paramString}`\n      : `?${paramString}`);\n  newUrl += mainAndFragment[1] ? `#${mainAndFragment[1]}` : '';\n  return newUrl;\n}\n\n/**\n * @param {string} key\n * @param {string} value\n * @return {string}\n */\nfunction urlEncodeKeyValue(key, value) {\n  return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n}\n\n/**\n * Appends a query string field and value to a url. `key` and `value`\n * will be ran through `encodeURIComponent` before appending.\n * @param {string} url\n * @param {string} key\n * @param {string} value\n * @param {boolean=} opt_addToFront\n * @return {string}\n */\nexport function addParamToUrl(url, key, value, opt_addToFront) {\n  return appendEncodedParamStringToUrl(\n    url,\n    urlEncodeKeyValue(key, value),\n    opt_addToFront\n  );\n}\n\n/**\n * Appends query string fields and values to a url. The `params` objects'\n * `key`s and `value`s will be transformed into query string keys/values.\n * @param {string} url\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\nexport function addParamsToUrl(url, params) {\n  return appendEncodedParamStringToUrl(url, serializeQueryString(params));\n}\n\n/**\n * Append query string fields and values to a url, only if the key does not\n * exist in current query string.\n * @param {string} url\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\nexport function addMissingParamsToUrl(url, params) {\n  const location = parseUrlDeprecated(url);\n  const existingParams = parseQueryString(location.search);\n  const paramsToAdd = dict({});\n  const keys = Object.keys(params);\n  for (let i = 0; i < keys.length; i++) {\n    if (!hasOwn(existingParams, keys[i])) {\n      paramsToAdd[keys[i]] = params[keys[i]];\n    }\n  }\n  return addParamsToUrl(url, paramsToAdd);\n}\n\n/**\n * Serializes the passed parameter map into a query string with both keys\n * and values encoded.\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\nexport function serializeQueryString(params) {\n  const s = [];\n  for (const k in params) {\n    let v = params[k];\n    if (v == null) {\n      continue;\n    }\n\n    v = arrayOrSingleItemToArray(v);\n    for (let i = 0; i < v.length; i++) {\n      s.push(urlEncodeKeyValue(k, v[i]));\n    }\n  }\n  return s.join('&');\n}\n\n/**\n * Returns `true` if the URL is secure: either HTTPS or localhost (for testing).\n * @param {string|!Location} url\n * @return {boolean}\n */\nexport function isSecureUrlDeprecated(url) {\n  url = urlAsLocation(url);\n  return (\n    url.protocol == 'https:' ||\n    url.hostname == 'localhost' ||\n    url.hostname == '127.0.0.1' ||\n    endsWith(url.hostname, '.localhost')\n  );\n}\n\n/**\n * Asserts that a given url is HTTPS or protocol relative. It's a user-level\n * assert.\n *\n * Provides an exception for localhost.\n *\n * @param {?string|undefined} urlString\n * @param {!Element|string} elementContext Element where the url was found.\n * @param {string=} sourceName Used for error messages.\n * @return {string}\n */\nexport function assertHttpsUrl(\n  urlString,\n  elementContext,\n  sourceName = 'source'\n) {\n  userAssert(\n    urlString != null,\n    '%s %s must be available',\n    elementContext,\n    sourceName\n  );\n  userAssert(\n    isSecureUrlDeprecated(urlString) || /^\\/\\//.test(urlString),\n    '%s %s must start with ' +\n      '\"https://\" or \"//\" or be relative and served from ' +\n      'either https or from localhost. Invalid value: %s',\n    elementContext,\n    sourceName,\n    urlString\n  );\n  return urlString;\n}\n\n/**\n * Asserts that a given url is an absolute HTTP or HTTPS URL.\n * @param {string} urlString\n * @return {string}\n */\nexport function assertAbsoluteHttpOrHttpsUrl(urlString) {\n  userAssert(\n    /^https?\\:/i.test(urlString),\n    'URL must start with \"http://\" or \"https://\". Invalid value: %s',\n    urlString\n  );\n  return parseUrlDeprecated(urlString).href;\n}\n\n/**\n * Returns the URL without fragment. If URL doesn't contain fragment, the same\n * string is returned.\n * @param {string} url\n * @return {string}\n */\nexport function removeFragment(url) {\n  const index = url.indexOf('#');\n  if (index == -1) {\n    return url;\n  }\n  return url.substring(0, index);\n}\n\n/**\n * Returns the fragment from the URL. If the URL doesn't contain fragment,\n * the empty string is returned.\n * @param {string} url\n * @return {string}\n */\nexport function getFragment(url) {\n  const index = url.indexOf('#');\n  if (index == -1) {\n    return '';\n  }\n  return url.substring(index);\n}\n\n/**\n * Returns whether the URL has the origin of a proxy.\n * @param {string|!Location} url URL of an AMP document.\n * @return {boolean}\n */\nexport function isProxyOrigin(url) {\n  return urls.cdnProxyRegex.test(urlAsLocation(url).origin);\n}\n\n/**\n * Returns whether the URL origin is localhost.\n * @param {string|!Location} url URL of an AMP document.\n * @return {boolean}\n */\nexport function isLocalhostOrigin(url) {\n  return urls.localhostRegex.test(urlAsLocation(url).origin);\n}\n\n/**\n * @param {string} uri\n * @return {boolean}\n */\nexport function isAmpScriptUri(uri) {\n  return uri.startsWith('amp-script:');\n}\n\n/**\n * For proxy-origin URLs, returns the serving type. Otherwise, returns null.\n * E.g., 'https://amp-com.cdn.ampproject.org/a/s/amp.com/amp_document.html'\n * returns 'a'.\n * @param {string|!Location} url URL of an AMP document.\n * @return {?string}\n */\nexport function getProxyServingType(url) {\n  url = urlAsLocation(url);\n  if (!isProxyOrigin(url)) {\n    return null;\n  }\n  const path = url.pathname.split('/', 2);\n  return path[1];\n}\n\n/**\n * Returns whether the URL has valid protocol.\n * Deep link protocol is valid, but not javascript etc.\n * @param {string|!Location} url\n * @return {boolean}\n */\nexport function isProtocolValid(url) {\n  return !(url && INVALID_PROTOCOLS.includes(urlAsLocation(url).protocol));\n}\n\n/**\n * Returns a URL without AMP JS parameters.\n * @param {string} url\n * @return {string}\n */\nexport function removeAmpJsParamsFromUrl(url) {\n  const {hash, origin, pathname, search} = parseUrlDeprecated(url);\n  const searchRemoved = removeAmpJsParamsFromSearch(search);\n  return origin + pathname + searchRemoved + hash;\n}\n\n/**\n * Returns a URL without a query string.\n * @param {string} url\n * @return {string}\n */\nexport function removeSearch(url) {\n  const index = url.indexOf('?');\n  if (index == -1) {\n    return url;\n  }\n  const fragment = getFragment(url);\n  return url.substring(0, index) + fragment;\n}\n\n/**\n * Removes parameters that start with amp js parameter pattern and returns the\n * new search string.\n * @param {string} urlSearch\n * @return {string}\n */\nfunction removeAmpJsParamsFromSearch(urlSearch) {\n  // The below regex is a combo of these original patterns. Combining these,\n  // removing the corresponding `.replace` calls, and reusing\n  // removeParamsFromSearch saves ~175B. Matches params in query string:\n  // - /[?&]amp_js[^&]*/   amp_js_*\n  // - /[?&]amp_gsa[^&]*/  amp_gsa\n  // - /[?&]amp_r[^&]*/    amp_r\n  // - /[?&]amp_kit[^&]*/  amp_kit\n  // - /[?&]usqp[^&]*/     usqp (from goog experiment)\n  return removeParamsFromSearch(urlSearch, '(amp_(js[^&=]*|gsa|r|kit)|usqp)');\n}\n\n/**\n * Removes parameters with param name and returns the new search string.\n * @param {string} urlSearch\n * @param {string} paramName\n * @return {string}\n */\nexport function removeParamsFromSearch(urlSearch, paramName) {\n  // TODO: Accept paramNames as an array.\n  if (!urlSearch || urlSearch == '?') {\n    return '';\n  }\n  const paramRegex = new RegExp(`[?&]${paramName}\\\\b[^&]*`, 'g');\n  const search = urlSearch.replace(paramRegex, '').replace(/^[?&]/, '');\n  return search ? '?' + search : '';\n}\n\n/**\n * Returns the source URL of an AMP document for documents served\n * on a proxy origin or directly.\n * @param {string|!Location} url URL of an AMP document.\n * @return {string}\n */\nexport function getSourceUrl(url) {\n  url = urlAsLocation(url);\n\n  // Not a proxy URL - return the URL itself.\n  if (!isProxyOrigin(url)) {\n    return url.href;\n  }\n\n  // A proxy URL.\n  // Example path that is being matched here.\n  // https://cdn.ampproject.org/c/s/www.origin.com/foo/\n  // The /s/ is optional and signals a secure origin.\n  const path = url.pathname.split('/');\n  const prefix = path[1];\n  userAssert(\n    SERVING_TYPE_PREFIX.has(prefix),\n    'Unknown path prefix in url %s',\n    url.href\n  );\n  const domainOrHttpsSignal = path[2];\n  const origin =\n    domainOrHttpsSignal == 's'\n      ? 'https://' + decodeURIComponent(path[3])\n      : 'http://' + decodeURIComponent(domainOrHttpsSignal);\n  // Sanity test that what we found looks like a domain.\n  userAssert(origin.indexOf('.') > 0, 'Expected a . in origin %s', origin);\n  path.splice(1, domainOrHttpsSignal == 's' ? 3 : 2);\n  return (\n    origin +\n    path.join('/') +\n    removeAmpJsParamsFromSearch(url.search) +\n    (url.hash || '')\n  );\n}\n\n/**\n * Returns the source origin of an AMP document for documents served\n * on a proxy origin or directly.\n * @param {string|!Location} url URL of an AMP document.\n * @return {string} The source origin of the URL.\n */\nexport function getSourceOrigin(url) {\n  return parseUrlDeprecated(getSourceUrl(url)).origin;\n}\n\n/**\n * Returns absolute URL resolved based on the relative URL and the base.\n * @param {string} relativeUrlString\n * @param {string|!Location} baseUrl\n * @return {string}\n */\nexport function resolveRelativeUrl(relativeUrlString, baseUrl) {\n  baseUrl = urlAsLocation(baseUrl);\n  if (mode.isEsm() || typeof URL == 'function') {\n    return new URL(relativeUrlString, baseUrl.href).toString();\n  }\n  return resolveRelativeUrlFallback_(relativeUrlString, baseUrl);\n}\n\n/**\n * Fallback for URL resolver when URL class is not available.\n * @param {string} relativeUrlString\n * @param {string|!Location} baseUrl\n * @return {string}\n * @private @visibleForTesting\n */\nexport function resolveRelativeUrlFallback_(relativeUrlString, baseUrl) {\n  baseUrl = urlAsLocation(baseUrl);\n  relativeUrlString = relativeUrlString.replace(/\\\\/g, '/');\n  const relativeUrl = parseUrlDeprecated(relativeUrlString);\n\n  // Absolute URL.\n  if (relativeUrlString.toLowerCase().startsWith(relativeUrl.protocol)) {\n    return relativeUrl.href;\n  }\n\n  // Protocol-relative URL.\n  if (relativeUrlString.startsWith('//')) {\n    return baseUrl.protocol + relativeUrlString;\n  }\n\n  // Absolute path.\n  if (relativeUrlString.startsWith('/')) {\n    return baseUrl.origin + relativeUrlString;\n  }\n\n  // Relative path.\n  return (\n    baseUrl.origin +\n    baseUrl.pathname.replace(/\\/[^/]*$/, '/') +\n    relativeUrlString\n  );\n}\n\n/**\n * Add \"__amp_source_origin\" query parameter to the URL.\n * @param {!Window} win\n * @param {string} url\n * @return {string}\n */\nexport function getCorsUrl(win, url) {\n  checkCorsUrl(url);\n  const sourceOrigin = getSourceOrigin(win.location.href);\n  return addParamToUrl(url, SOURCE_ORIGIN_PARAM, sourceOrigin);\n}\n\n/**\n * Checks if the url has __amp_source_origin and throws if it does.\n * @param {string} url\n */\nexport function checkCorsUrl(url) {\n  const parsedUrl = parseUrlDeprecated(url);\n  const query = parseQueryString(parsedUrl.search);\n  userAssert(\n    !(SOURCE_ORIGIN_PARAM in query),\n    'Source origin is not allowed in %s',\n    url\n  );\n}\n\n/**\n * Adds the path to the given url.\n *\n * @param {!Location} url\n * @param {string} path\n * @return {string}\n */\nexport function appendPathToUrl(url, path) {\n  const pathname = url.pathname.replace(/\\/?$/, '/') + path.replace(/^\\//, '');\n  return url.origin + pathname + url.search + url.hash;\n}\n", "import {devAssert, userAssert} from '#core/assert';\nimport {fromIterator, isArray} from '#core/types/array';\nimport {dict, isObject, map} from '#core/types/object';\n\nimport {isExperimentOn} from '#experiments';\n\nimport {Services} from '#service';\n\nimport {user} from '#utils/log';\n\nimport {isFormDataWrapper} from '../form-data-wrapper';\nimport {getMode} from '../mode';\nimport {\n  getCorsUrl,\n  getWinOrigin,\n  isProxyOrigin,\n  parseUrlDeprecated,\n  serializeQueryString,\n} from '../url';\n\n/** @private @const {!Array<string>} */\nconst allowedMethods_ = ['GET', 'POST'];\n\n/** @private @const {!Array<function(*):boolean>} */\nconst allowedJsonBodyTypes_ = [isArray, isObject];\n\n/**\n * Serializes a fetch request so that it can be passed to `postMessage()`,\n * i.e., can be cloned using the\n * [structured clone algorithm](http://mdn.io/Structured_clone_algorithm).\n *\n * The request is serialized in the following way:\n *\n * 1. If the `init.body` is a `FormData`, set content-type header to\n * `multipart/form-data` and transform `init.body` into an\n * `!Array<!Array<string>>` holding the list of form entries, where each\n * element in the array is a form entry (key-value pair) represented as a\n * 2-element array.\n *\n * 2. Return a new object having properties `input` and the transformed\n * `init`.\n *\n * The serialized request is assumed to be de-serialized in the following way:\n *\n * 1.If content-type header starts with `multipart/form-data`\n * (case-insensitive), transform the entry array in `init.body` into a\n * `FormData` object.\n *\n * 2. Pass `input` and transformed `init` to `fetch` (or the constructor of\n * `Request`).\n *\n * Currently only `FormData` used in `init.body` is handled as it's the only\n * type being used in AMP runtime that needs serialization. The `Headers` type\n * also needs serialization, but callers should not be passing `Headers`\n * object in `init`, as that fails `fetchPolyfill` on browsers that don't\n * support fetch. Some serialization-needing types for `init.body` such as\n * `ArrayBuffer` and `Blob` are already supported by the structured clone\n * algorithm. Other serialization-needing types such as `URLSearchParams`\n * (which is not supported in IE and Safari) and `FederatedCredentials` are\n * not used in AMP runtime. `init.body` can also be a string\n * (application/x-www-form-urlencoded) but that doesn't require serialization.\n *\n * @param {string} input The URL of the XHR to convert to structured\n *     cloneable.\n * @param {!FetchInitDef} init The options of the XHR to convert to structured\n *     cloneable.\n * @return {{input: string, init: !FetchInitDef}} The serialized structurally-\n *     cloneable request.\n */\nexport function toStructuredCloneable(input, init) {\n  const newInit = /** @type {!FetchInitDef} */ ({...init});\n  if (isFormDataWrapper(init.body)) {\n    const wrapper = /** @type {!FormDataWrapperInterface} */ (init.body);\n    newInit.headers['Content-Type'] = 'multipart/form-data;charset=utf-8';\n    newInit.body = fromIterator(wrapper.entries());\n  }\n  return {input, init: newInit};\n}\n\n/**\n * De-serializes a fetch response that was made possible to be passed to\n * `postMessage()`, i.e., can be cloned using the\n * [structured clone algorithm](http://mdn.io/Structured_clone_algorithm).\n *\n * The response is assumed to be serialized in the following way:\n *\n * 1. Transform the entries in the headers of the response into an\n * `!Array<!Array<string>>` holding the list of header entries, where each\n * element in the array is a header entry (key-value pair) represented as a\n * 2-element array. The header key is case-insensitive.\n *\n * 2. Include the header entry list and `status` and `statusText` properties\n * of the response in as `headers`, `status` and `statusText` properties of\n * `init`.\n *\n * 3. Include the body of the response serialized as string in `body`.\n *\n * 4. Return a new object having properties `body` and `init`.\n *\n * The response is de-serialized in the following way:\n *\n * 1. If the `Response` type is supported and `responseType` is not\n * document, pass `body` and `init` directly to the constructor of `Response`.\n *\n * 2. Otherwise, populate a fake XHR object to pass to `FetchResponse` as if\n * the response is returned by the fetch polyfill.\n *\n * 3. If `responseType` is `document`, also parse the body and populate\n * `responseXML` as a `Document` type.\n *\n * @param {JsonObject|string|undefined} response The structurally-cloneable\n *     response to convert back to a regular Response.\n * @param {string|undefined} responseType The original response type used to\n *     initiate the XHR.\n * @return {!Response} The deserialized regular response.\n * @private\n */\nexport function fromStructuredCloneable(response, responseType) {\n  userAssert(isObject(response), 'Object expected: %s', response);\n\n  const isDocumentType = responseType == 'document';\n  if (!isDocumentType) {\n    // Use native `Response` type if available for performance. If response\n    // type is `document`, we must fall back to `FetchResponse` polyfill\n    // because callers would then rely on the `responseXML` property being\n    // present, which is not supported by the Response type.\n    return new Response(response['body'], response['init']);\n  }\n\n  const lowercasedHeaders = map();\n  const data = {\n    status: 200,\n    statusText: 'OK',\n    /**\n     * @param {string} name\n     * @return {string}\n     */\n    getResponseHeader(name) {\n      return lowercasedHeaders[String(name).toLowerCase()] || null;\n    },\n  };\n\n  if (response['init']) {\n    const init = response['init'];\n    if (isArray(init.headers)) {\n      /** @type {!Array} */ (init.headers).forEach((entry) => {\n        const headerName = entry[0];\n        const headerValue = entry[1];\n        lowercasedHeaders[String(headerName).toLowerCase()] =\n          String(headerValue);\n      });\n    }\n    if (init.status) {\n      data.status = parseInt(init.status, 10);\n    }\n    if (init.statusText) {\n      data.statusText = String(init.statusText);\n    }\n  }\n\n  return new Response(response['body'] ? String(response['body']) : '', data);\n}\n\n/**\n * Intercepts the XHR and proxies it through the viewer if necessary.\n *\n * XHRs are intercepted if all of the following are true:\n * - The AMP doc is in single doc mode\n * - The requested resource is not a 1p request.\n * - The viewer has the `xhrInterceptor` capability\n * - The Viewer is a trusted viewer or AMP is currently in developement mode\n * - The AMP doc is opted-in for XHR interception (`<html>` tag has\n *   `allow-xhr-interception` attribute)\n *\n * @param {!Window} win\n * @param {?../service/ampdoc-impl.AmpDoc} ampdocSingle\n * @param {string} input The URL of the XHR which may get intercepted.\n * @param {!FetchInitDef} init The options of the XHR which may get\n *     intercepted.\n * @return {!Promise<!Response|undefined>}\n *     A response returned by the interceptor if XHR is intercepted or\n *     `Promise<undefined>` otherwise.\n */\nexport function getViewerInterceptResponse(win, ampdocSingle, input, init) {\n  if (!ampdocSingle) {\n    return Promise.resolve();\n  }\n\n  const whenUnblocked = init.prerenderSafe\n    ? Promise.resolve()\n    : ampdocSingle.whenFirstVisible();\n  const viewer = Services.viewerForDoc(ampdocSingle);\n  const urlIsProxy = isProxyOrigin(input);\n  const viewerCanIntercept = viewer.hasCapability('xhrInterceptor');\n  const interceptorDisabledForLocalDev =\n    init.bypassInterceptorForDev && getMode(win).localDev;\n  if (urlIsProxy || !viewerCanIntercept || interceptorDisabledForLocalDev) {\n    return whenUnblocked;\n  }\n\n  const htmlElement = ampdocSingle.getRootNode().documentElement;\n  const docOptedIn = htmlElement.hasAttribute('allow-xhr-interception');\n  if (!docOptedIn) {\n    return whenUnblocked;\n  }\n\n  return whenUnblocked\n    .then(() => viewer.isTrustedViewer())\n    .then((viewerTrusted) => {\n      if (\n        !(\n          viewerTrusted ||\n          getMode(win).localDev ||\n          isExperimentOn(win, 'untrusted-xhr-interception')\n        )\n      ) {\n        return;\n      }\n      const messagePayload = dict({\n        'originalRequest': toStructuredCloneable(input, init),\n      });\n      return viewer\n        .sendMessageAwaitResponse('xhr', messagePayload)\n        .then((response) =>\n          fromStructuredCloneable(response, init.responseType)\n        );\n    });\n}\n\n/**\n * Sets up URL based on ampCors\n * @param {!Window} win\n * @param {string} input\n * @param {!FetchInitDef} init The options of the XHR which may get\n * intercepted.\n * @return {string}\n */\nexport function setupInput(win, input, init) {\n  devAssert(typeof input == 'string', 'Only URL supported: %s', input);\n  if (init.ampCors !== false) {\n    input = getCorsUrl(win, input);\n  }\n  return input;\n}\n\n/**\n * Sets up and normalizes the FetchInitDef\n *\n * @param {?FetchInitDef=} opt_init Fetch options object.\n * @param {string=} opt_accept The HTTP Accept header value.\n * @return {!FetchInitDef}\n */\nexport function setupInit(opt_init, opt_accept) {\n  const init = opt_init || {};\n\n  // In particular, Firefox does not tolerate `null` values for\n  // `credentials`.\n  const creds = init.credentials;\n  devAssert(\n    creds === undefined || creds == 'include' || creds == 'omit',\n    'Only credentials=include|omit support: %s',\n    creds\n  );\n\n  init.method = normalizeMethod_(init.method);\n  init.headers = init.headers || dict({});\n  if (opt_accept) {\n    init.headers['Accept'] = opt_accept;\n  }\n\n  // In edge a `TypeMismatchError` is thrown when body is set to null.\n  devAssert(init.body !== null, 'fetch `body` can not be `null`');\n\n  return init;\n}\n\n/**\n *\n * Sets up AMPSpecific CORS headers.\n * @param {!Window} win\n * @param {string} input\n * @param {?FetchInitDef=} init\n * @return {!FetchInitDef}\n */\nexport function setupAMPCors(win, input, init) {\n  init = init || {};\n  // For some same origin requests, add AMP-Same-Origin: true header to allow\n  // publishers to validate that this request came from their own origin.\n  const currentOrigin = getWinOrigin(win);\n  const targetOrigin = parseUrlDeprecated(input).origin;\n  if (currentOrigin == targetOrigin) {\n    init['headers'] = init['headers'] || {};\n    init['headers']['AMP-Same-Origin'] = 'true';\n  }\n  return init;\n}\n\n/**\n * @param {?FetchInitDef=} init\n * @return {!FetchInitDef}\n */\nexport function setupJsonFetchInit(init) {\n  const fetchInit = setupInit(init, 'application/json');\n  if (fetchInit.method == 'POST' && !isFormDataWrapper(fetchInit.body)) {\n    // Assume JSON strict mode where only objects or arrays are allowed\n    // as body.\n    devAssert(\n      allowedJsonBodyTypes_.some((test) => test(fetchInit.body)),\n      'body must be of type object or array. %s',\n      fetchInit.body\n    );\n\n    // Content should be 'text/plain' to avoid CORS preflight.\n    fetchInit.headers['Content-Type'] =\n      fetchInit.headers['Content-Type'] || 'text/plain;charset=utf-8';\n    const headerContentType = fetchInit.headers['Content-Type'];\n    // Cast is valid, because we checked that it is not form data above.\n    if (headerContentType === 'application/x-www-form-urlencoded') {\n      fetchInit.body = serializeQueryString(\n        /** @type {!JsonObject} */ (fetchInit.body)\n      );\n    } else {\n      fetchInit.body = JSON.stringify(\n        /** @type {!JsonObject} */ (fetchInit.body)\n      );\n    }\n  }\n  return fetchInit;\n}\n\n/**\n * Normalized method name by uppercasing.\n * @param {string|undefined} method\n * @return {string}\n * @private\n */\nfunction normalizeMethod_(method) {\n  if (method === undefined) {\n    return 'GET';\n  }\n  method = method.toUpperCase();\n  devAssert(\n    allowedMethods_.includes(method),\n    'Only one of %s is currently allowed. Got %s',\n    allowedMethods_.join(', '),\n    method\n  );\n  return method;\n}\n\n/**\n * If 415 or in the 5xx range.\n * @param {number} status\n * @return {boolean}\n */\nfunction isRetriable(status) {\n  return status == 415 || (status >= 500 && status < 600);\n}\n\n/**\n * Returns the response if successful or otherwise throws an error.\n * @param {!Response} response\n * @return {!Promise<!Response>}\n */\nexport function assertSuccess(response) {\n  return new Promise((resolve) => {\n    if (response.ok) {\n      return resolve(response);\n    }\n\n    const {status} = response;\n    const err = user().createError(`HTTP error ${status}`);\n    err['retriable'] = isRetriable(status);\n    // TODO(@jridgewell, #9448): Callers who need the response should\n    // skip processing.\n    err['response'] = response;\n    throw err;\n  });\n}\n", "// Note: loaded by 3p system. Cannot rely on babel polyfills.\nimport {devAssert} from '#core/assert';\nimport {devError} from '#core/error';\nimport {map} from '#core/types/object';\n\n/** @type {Object<string, string>} */\nlet propertyNameCache;\n\n/** @const {!Array<string>} */\nconst vendorPrefixes = ['Webkit', 'webkit', 'Moz', 'moz', 'ms', 'O', 'o'];\n\nconst DISPLAY_STYLE_MESSAGE =\n  '`display` style detected. You must use toggle instead.';\n\nconst EMPTY_CSS_DECLARATION = /** @type {!CSSStyleDeclaration} */ ({\n  'getPropertyPriority': () => '',\n  'getPropertyValue': () => '',\n});\n\n/**\n * @param {string} camelCase camel cased string\n * @return {string} title cased string\n */\nexport function camelCaseToTitleCase(camelCase) {\n  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n}\n\n/**\n  Checks the style if a prefixed version of a property exists and returns\n * it or returns an empty string.\n * @private\n * @param {!Object} style\n * @param {string} titleCase the title case version of a css property name\n * @return {string} the prefixed property name or null.\n */\nfunction getVendorJsPropertyName_(style, titleCase) {\n  for (let i = 0; i < vendorPrefixes.length; i++) {\n    const propertyName = vendorPrefixes[i] + titleCase;\n    if (style[propertyName] !== undefined) {\n      return propertyName;\n    }\n  }\n  return '';\n}\n\n/**\n * Returns the possibly prefixed JavaScript property name of a style property\n * (ex. WebkitTransitionDuration) given a camelCase'd version of the property\n * (ex. transitionDuration).\n * @param {!Object} style\n * @param {string} camelCase the camel cased version of a css property name\n * @param {boolean=} opt_bypassCache bypass the memoized cache of property\n *   mapping\n * @return {string}\n */\nexport function getVendorJsPropertyName(style, camelCase, opt_bypassCache) {\n  if (isVar(camelCase)) {\n    // CSS vars are returned as is.\n    return camelCase;\n  }\n  if (!propertyNameCache) {\n    propertyNameCache = map();\n  }\n  let propertyName = propertyNameCache[camelCase];\n  if (!propertyName || opt_bypassCache) {\n    propertyName = camelCase;\n    if (style[camelCase] === undefined) {\n      const titleCase = camelCaseToTitleCase(camelCase);\n      const prefixedPropertyName = getVendorJsPropertyName_(style, titleCase);\n\n      if (style[prefixedPropertyName] !== undefined) {\n        propertyName = prefixedPropertyName;\n      }\n    }\n    if (!opt_bypassCache) {\n      propertyNameCache[camelCase] = propertyName;\n    }\n  }\n  return propertyName;\n}\n\n/**\n * Sets the CSS styles of the specified element with !important. The styles\n * are specified as a map from CSS property names to their values.\n * @param {!Element} element\n * @param {!Object<string, *>} styles\n */\nexport function setImportantStyles(element, styles) {\n  const {style} = element;\n  for (const k in styles) {\n    style.setProperty(\n      getVendorJsPropertyName(style, k),\n      String(styles[k]),\n      'important'\n    );\n  }\n}\n\n/**\n * Sets the CSS style of the specified element with optional units, e.g. \"px\".\n * @param {?Element} element\n * @param {string} property\n * @param {*} value\n * @param {string=} opt_units\n * @param {boolean=} opt_bypassCache\n */\nexport function setStyle(element, property, value, opt_units, opt_bypassCache) {\n  const propertyName = getVendorJsPropertyName(\n    element.style,\n    property,\n    opt_bypassCache\n  );\n  if (!propertyName) {\n    return;\n  }\n  const styleValue = /** @type {string} */ (\n    opt_units ? value + opt_units : value\n  );\n  if (isVar(propertyName)) {\n    element.style.setProperty(propertyName, styleValue);\n  } else {\n    element.style[propertyName] = styleValue;\n  }\n}\n\n/**\n * Returns the value of the CSS style of the specified element.\n * @param {!Element} element\n * @param {string} property\n * @param {boolean=} opt_bypassCache\n * @return {*}\n */\nexport function getStyle(element, property, opt_bypassCache) {\n  const propertyName = getVendorJsPropertyName(\n    element.style,\n    property,\n    opt_bypassCache\n  );\n  if (!propertyName) {\n    return undefined;\n  }\n  if (isVar(propertyName)) {\n    return element.style.getPropertyValue(propertyName);\n  }\n  return element.style[propertyName];\n}\n\n/**\n * Sets the CSS styles of the specified element. The styles\n * a specified as a map from CSS property names to their values.\n * @param {!Element} element\n * @param {!Object<string, *>} styles\n */\nexport function setStyles(element, styles) {\n  for (const k in styles) {\n    setStyle(element, k, styles[k]);\n  }\n}\n\n/**\n * Sets the initial display style of an element. This is a last resort. If you\n * can set the initial display using CSS, YOU MUST.\n * DO NOT USE THIS TO ARBITRARILY SET THE DISPLAY STYLE AFTER INITIAL SETUP.\n *\n * @param {!Element} el\n * @param {string} value\n */\nexport function setInitialDisplay(el, value) {\n  const {style} = el;\n  devAssert(\n    value !== '' && value !== 'none',\n    'Initial display value must not be \"none\". Use toggle instead.'\n  );\n  devAssert(\n    !style['display'],\n    'setInitialDisplay MUST NOT be used for ' +\n      'resetting the display style. If you are looking for display:none ' +\n      'toggling, use toggle instead.'\n  );\n  style['display'] = value;\n}\n\n/**\n * Shows or hides the specified element.\n * @param {!Element} element\n * @param {boolean=} opt_display\n */\nexport function toggle(element, opt_display) {\n  if (opt_display === undefined) {\n    opt_display = element.hasAttribute('hidden');\n  }\n  if (opt_display) {\n    element.removeAttribute('hidden');\n  } else {\n    element.setAttribute('hidden', '');\n  }\n}\n\n/**\n * Returns a pixel value.\n * @param {number} value\n * @return {string}\n */\nexport function px(value) {\n  return `${value}px`;\n}\n\n/**\n * Returns a degree value.\n * @param {number} value\n * @return {string}\n */\nexport function deg(value) {\n  return `${value}deg`;\n}\n\n/**\n * Coerces a number into a string with units.\n * @param {number|string} value\n * @param {function(number):string} fn\n * @return {string}\n */\nfunction units(value, fn) {\n  return typeof value == 'number' ? fn(value) : value;\n}\n\n/**\n * Returns a \"translateX\" for CSS \"transform\" property.\n * @param {number|string} value\n * @return {string}\n */\nexport function translateX(value) {\n  return `translateX(${units(value, px)})`;\n}\n\n/**\n * Returns a \"translateX\" for CSS \"transform\" property.\n * @param {number|string} x\n * @param {(number|string|null)=} opt_y\n * @return {string}\n */\nexport function translate(x, opt_y) {\n  return opt_y === undefined || opt_y === null\n    ? `translate(${units(x, px)})`\n    : `translate(${units(x, px)}, ${units(opt_y, px)})`;\n}\n\n/**\n * Returns a \"scale\" for CSS \"transform\" property.\n * @param {number|string} value\n * @return {string}\n */\nexport function scale(value) {\n  return `scale(${value})`;\n}\n\n/**\n * Returns a \"rotate\" for CSS \"transform\" property.\n * @param {number|string} value\n * @return {string}\n */\nexport function rotate(value) {\n  return `rotate(${units(value, deg)})`;\n}\n\n/**\n * Remove alpha value from a rgba color value.\n * Return the new color property with alpha equals if has the alpha value.\n * Caller needs to make sure the input color value is a valid rgba/rgb value\n * @param {string} rgbaColor\n * @return {string}\n */\nexport function removeAlphaFromColor(rgbaColor) {\n  return rgbaColor.replace(\n    /\\(([^,]+),([^,]+),([^,)]+),[^)]+\\)/g,\n    '($1,$2,$3, 1)'\n  );\n}\n\n/**\n * Gets the computed style of the element. The helper is necessary to enforce\n * the possible `null` value returned by a buggy Firefox.\n *\n * @param {!Window} win\n * @param {!Element} el\n * @return {!CSSStyleDeclaration}\n */\nexport function computedStyle(win, el) {\n  const style = /** @type {?CSSStyleDeclaration} */ (win.getComputedStyle(el));\n  return style || EMPTY_CSS_DECLARATION;\n}\n\n/**\n * Resets styles that were set dynamically (i.e. inline)\n * @param {!Element} element\n * @param {!Array<string>} properties\n */\nexport function resetStyles(element, properties) {\n  for (let i = 0; i < properties.length; i++) {\n    setStyle(element, properties[i], null);\n  }\n}\n\n/**\n * Propagates the object-fit/position element attributes as styles.\n * @param {!Element} fromEl ie: amp-img\n * @param {!Element} toEl ie: the img within amp-img\n */\nexport function propagateObjectFitStyles(fromEl, toEl) {\n  if (fromEl.hasAttribute('object-fit')) {\n    setStyle(toEl, 'object-fit', fromEl.getAttribute('object-fit'));\n  }\n\n  if (fromEl.hasAttribute('object-position')) {\n    setStyle(toEl, 'object-position', fromEl.getAttribute('object-position'));\n  }\n}\n\n/**\n * @param {string} property\n * @return {boolean}\n */\nfunction isVar(property) {\n  return property.startsWith('--');\n}\n\n/**\n * Asserts that the style is not the `display` style.\n * This is the only possible way to pass a dynamic style to setStyle.\n *\n * If you wish to set `display`, use the `toggle` helper instead. This is so\n * changes to display can trigger necessary updates. See #17475.\n *\n * @param {string} style\n * @return {string}\n */\nexport function assertNotDisplay(style) {\n  // TODO(rcebulko): This calls itself an assert, but doesn't throw an error.\n  // Should it throw sync? If so, this/below can reduce to\n  // `return devAssert(style == 'display', DISPLAY_STYLE_MESSAGE);`\n  if (style === 'display') {\n    devError('STYLE', DISPLAY_STYLE_MESSAGE);\n  }\n  return style;\n}\n\n/**\n * Asserts that the styles does not contain the `display` style.\n * This is the only possible way to pass a dynamic styles object to setStyles\n * and setImportantStyles.\n *\n * If you wish to set `display`, use the `toggle` helper instead. This is so\n * changes to display can trigger necessary updates. See #17475.\n *\n * @param {!Object<string, *>} styles\n * @return {!Object<string, *>}\n */\nexport function assertDoesNotContainDisplay(styles) {\n  if ('display' in styles) {\n    devError('STYLE', DISPLAY_STYLE_MESSAGE);\n  }\n  return styles;\n}\n", "import {AmpEvents} from '#core/constants/amp-events';\nimport {iterateCursor, removeElement} from '#core/dom';\nimport {computedStyle, px, setStyle} from '#core/dom/style';\nimport {toArray} from '#core/types/array';\nimport {throttle} from '#core/types/function';\n\nimport {Services} from '#service';\n\nimport {listen, listenOncePromise} from '#utils/event-helper';\nimport {dev, devAssert, user} from '#utils/log';\n\nconst AMP_FORM_TEXTAREA_EXPAND_ATTR = 'autoexpand';\n\nconst MIN_EVENT_INTERVAL_MS = 100;\n\nconst AMP_FORM_TEXTAREA_CLONE_CSS = 'i-amphtml-textarea-clone';\n\nconst AMP_FORM_TEXTAREA_MAX_CSS = 'i-amphtml-textarea-max';\n\nconst AMP_FORM_TEXTAREA_HAS_EXPANDED_DATA = 'iAmphtmlHasExpanded';\n\n/**\n * Install expandable textarea behavior for the given form.\n *\n * This class should be able to be removed when browsers implement\n * `height: max-content` for the textarea element.\n * https://github.com/w3c/csswg-drafts/issues/2141\n */\nexport class AmpFormTextarea {\n  /**\n   * Install, monitor and cleanup the document as `textarea[autoexpand]`\n   * elements are added and removed.\n   * @param {!../../../src/service/ampdoc-impl.AmpDoc} ampdoc\n   */\n  static install(ampdoc) {\n    const root = ampdoc.getRootNode();\n\n    let ampFormTextarea = null;\n    const maybeInstall = () => {\n      const autoexpandTextarea = root.querySelector('textarea[autoexpand]');\n      if (autoexpandTextarea && !ampFormTextarea) {\n        ampFormTextarea = new AmpFormTextarea(ampdoc);\n        return;\n      }\n\n      if (!autoexpandTextarea && ampFormTextarea) {\n        ampFormTextarea.dispose();\n        ampFormTextarea = null;\n        return;\n      }\n    };\n\n    listen(root, AmpEvents.DOM_UPDATE, maybeInstall);\n    maybeInstall();\n  }\n\n  /**\n   * @param {!../../../src/service/ampdoc-impl.AmpDoc} ampdoc\n   */\n  constructor(ampdoc) {\n    const root = ampdoc.getRootNode();\n\n    /** @private @const */\n    this.doc_ = root.ownerDocument || root;\n\n    /** @private @const */\n    this.win_ = /** @type {!Window} */ (devAssert(this.doc_.defaultView));\n\n    /** @private @const */\n    this.viewport_ = Services.viewportForDoc(ampdoc);\n\n    /** @private */\n    this.unlisteners_ = [];\n\n    this.unlisteners_.push(\n      listen(root, 'input', (e) => {\n        const element = dev().assertElement(e.target);\n        if (\n          element.tagName != 'TEXTAREA' ||\n          !element.hasAttribute(AMP_FORM_TEXTAREA_EXPAND_ATTR)\n        ) {\n          return;\n        }\n\n        maybeResizeTextarea(element);\n      })\n    );\n\n    this.unlisteners_.push(\n      listen(root, 'mousedown', (e) => {\n        if (e.which != 1) {\n          return;\n        }\n\n        const element = dev().assertElement(e.target);\n        // Handle all text area drag as we want to measure mutate and notify\n        // the viewer of possible doc height changes.\n        if (element.tagName != 'TEXTAREA') {\n          return;\n        }\n\n        handleTextareaDrag(element);\n      })\n    );\n\n    let cachedTextareaElements = root.querySelectorAll('textarea');\n    this.unlisteners_.push(\n      listen(root, AmpEvents.DOM_UPDATE, () => {\n        cachedTextareaElements = root.querySelectorAll('textarea');\n      })\n    );\n    const throttledResize = throttle(\n      this.win_,\n      (e) => {\n        if (e.relayoutAll) {\n          resizeTextareaElements(cachedTextareaElements);\n        }\n      },\n      MIN_EVENT_INTERVAL_MS\n    );\n    this.unlisteners_.push(this.viewport_.onResize(throttledResize));\n\n    handleInitialOverflowElements(cachedTextareaElements);\n  }\n\n  /**\n   * Cleanup any consumed resources\n   */\n  dispose() {\n    this.unlisteners_.forEach((unlistener) => unlistener());\n  }\n}\n\n/**\n * For now, warn if textareas with initial overflow are present, and\n * prevent them from becoming autoexpand textareas.\n * @param {!IArrayLike<!Element>} textareas\n * @return {!Promise}\n */\nexport function handleInitialOverflowElements(textareas) {\n  return Promise.all(\n    toArray(textareas).map((element) => {\n      return getHasOverflow(element).then((hasOverflow) => {\n        if (hasOverflow) {\n          user().warn(\n            'AMP-FORM',\n            '\"textarea[autoexpand]\" with initially scrolling content ' +\n              'will not autoexpand.\\n' +\n              'See https://github.com/ampproject/amphtml/issues/20839'\n          );\n          element.removeAttribute(AMP_FORM_TEXTAREA_EXPAND_ATTR);\n        }\n      });\n    })\n  );\n}\n\n/**\n * Measure if any overflow is present on the element.\n * @param {!Element} element\n * @return {!Promise<boolean>}\n * @visibleForTesting\n */\nexport function getHasOverflow(element) {\n  const mutator = Services.mutatorForDoc(element);\n  return mutator.measureElement(() => {\n    return element./*OK*/ scrollHeight > element./*OK*/ clientHeight;\n  });\n}\n\n/**\n * Attempt to resize all textarea elements\n * @param {!IArrayLike<!Element>} elements\n */\nfunction resizeTextareaElements(elements) {\n  iterateCursor(elements, (element) => {\n    if (\n      element.tagName != 'TEXTAREA' ||\n      !element.hasAttribute(AMP_FORM_TEXTAREA_EXPAND_ATTR)\n    ) {\n      return;\n    }\n\n    maybeResizeTextarea(element);\n  });\n}\n\n/**\n * This makes no assumptions about the location of the resize handle, and it\n * assumes that if the user drags the mouse at any position and the height of\n * the textarea changes, then the user intentionally resized the textarea.\n * @param {!Element} element\n */\nfunction handleTextareaDrag(element) {\n  const mutator = Services.mutatorForDoc(element);\n\n  Promise.all([\n    mutator.measureElement(() => element./*OK*/ scrollHeight),\n    listenOncePromise(element, 'mouseup'),\n  ]).then((results) => {\n    const heightMouseDown = results[0];\n    let heightMouseUp = 0;\n\n    return mutator.measureMutateElement(\n      element,\n      () => {\n        heightMouseUp = element./*OK*/ scrollHeight;\n      },\n      () => {\n        maybeRemoveResizeBehavior(element, heightMouseDown, heightMouseUp);\n      }\n    );\n  });\n}\n\n/**\n * Remove the resize behavior if a user drags the resize handle and changes\n * the height of the textarea.\n * @param {!Element} element\n * @param {number} startHeight\n * @param {number} endHeight\n */\nfunction maybeRemoveResizeBehavior(element, startHeight, endHeight) {\n  if (startHeight != endHeight) {\n    element.removeAttribute(AMP_FORM_TEXTAREA_EXPAND_ATTR);\n  }\n}\n\n/**\n * Resize the textarea to fit its current text, by expanding or shrinking if\n * needed.\n * @param {!Element} element\n * @return {!Promise}\n * @visibleForTesting\n */\nexport function maybeResizeTextarea(element) {\n  const mutator = Services.mutatorForDoc(element);\n  const win = /** @type {!Window} */ (\n    devAssert(element.ownerDocument.defaultView)\n  );\n\n  let offset = 0;\n  let scrollHeight = 0;\n  let maxHeight = 0;\n\n  // The minScrollHeight is the minimimum height required to contain the\n  // text content without showing a scrollbar.\n  // This is different than scrollHeight, which is the larger of: 1. the\n  // element's content, or 2. the element itself.\n  const minScrollHeightPromise = getShrinkHeight(element);\n\n  return mutator.measureMutateElement(\n    element,\n    () => {\n      const computed = computedStyle(win, element);\n      scrollHeight = element./*OK*/ scrollHeight;\n\n      const maybeMaxHeight = parseInt(\n        computed.getPropertyValue('max-height'),\n        10\n      );\n      maxHeight = isNaN(maybeMaxHeight) ? Infinity : maybeMaxHeight;\n\n      if (computed.getPropertyValue('box-sizing') == 'content-box') {\n        offset =\n          -parseInt(computed.getPropertyValue('padding-top'), 10) +\n          -parseInt(computed.getPropertyValue('padding-bottom'), 10);\n      } else {\n        offset =\n          parseInt(computed.getPropertyValue('border-top-width'), 10) +\n          parseInt(computed.getPropertyValue('border-bottom-width'), 10);\n      }\n    },\n    () => {\n      return minScrollHeightPromise.then((minScrollHeight) => {\n        const height = minScrollHeight + offset;\n        // Prevent the scrollbar from appearing\n        // unless the text is beyond the max-height\n        element.classList.toggle(AMP_FORM_TEXTAREA_MAX_CSS, height > maxHeight);\n\n        // Prevent the textarea from shrinking if it has not yet expanded.\n        const hasExpanded =\n          AMP_FORM_TEXTAREA_HAS_EXPANDED_DATA in element.dataset;\n\n        // There is super specific a bug in Chrome affecting scrollHeight calculation\n        // for textareas with padding when the document is zoomed in.\n        // It makes the scrollHeight calculation off by ~1px.\n        // This is why we have a small error margin.\n        // TODO: Remove error margin when chrome bug is resolved (https://bugs.chromium.org/p/chromium/issues/detail?id=1171989).\n        const errorMargin = /google/i.test(win.navigator.vendor) ? 3 : 0;\n        const shouldResize =\n          hasExpanded || scrollHeight <= minScrollHeight + errorMargin;\n\n        if (shouldResize) {\n          element.dataset[AMP_FORM_TEXTAREA_HAS_EXPANDED_DATA] = '';\n          // Set the textarea height to the height of the text\n          setStyle(element, 'height', px(minScrollHeight + offset));\n        }\n      });\n    }\n  );\n}\n\n/**\n * If shrink behavior is enabled, get the amount to shrink or expand. This\n * uses a more expensive method to calculate the new height creating a temporary\n * clone of the node and setting its height to 0 to get the minimum scrollHeight\n * of the element's contents.\n * @param {!Element} textarea\n * @return {!Promise<number>}\n */\nfunction getShrinkHeight(textarea) {\n  const doc = /** @type {!Document} */ (devAssert(textarea.ownerDocument));\n  const win = /** @type {!Window} */ (devAssert(doc.defaultView));\n  const body = /** @type {!HTMLBodyElement} */ (devAssert(doc.body));\n  const mutator = Services.mutatorForDoc(textarea);\n\n  const clone = textarea.cloneNode(/*deep*/ false);\n  clone.classList.add(AMP_FORM_TEXTAREA_CLONE_CSS);\n\n  let cloneWidth = 0;\n  let resultingHeight = 0;\n  let shouldKeepTop = false;\n\n  return mutator\n    .measureMutateElement(\n      body,\n      () => {\n        const computed = computedStyle(win, textarea);\n        const maxHeight = parseInt(computed.getPropertyValue('max-height'), 10); // TODO(cvializ): what if it's a percent?\n        cloneWidth = parseInt(computed.getPropertyValue('width'), 10);\n        // maxHeight is NaN if the max-height property is 'none'.\n        shouldKeepTop =\n          isNaN(maxHeight) || textarea./*OK*/ scrollHeight < maxHeight;\n      },\n      () => {\n        // Prevent a jump from the textarea element scrolling\n        if (shouldKeepTop) {\n          textarea./*OK*/ scrollTop = 0;\n        }\n\n        // Keep the clone's width consistent if the textarea was sized relative\n        // to its parent element.\n        setStyle(clone, 'width', px(cloneWidth));\n\n        // Append the clone to the DOM so its scrollHeight can be read\n        doc.body.appendChild(clone);\n      }\n    )\n    .then(() => {\n      return mutator.measureMutateElement(\n        body,\n        () => {\n          resultingHeight = clone./*OK*/ scrollHeight;\n        },\n        () => {\n          removeElement(clone);\n        }\n      );\n    })\n    .then(() => resultingHeight);\n}\n", "import {AmpEvents} from '#core/constants/amp-events';\nimport {isDisabled, isFieldDefault, isFieldEmpty} from '#core/dom/form';\nimport {dict, map} from '#core/types/object';\n\nimport {createCustomEvent} from '#utils/event-helper';\nimport {dev} from '#utils/log';\n\nimport {createFormDataWrapper} from '../../../src/form-data-wrapper';\n\nexport const DIRTINESS_INDICATOR_CLASS = 'amp-form-dirty';\n\n/** @private {!Object<string, boolean>} */\nconst SUPPORTED_TAG_NAMES = {\n  'INPUT': true,\n  'SELECT': true,\n  'TEXTAREA': true,\n};\n\nexport class FormDirtiness {\n  /**\n   * @param {!HTMLFormElement} form\n   * @param {!Window} win\n   */\n  constructor(form, win) {\n    /** @private @const {!HTMLFormElement} */\n    this.form_ = form;\n\n    /** @private @const {!Window} */\n    this.win_ = win;\n\n    /** @private {number} */\n    this.dirtyFieldCount_ = 0;\n\n    /** @private {!Object<string, boolean>} */\n    this.isFieldNameDirty_ = map();\n\n    /** @private {?FormData} */\n    this.submittedFormData_ = null;\n\n    /** @private {boolean} */\n    this.isSubmitting_ = false;\n\n    /** @private {boolean} */\n    this.wasDirty_ = false;\n\n    this.installEventHandlers_();\n\n    // New forms are usually clean. However, if `amp-bind` mutates a form field\n    // before the `amp-form` is initialized, the `amp-form` will miss the\n    // `FORM_VALUE_CHANGE` event dispatched.\n    this.determineInitialDirtiness_();\n  }\n\n  /**\n   * Processes dirtiness state when a form is being submitted. This puts the\n   * form in a \"submitting\" state, and temporarily clears the dirtiness state.\n   */\n  onSubmitting() {\n    this.isSubmitting_ = true;\n    this.updateClassAndDispatchEventIfDirtyStateChanged_();\n  }\n\n  /**\n   * Processes dirtiness state when the form submission fails. This clears the\n   * \"submitting\" state and reverts the form's dirtiness state.\n   */\n  onSubmitError() {\n    this.isSubmitting_ = false;\n    this.updateClassAndDispatchEventIfDirtyStateChanged_();\n  }\n\n  /**\n   * Processes dirtiness state when the form submission succeeds. This clears\n   * the \"submitting\" state and the form's overall dirtiness.\n   */\n  onSubmitSuccess() {\n    this.isSubmitting_ = false;\n    this.submittedFormData_ = this.takeFormDataSnapshot_();\n    this.clearDirtyFields_();\n    this.updateClassAndDispatchEventIfDirtyStateChanged_();\n  }\n\n  /**\n   * @return {!FormData}\n   * @private\n   */\n  takeFormDataSnapshot_() {\n    return createFormDataWrapper(this.win_, this.form_).getFormData();\n  }\n\n  /**\n   * Adds or removes the `amp-form-dirty` class and dispatches a\n   * `FORM_DIRTINESS_CHANGE` event that reflects the current dirtiness state,\n   * when the form dirtiness state changes. Does nothing otherwise.\n   * @private\n   */\n  updateClassAndDispatchEventIfDirtyStateChanged_() {\n    const isDirty = this.dirtyFieldCount_ > 0 && !this.isSubmitting_;\n\n    if (isDirty !== this.wasDirty_) {\n      this.form_.classList.toggle(DIRTINESS_INDICATOR_CLASS, isDirty);\n\n      const formDirtinessChangeEvent = createCustomEvent(\n        this.win_,\n        AmpEvents.FORM_DIRTINESS_CHANGE,\n        dict({'isDirty': isDirty}),\n        {bubbles: true}\n      );\n      this.form_.dispatchEvent(formDirtinessChangeEvent);\n    }\n\n    this.wasDirty_ = isDirty;\n  }\n\n  /**\n   * @private\n   */\n  installEventHandlers_() {\n    this.form_.addEventListener('input', this.onInput_.bind(this));\n    this.form_.addEventListener('reset', this.onReset_.bind(this));\n\n    // `amp-bind` dispatches the custom event `FORM_VALUE_CHANGE` when it\n    // mutates the value of a form field (e.g. textarea, input, etc)\n    this.form_.addEventListener(\n      AmpEvents.FORM_VALUE_CHANGE,\n      this.onInput_.bind(this)\n    );\n  }\n\n  /** @private */\n  determineInitialDirtiness_() {\n    for (let i = 0; i < this.form_.elements.length; ++i) {\n      this.checkDirtinessAfterUserInteraction_(this.form_.elements[i]);\n    }\n    this.updateClassAndDispatchEventIfDirtyStateChanged_();\n  }\n\n  /**\n   * Listens to form field value changes, determines the field's dirtiness, and\n   * updates the form's overall dirtiness.\n   * @param {!Event} event\n   * @private\n   */\n  onInput_(event) {\n    const field = dev().assertElement(event.target);\n    this.checkDirtinessAfterUserInteraction_(field);\n    this.updateClassAndDispatchEventIfDirtyStateChanged_();\n  }\n\n  /**\n   * Listens to the form reset event, and clears the overall dirtiness.\n   * @param {!Event} unusedEvent\n   * @private\n   */\n  onReset_(unusedEvent) {\n    this.clearDirtyFields_();\n    this.updateClassAndDispatchEventIfDirtyStateChanged_();\n  }\n\n  /**\n   * Determine the given field's dirtiness.\n   * @param {!Element} field\n   * @private\n   */\n  checkDirtinessAfterUserInteraction_(field) {\n    if (shouldSkipDirtinessCheck(field)) {\n      return;\n    }\n\n    if (\n      isFieldEmpty(field) ||\n      isFieldDefault(field) ||\n      this.isFieldSameAsLastSubmission_(field)\n    ) {\n      this.removeDirtyField_(field.name);\n    } else {\n      this.addDirtyField_(field.name);\n    }\n  }\n\n  /**\n   * Returns true if the form field's current value matches its most recent\n   * submitted value.\n   * @param {!Element} field\n   * @return {boolean}\n   * @private\n   */\n  isFieldSameAsLastSubmission_(field) {\n    if (!this.submittedFormData_) {\n      return false;\n    }\n    const {name, value} = field;\n    return this.submittedFormData_.get(name) === value;\n  }\n\n  /**\n   * Mark the field as dirty and increase the overall dirty field count, if the\n   * field is previously clean.\n   * @param {string} fieldName\n   * @private\n   */\n  addDirtyField_(fieldName) {\n    if (!this.isFieldNameDirty_[fieldName]) {\n      this.isFieldNameDirty_[fieldName] = true;\n      ++this.dirtyFieldCount_;\n    }\n  }\n\n  /**\n   * Mark the field as clean and decrease the overall dirty field count, if the\n   * field is previously dirty.\n   * @param {string} fieldName\n   * @private\n   */\n  removeDirtyField_(fieldName) {\n    if (this.isFieldNameDirty_[fieldName]) {\n      this.isFieldNameDirty_[fieldName] = false;\n      --this.dirtyFieldCount_;\n    }\n  }\n\n  /**\n   * Clears the dirty field name map and counter.\n   * @private\n   */\n  clearDirtyFields_() {\n    this.isFieldNameDirty_ = map();\n    this.dirtyFieldCount_ = 0;\n  }\n}\n\n/**\n * Returns true if the form should be subject to dirtiness check. Unsupported\n * elements, disabled elements, hidden elements, or elements without the `name`\n * attribute are skipped.\n * @param {!Element} field\n * @return {boolean}\n */\nfunction shouldSkipDirtinessCheck(field) {\n  const {hidden, name, tagName} = field;\n\n  if (!SUPPORTED_TAG_NAMES[tagName]) {\n    return true;\n  }\n\n  return !name || hidden || isDisabled(field);\n}\n", "/** @enum {string} */\nexport const FormEvents = {\n  INVALID: 'invalid',\n  SERVICE_INIT: 'amp:form-service:initialize', // Dispatched by the window when AmpFormService initializes.\n  SUBMIT_ERROR: 'submit-error',\n  SUBMIT_SUCCESS: 'submit-success',\n  SUBMIT: 'submit',\n  VALID: 'valid',\n  VERIFY_ERROR: 'verify-error',\n  VERIFY: 'verify',\n};\n", "import {getWin} from '#core/window';\n\nimport {Services} from '#service';\n\nimport {dev, devAssert} from '#utils/log';\n\n/**\n * denylisted properties. Used mainly fot testing.\n * @type {?Array<string>}\n */\nlet denylistedProperties = null;\n\n/**\n * @param {?Array<string>} properties\n * @visibleForTesting\n */\nexport function setDenylistedPropertiesForTesting(properties) {\n  denylistedProperties = properties;\n}\n\n/**\n * Creates a proxy object `form.$p` that proxies all of the methods and\n * properties to the original DOM APIs. This is to work around the problematic\n * forms feature where inputs mask DOM APIs.\n *\n * E.g. a `<input id=\"id\">` will override `form.id` from the original DOM API.\n * Form proxy will give access to the original `id` value via `form.$p.id`.\n *\n * See https://medium.com/@dvoytenko/solving-conflicts-between-form-inputs-and-dom-api-535c45333ae4\n *\n * @param {!HTMLFormElement} form\n * @return {!Object}\n */\nexport function installFormProxy(form) {\n  const constr = getFormProxyConstr(getWin(form));\n  const proxy = new constr(form);\n  if (!('action' in proxy)) {\n    setupLegacyProxy(form, proxy);\n  }\n  form['$p'] = proxy;\n  return proxy;\n}\n\n/**\n * @param {!Window} win\n * @return {function(new:Object, !HTMLFormElement)}\n */\nfunction getFormProxyConstr(win) {\n  if (!win.FormProxy) {\n    win.FormProxy = createFormProxyConstr(win);\n  }\n  return win.FormProxy;\n}\n\n/**\n * @param {!Window} win\n * @return {function(new:Object, !HTMLFormElement)}\n */\nfunction createFormProxyConstr(win) {\n  /**\n   * @param {!HTMLFormElement} form\n   * @constructor\n   */\n  function FormProxy(form) {\n    /** @private @const {!HTMLFormElement} */\n    this.form_ = form;\n  }\n\n  const FormProxyProto = FormProxy.prototype;\n  const {Object} = win;\n  const ObjectProto = Object.prototype;\n\n  // Hierarchy:\n  //   Node  <==  Element <== HTMLElement <== HTMLFormElement\n  //   EventTarget  <==  HTMLFormElement\n  const baseClasses = [win.HTMLFormElement, win.EventTarget];\n  const inheritance = baseClasses.reduce((all, klass) => {\n    let proto = klass && klass.prototype;\n    while (proto && proto !== ObjectProto) {\n      if (all.indexOf(proto) >= 0) {\n        break;\n      }\n      all.push(proto);\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    return all;\n  }, []);\n\n  /** @type {!Array} */ (inheritance).forEach((proto) => {\n    for (const name in proto) {\n      const property = win.Object.getOwnPropertyDescriptor(proto, name);\n      if (\n        !property ||\n        // Exclude constants.\n        name.toUpperCase() == name ||\n        // Exclude on-events.\n        name.startsWith('on') ||\n        // Exclude properties that already been created.\n        ObjectProto.hasOwnProperty.call(FormProxyProto, name) ||\n        // Exclude some properties. Currently only used for testing.\n        (denylistedProperties && denylistedProperties.includes(name))\n      ) {\n        continue;\n      }\n      if (typeof property.value == 'function') {\n        // A method call. Call the original prototype method via `call`.\n        const method = property.value;\n        FormProxyProto[name] = function () {\n          return method.apply(\n            /** @type {!FormProxy} */ (this).form_,\n            arguments\n          );\n        };\n      } else {\n        // A read/write property. Call the original prototype getter/setter.\n        const spec = {};\n        if (property.get) {\n          spec.get = function () {\n            return property.get.call(/** @type {!FormProxy} */ (this).form_);\n          };\n        }\n        if (property.set) {\n          spec.set = function (v) {\n            return property.set.call(/** @type {!FormProxy} */ (this).form_, v);\n          };\n        }\n        win.Object.defineProperty(FormProxyProto, name, spec);\n      }\n    }\n  });\n\n  return FormProxy;\n}\n\n/**\n * This is a very heavy-handed way to support browsers that do not have\n * properties defined in the prototype chain. Specifically, this is necessary\n * for Chrome 45 and under.\n *\n * See https://developers.google.com/web/updates/2015/04/DOM-attributes-now-on-the-prototype-chain\n * for more info.\n *\n * @param {!HTMLFormElement} form\n * @param {!Object} proxy\n */\nfunction setupLegacyProxy(form, proxy) {\n  const win = form.ownerDocument.defaultView;\n  const proto = win.HTMLFormElement.prototype.cloneNode.call(\n    form,\n    /* deep */ false\n  );\n  for (const name in proto) {\n    if (\n      name in proxy ||\n      // Exclude constants.\n      name.toUpperCase() == name ||\n      // Exclude on-events.\n      name.startsWith('on')\n    ) {\n      continue;\n    }\n    const desc = LEGACY_PROPS[name];\n    const current = form[name];\n    if (desc) {\n      if (desc.access == LegacyPropAccessType.READ_ONCE) {\n        // A property such as `style`. The only way is to read this value\n        // once and use it for all subsequent calls.\n        let actual;\n        if (current && current.nodeType) {\n          // The overriding input, if present, has to be removed and re-added\n          // (renaming does NOT work). Completely insane, I know.\n          const element = dev().assertElement(current);\n          const {nextSibling, parentNode: parent} = element;\n          parent.removeChild(element);\n          try {\n            actual = form[name];\n          } finally {\n            parent.insertBefore(element, nextSibling);\n          }\n        } else {\n          actual = current;\n        }\n        Object.defineProperty(proxy, name, {\n          get() {\n            return actual;\n          },\n        });\n      } else if (desc.access == LegacyPropAccessType.ATTR) {\n        // An attribute-based property. We can use DOM API to read and write\n        // with a minimal type conversion.\n        const attr = desc.attr || name;\n        Object.defineProperty(proxy, name, {\n          get() {\n            const value = proxy.getAttribute(attr);\n            if (value == null && desc.def !== undefined) {\n              return desc.def;\n            }\n            if (desc.type == LegacyPropDataType.BOOL) {\n              return value === 'true';\n            }\n            if (desc.type == LegacyPropDataType.TOGGLE) {\n              return value != null;\n            }\n            if (desc.type == LegacyPropDataType.URL) {\n              // URLs, e.g. in `action` attribute are resolved against the\n              // document's base.\n              const str = /** @type {string} */ (value || '');\n              return Services.urlForDoc(form).parse(str).href;\n            }\n            return value;\n          },\n          set(value) {\n            if (desc.type == LegacyPropDataType.TOGGLE) {\n              if (value) {\n                value = '';\n              } else {\n                value = null;\n              }\n            }\n            if (value != null) {\n              proxy.setAttribute(attr, value);\n            } else {\n              proxy.removeAttribute(attr);\n            }\n          },\n        });\n      } else {\n        devAssert(false, 'unknown property access type: %s', desc.access);\n      }\n    } else {\n      // Not a known property - proxy directly.\n      Object.defineProperty(proxy, name, {\n        get() {\n          return form[name];\n        },\n        set(value) {\n          form[name] = value;\n        },\n      });\n    }\n  }\n}\n\n/**\n * @enum {number}\n */\nconst LegacyPropAccessType = {\n  ATTR: 1,\n  READ_ONCE: 2,\n};\n\n/**\n * @enum {number}\n */\nconst LegacyPropDataType = {\n  URL: 1,\n  BOOL: 2,\n  TOGGLE: 3,\n};\n\n/**\n * @const {!Object<string, {\n *   access: !LegacyPropAccessType,\n *   attr: (string|undefined),\n *   type: (LegacyPropDataType|undefined),\n *   def: *,\n * }>}\n */\nconst LEGACY_PROPS = {\n  'acceptCharset': {\n    access: LegacyPropAccessType.ATTR,\n    attr: 'accept-charset',\n  },\n  'accessKey': {\n    access: LegacyPropAccessType.ATTR,\n    attr: 'accesskey',\n  },\n  'action': {\n    access: LegacyPropAccessType.ATTR,\n    type: LegacyPropDataType.URL,\n  },\n  'attributes': {\n    access: LegacyPropAccessType.READ_ONCE,\n  },\n  'autocomplete': {\n    access: LegacyPropAccessType.ATTR,\n    def: 'on',\n  },\n  'children': {\n    access: LegacyPropAccessType.READ_ONCE,\n  },\n  'dataset': {\n    access: LegacyPropAccessType.READ_ONCE,\n  },\n  'dir': {\n    access: LegacyPropAccessType.ATTR,\n  },\n  'draggable': {\n    access: LegacyPropAccessType.ATTR,\n    type: LegacyPropDataType.BOOL,\n    def: false,\n  },\n  'elements': {\n    access: LegacyPropAccessType.READ_ONCE,\n  },\n  'encoding': {\n    access: LegacyPropAccessType.READ_ONCE,\n  },\n  'enctype': {\n    access: LegacyPropAccessType.ATTR,\n  },\n  'hidden': {\n    access: LegacyPropAccessType.ATTR,\n    type: LegacyPropDataType.TOGGLE,\n    def: false,\n  },\n  'id': {\n    access: LegacyPropAccessType.ATTR,\n    def: '',\n  },\n  'lang': {\n    access: LegacyPropAccessType.ATTR,\n  },\n  'localName': {\n    access: LegacyPropAccessType.READ_ONCE,\n  },\n  'method': {\n    access: LegacyPropAccessType.ATTR,\n    def: 'get',\n  },\n  'name': {\n    access: LegacyPropAccessType.ATTR,\n  },\n  'noValidate': {\n    access: LegacyPropAccessType.ATTR,\n    attr: 'novalidate',\n    type: LegacyPropDataType.TOGGLE,\n    def: false,\n  },\n  'prefix': {\n    access: LegacyPropAccessType.READ_ONCE,\n  },\n  'spellcheck': {\n    access: LegacyPropAccessType.ATTR,\n  },\n  'style': {\n    access: LegacyPropAccessType.READ_ONCE,\n  },\n  'target': {\n    access: LegacyPropAccessType.ATTR,\n    def: '',\n  },\n  'title': {\n    access: LegacyPropAccessType.ATTR,\n  },\n  'translate': {\n    access: LegacyPropAccessType.ATTR,\n  },\n};\n", "import {removeItem} from '#core/types/array';\n\n/**\n * This class helps to manage observers. Observers can be added, removed or\n * fired through and instance of this class.\n * @template TYPE\n */\nexport class Observable {\n  /**\n   * Creates an instance of Observable.\n   */\n  constructor() {\n    /** @type {?Array<function(TYPE)>} */\n    this.handlers_ = null;\n  }\n\n  /**\n   * Adds the observer to this instance.\n   * @param {function(TYPE)} handler Observer's handler.\n   * @return {!UnlistenDef}\n   */\n  add(handler) {\n    if (!this.handlers_) {\n      this.handlers_ = [];\n    }\n    this.handlers_.push(handler);\n    return () => {\n      this.remove(handler);\n    };\n  }\n\n  /**\n   * Removes the observer from this instance.\n   * @param {function(TYPE)} handler Observer's instance.\n   */\n  remove(handler) {\n    if (!this.handlers_) {\n      return;\n    }\n    removeItem(this.handlers_, handler);\n  }\n\n  /**\n   * Removes all observers.\n   */\n  removeAll() {\n    if (!this.handlers_) {\n      return;\n    }\n    this.handlers_.length = 0;\n  }\n\n  /**\n   * Fires an event. All observers are called.\n   * @param {TYPE=} opt_event\n   */\n  fire(opt_event) {\n    if (!this.handlers_) {\n      return;\n    }\n    for (const handler of this.handlers_) {\n      handler(opt_event);\n    }\n  }\n\n  /**\n   * Returns number of handlers. Mostly needed for tests.\n   * @return {number}\n   */\n  getHandlerCount() {\n    return this.handlers_?.length ?? 0;\n  }\n}\n", "import {Observable} from '#core/data-structures/observable';\n\n/**\n * @typedef {{\n *   form: !HTMLFormElement,\n *   actionXhrMutator: function(string)\n * }}\n */\nexport let FormSubmitEventDef;\n\nexport class FormSubmitService {\n  /**\n   * Global service used to register callbacks we wish to execute when an\n   * amp-form is submitted.\n   */\n  constructor() {\n    this.observable_ = new Observable();\n  }\n\n  /**\n   * Used to register callbacks.\n   * @param {function(!FormSubmitEventDef)} cb\n   * @return {!UnlistenDef}\n   */\n  beforeSubmit(cb) {\n    return this.observable_.add(cb);\n  }\n\n  /**\n   * Fired when form is submitted.\n   * @param {!FormSubmitEventDef} event\n   */\n  fire(event) {\n    this.observable_.fire(event);\n  }\n}\n", "import {removeChildren} from '#core/dom';\nimport {setStyles, toggle} from '#core/dom/style';\n\nimport {Services} from '#service';\n\n/** @type {string} */\nconst OBJ_PROP = '__BUBBLE_OBJ';\n\nexport class ValidationBubble {\n  /**\n   * Creates a bubble component to display messages in.\n   * @param {!../../../src/service/ampdoc-impl.AmpDoc} ampdoc\n   * @param {string} id\n   */\n  constructor(ampdoc, id) {\n    /** @private @const {string} */\n    this.id_ = id;\n\n    /** @private @const {!../../../src/service/viewport/viewport-interface.ViewportInterface} */\n    this.viewport_ = Services.viewportForDoc(ampdoc);\n\n    /** @private @const {!../../../src/service/vsync-impl.Vsync} */\n    this.vsync_ = Services.vsyncFor(ampdoc.win);\n\n    /** @private {?Element} */\n    this.currentTargetElement_ = null;\n\n    /** @private {string} */\n    this.currentMessage_ = '';\n\n    /** @private {boolean} */\n    this.isVisible_ = false;\n\n    /** @private @const {!Element} */\n    this.bubbleElement_ = ampdoc.win.document.createElement('div');\n    toggle(this.bubbleElement_, false);\n\n    this.bubbleElement_.classList.add('i-amphtml-validation-bubble');\n    this.bubbleElement_[OBJ_PROP] = this;\n    ampdoc.getBody().appendChild(this.bubbleElement_);\n  }\n\n  /**\n   * @param {!Element} element\n   * @return {boolean}\n   */\n  isActiveOn(element) {\n    return this.isVisible_ && element == this.currentTargetElement_;\n  }\n\n  /**\n   * Hides the bubble off screen.\n   */\n  hide() {\n    if (!this.isVisible_) {\n      return;\n    }\n\n    this.isVisible_ = false;\n    this.currentTargetElement_ = null;\n    this.currentMessage_ = '';\n\n    this.vsync_.run(\n      {\n        measure: undefined,\n        mutate: hideBubble,\n      },\n      {\n        bubbleElement: this.bubbleElement_,\n      }\n    );\n  }\n\n  /**\n   * Shows the bubble targeted to an element with the passed message.\n   * @param {!Element} targetElement\n   * @param {string} message\n   */\n  show(targetElement, message) {\n    if (this.isActiveOn(targetElement) && message == this.currentMessage_) {\n      return;\n    }\n\n    this.isVisible_ = true;\n    this.currentTargetElement_ = targetElement;\n    this.currentMessage_ = message;\n    const state = {\n      message,\n      targetElement,\n      bubbleElement: this.bubbleElement_,\n      viewport: this.viewport_,\n      id: this.id_,\n    };\n    this.vsync_.run(\n      {\n        measure: measureTargetElement,\n        mutate: showBubbleElement,\n      },\n      state\n    );\n  }\n}\n\n/**\n * Hides the bubble element passed through state object.\n * @param {!Object} state\n * @private\n */\nfunction hideBubble(state) {\n  state.bubbleElement.removeAttribute('aria-alert');\n  state.bubbleElement.removeAttribute('role');\n  removeChildren(state.bubbleElement);\n  toggle(state.bubbleElement, false);\n}\n\n/**\n * Measures the layout for the target element passed through state object.\n * @param {!Object} state\n * @private\n */\nfunction measureTargetElement(state) {\n  state.targetRect = state.viewport.getLayoutRect(state.targetElement);\n}\n\n/**\n * Updates text content, positions and displays the bubble.\n * @param {!Object} state\n * @private\n */\nfunction showBubbleElement(state) {\n  removeChildren(state.bubbleElement);\n  const messageDiv = state.bubbleElement.ownerDocument.createElement('div');\n  messageDiv.id = `bubble-message-${state.id}`;\n  messageDiv.textContent = state.message;\n  state.bubbleElement.setAttribute('aria-labeledby', messageDiv.id);\n  state.bubbleElement.setAttribute('role', 'alert');\n  state.bubbleElement.setAttribute('aria-live', 'assertive');\n  state.bubbleElement.appendChild(messageDiv);\n  toggle(state.bubbleElement, true);\n  setStyles(state.bubbleElement, {\n    top: `${state.targetRect.top - 10}px`,\n    left: `${state.targetRect.left + state.targetRect.width / 2}px`,\n  });\n}\n", "import {iterateCursor} from '#core/dom';\nimport {getWin} from '#core/window';\n\nimport {Services} from '#service';\n\nimport {createCustomEvent} from '#utils/event-helper';\nimport {dev} from '#utils/log';\n\nimport {FormEvents} from './form-events';\nimport {ValidationBubble} from './validation-bubble';\n\n/** @const @private {string} */\nconst VALIDATION_CACHE_PREFIX = '__AMP_VALIDATION_';\n\n/** @const @private {string} */\nconst VISIBLE_VALIDATION_CACHE = '__AMP_VISIBLE_VALIDATION';\n\n/** @const @private {string} */\nconst ARIA_DESC_ID_PREFIX = 'i-amphtml-aria-desc-';\n\n/**\n * Validation user message for non-standard pattern mismatch errors.\n * Note this isn't localized but custom validation can be used instead.\n * @const @private {string}\n */\nconst CUSTOM_PATTERN_ERROR = 'Please match the requested format.';\n\n/** @type {boolean|undefined} */\nlet reportValiditySupported;\n\n/** @type {boolean|undefined} */\nlet checkValiditySupported;\n\n/** @type {number} */\nlet validationBubbleCount = 0;\n\n/**\n * @param {boolean} isSupported\n * @private visible for testing.\n */\nexport function setReportValiditySupportedForTesting(isSupported) {\n  reportValiditySupported = isSupported;\n}\n\n/**\n * @param {boolean} isSupported\n * @private visible for testing.\n */\nexport function setCheckValiditySupportedForTesting(isSupported) {\n  checkValiditySupported = isSupported;\n}\n\n/** @const @enum {string} */\nconst CustomValidationTypes = {\n  AsYouGo: 'as-you-go',\n  ShowAllOnSubmit: 'show-all-on-submit',\n  InteractAndSubmit: 'interact-and-submit',\n  ShowFirstOnSubmit: 'show-first-on-submit',\n};\n\n/**\n * Form validator interface.\n * @abstract\n */\nexport class FormValidator {\n  /**\n   * @param {!HTMLFormElement} form\n   */\n  constructor(form) {\n    /** @protected @const {!HTMLFormElement} */\n    this.form = form;\n\n    /** @protected @const {!../../../src/service/ampdoc-impl.AmpDoc} */\n    this.ampdoc = Services.ampdoc(form);\n\n    /** @const @protected {!../../../src/service/mutator-interface.MutatorInterface} */\n    this.mutator = Services.mutatorForDoc(form);\n\n    /** @protected @const {!Document|!ShadowRoot} */\n    this.root = this.ampdoc.getRootNode();\n\n    /**\n     * Tribool indicating last known validity of form.\n     * @private {?boolean}\n     */\n    this.formValidity_ = null;\n  }\n\n  /**\n   * Called to report validation errors.\n   */\n  report() {}\n\n  /**\n   * @param {!Event} unusedEvent\n   */\n  onBlur(unusedEvent) {}\n\n  /**\n   * @param {!Event} unusedEvent\n   */\n  onInput(unusedEvent) {}\n\n  /** @return {!NodeList} */\n  inputs() {\n    return this.form.querySelectorAll('input,select,textarea');\n  }\n\n  /**\n   * Wraps `checkValidity` on input elements to support `pattern` attribute on\n   * <textarea> which is not supported in HTML5.\n   * @param {!Element} input\n   * @return {boolean}\n   * @protected\n   */\n  checkInputValidity(input) {\n    if (input.tagName === 'TEXTAREA' && input.hasAttribute('pattern')) {\n      // FormVerifier also uses setCustomValidity() to signal verification\n      // errors. Make sure we only override pattern errors here.\n      if (\n        input.checkValidity() ||\n        input.validationMessage === CUSTOM_PATTERN_ERROR\n      ) {\n        const pattern = input.getAttribute('pattern');\n        const re = new RegExp(`^${pattern}$`, 'm');\n        const valid = re.test(input.value);\n        input.setCustomValidity(valid ? '' : CUSTOM_PATTERN_ERROR);\n      }\n    }\n    return input.checkValidity();\n  }\n\n  /**\n   * Wraps `checkValidity` on form elements to support `pattern` attribute on\n   * <textarea> which is not supported in HTML5.\n   * @param {!HTMLFormElement} form\n   * @return {boolean}\n   * @protected\n   */\n  checkFormValidity(form) {\n    this.checkTextAreaValidityInForm_(form);\n    return form.checkValidity();\n  }\n\n  /**\n   * Wraps `reportValidity` on form elements to support `pattern` attribute on\n   * <textarea> which is not supported in HTML5.\n   * @param {!HTMLFormElement} form\n   * @return {boolean}\n   * @protected\n   */\n  reportFormValidity(form) {\n    this.checkTextAreaValidityInForm_(form);\n    return form.reportValidity();\n  }\n\n  /**\n   * @param {!HTMLFormElement} form\n   * @private\n   */\n  checkTextAreaValidityInForm_(form) {\n    iterateCursor(form.elements, (element) => {\n      if (element.tagName == 'TEXTAREA') {\n        this.checkInputValidity(element);\n      }\n    });\n  }\n\n  /**\n   * Fires a valid/invalid event from the form if its validity state\n   * has changed since the last invocation of this function.\n   * @visibleForTesting\n   */\n  fireValidityEventIfNecessary() {\n    const previousValidity = this.formValidity_;\n    this.formValidity_ = this.checkFormValidity(this.form);\n    if (previousValidity !== this.formValidity_) {\n      const win = getWin(this.form);\n      const type = this.formValidity_ ? FormEvents.VALID : FormEvents.INVALID;\n      const event = createCustomEvent(win, type, null, {bubbles: true});\n      this.form.dispatchEvent(event);\n    }\n  }\n}\n\n/** @private visible for testing */\nexport class DefaultValidator extends FormValidator {\n  /** @override */\n  report() {\n    this.reportFormValidity(this.form);\n    this.fireValidityEventIfNecessary();\n  }\n}\n\n/** @private visible for testing */\nexport class PolyfillDefaultValidator extends FormValidator {\n  /**\n   * Creates an instance of PolyfillDefaultValidator.\n   * @param {!HTMLFormElement} form\n   */\n  constructor(form) {\n    super(form);\n    const bubbleId = `i-amphtml-validation-bubble-${validationBubbleCount++}`;\n    /** @private @const {!./validation-bubble.ValidationBubble} */\n    this.validationBubble_ = new ValidationBubble(this.ampdoc, bubbleId);\n  }\n\n  /** @override */\n  report() {\n    const inputs = this.inputs();\n    for (let i = 0; i < inputs.length; i++) {\n      if (!this.checkInputValidity(inputs[i])) {\n        inputs[i]./*REVIEW*/ focus();\n        this.validationBubble_.show(inputs[i], inputs[i].validationMessage);\n        break;\n      }\n    }\n\n    this.fireValidityEventIfNecessary();\n  }\n\n  /** @override */\n  onBlur(e) {\n    // NOTE: IE11 focuses the submit button after submitting a form.\n    // Then amp-form focuses the first field with an error, which causes the\n    // submit button to blur. So we need to disregard the submit button blur.\n    if (e.target.type == 'submit') {\n      return;\n    }\n    this.validationBubble_.hide();\n  }\n\n  /** @override */\n  onInput(event) {\n    const input = dev().assertElement(event.target);\n    if (!this.validationBubble_.isActiveOn(input)) {\n      return;\n    }\n\n    if (this.checkInputValidity(input)) {\n      input.removeAttribute('aria-invalid');\n      this.validationBubble_.hide();\n    } else {\n      input.setAttribute('aria-invalid', 'true');\n      this.validationBubble_.show(input, input.validationMessage);\n    }\n  }\n}\n\n/**\n * @abstract\n * @private visible for testing\n */\nexport class AbstractCustomValidator extends FormValidator {\n  /**\n   * Creates an instance of AbstractCustomValidator.\n   * @param {!HTMLFormElement} form\n   */\n  constructor(form) {\n    super(form);\n\n    /** @private {string} */\n    this.uniqueFormId_ = this.form.id\n      ? this.form.id\n      : String(Date.now() + Math.floor(Math.random() * 100));\n\n    /**\n     * Counter used to create a unique id for every validation message\n     * to be used with `aria-describedby`.\n     * @private {number}\n     */\n    this.ariaDescCounter_ = 0;\n  }\n\n  /**\n   * @param {!Element} input\n   */\n  reportInput(input) {\n    const invalidType = getInvalidType(input);\n    if (invalidType) {\n      this.showValidationFor(input, invalidType);\n    }\n  }\n\n  /**\n   * @return {string} A unique ID.\n   * @private\n   */\n  createUniqueAriaDescId_() {\n    return `${ARIA_DESC_ID_PREFIX}${this.uniqueFormId_}-${this\n      .ariaDescCounter_++}`;\n  }\n\n  /**\n   * Hides all validation messages.\n   */\n  hideAllValidations() {\n    const inputs = this.inputs();\n    for (let i = 0; i < inputs.length; i++) {\n      this.hideValidationFor(dev().assertElement(inputs[i]));\n    }\n  }\n\n  /**\n   * @param {!Element} input\n   * @param {string=} inputInvalidType\n   * @return {?Element}\n   */\n  getValidationFor(input, inputInvalidType = undefined) {\n    if (!input.id) {\n      return null;\n    }\n    const invalidType = this.getInvalidType_(input, inputInvalidType);\n    const property = VALIDATION_CACHE_PREFIX + invalidType;\n    if (!(property in input)) {\n      const selector =\n        `[visible-when-invalid=${invalidType}]` +\n        `[validation-for=${input.id}]`;\n      input[property] = this.root.querySelector(selector);\n    }\n    return input[property];\n  }\n\n  /**\n   * Wraps the validity type for inputs to support pattern on <textarea>\n   * @param {!Element} input\n   * @param {string=} inputInvalidType\n   * @return {*} TODO(#23582): Specify return type\n   */\n  getInvalidType_(input, inputInvalidType = undefined) {\n    const {tagName, validationMessage} = input;\n\n    // <textarea> only supports `pattern` and `valueMissing`.\n    // `pattern` is implemented via setCustomValidity(),\n    // which results in the 'customError' validity state.\n    if (\n      tagName === 'TEXTAREA' &&\n      inputInvalidType === 'customError' &&\n      validationMessage === CUSTOM_PATTERN_ERROR\n    ) {\n      return 'patternMismatch';\n    }\n\n    return inputInvalidType;\n  }\n\n  /**\n   * @param {!Element} input\n   * @param {string} invalidType\n   */\n  showValidationFor(input, invalidType) {\n    const validation = this.getValidationFor(input, invalidType);\n    if (!validation) {\n      return;\n    }\n    if (!validation.textContent.trim()) {\n      validation.textContent = input.validationMessage;\n    }\n    input[VISIBLE_VALIDATION_CACHE] = validation;\n\n    let validationId = validation.getAttribute('id');\n    if (!validationId) {\n      validationId = this.createUniqueAriaDescId_();\n      validation.setAttribute('id', validationId);\n    }\n\n    input.setAttribute('aria-invalid', 'true');\n    input.setAttribute('aria-describedby', validationId);\n\n    this.mutator.mutateElement(validation, () =>\n      validation.classList.add('visible')\n    );\n  }\n\n  /**\n   * @param {!Element} input\n   */\n  hideValidationFor(input) {\n    const visibleValidation = this.getVisibleValidationFor(input);\n    if (!visibleValidation) {\n      return;\n    }\n    delete input[VISIBLE_VALIDATION_CACHE];\n\n    input.removeAttribute('aria-invalid');\n    input.removeAttribute('aria-describedby');\n\n    this.mutator.mutateElement(visibleValidation, () =>\n      visibleValidation.classList.remove('visible')\n    );\n  }\n\n  /**\n   * @param {!Element} input\n   * @return {?Element}\n   */\n  getVisibleValidationFor(input) {\n    return input[VISIBLE_VALIDATION_CACHE];\n  }\n\n  /**\n   * Whether an input should validate after an interaction.\n   * @param {!Element} unusedInput\n   * @return {boolean}\n   */\n  shouldValidateOnInteraction(unusedInput) {\n    throw Error('Not Implemented');\n  }\n\n  /**\n   * @param {!Event} event\n   */\n  onInteraction(event) {\n    const input = dev().assertElement(event.target);\n    const shouldValidate =\n      !!input.checkValidity && this.shouldValidateOnInteraction(input);\n\n    this.hideValidationFor(input);\n    if (shouldValidate && !this.checkInputValidity(input)) {\n      this.reportInput(input);\n    }\n  }\n\n  /** @override */\n  onBlur(event) {\n    this.onInteraction(event);\n  }\n\n  /** @override */\n  onInput(event) {\n    this.onInteraction(event);\n  }\n}\n\n/** @private visible for testing */\nexport class ShowFirstOnSubmitValidator extends AbstractCustomValidator {\n  /** @override */\n  report() {\n    this.hideAllValidations();\n    const inputs = this.inputs();\n    for (let i = 0; i < inputs.length; i++) {\n      if (!this.checkInputValidity(inputs[i])) {\n        this.reportInput(inputs[i]);\n        inputs[i]./*REVIEW*/ focus();\n        break;\n      }\n    }\n\n    this.fireValidityEventIfNecessary();\n  }\n\n  /** @override */\n  shouldValidateOnInteraction(input) {\n    return !!this.getVisibleValidationFor(input);\n  }\n}\n\n/** @private visible for testing */\nexport class ShowAllOnSubmitValidator extends AbstractCustomValidator {\n  /** @override */\n  report() {\n    this.hideAllValidations();\n    let firstInvalidInput = null;\n    const inputs = this.inputs();\n    for (let i = 0; i < inputs.length; i++) {\n      if (!this.checkInputValidity(inputs[i])) {\n        firstInvalidInput = firstInvalidInput || inputs[i];\n        this.reportInput(inputs[i]);\n      }\n    }\n\n    if (firstInvalidInput) {\n      firstInvalidInput./*REVIEW*/ focus();\n    }\n\n    this.fireValidityEventIfNecessary();\n  }\n\n  /** @override */\n  shouldValidateOnInteraction(input) {\n    return !!this.getVisibleValidationFor(input);\n  }\n}\n\n/** @private visible for testing */\nexport class AsYouGoValidator extends AbstractCustomValidator {\n  /** @override */\n  shouldValidateOnInteraction(unusedInput) {\n    return true;\n  }\n\n  /** @override */\n  onInteraction(event) {\n    super.onInteraction(event);\n    this.fireValidityEventIfNecessary();\n  }\n}\n\n/** @private visible for testing */\nexport class InteractAndSubmitValidator extends ShowAllOnSubmitValidator {\n  /** @override */\n  shouldValidateOnInteraction(unusedInput) {\n    return true;\n  }\n\n  /** @override */\n  onInteraction(event) {\n    super.onInteraction(event);\n    this.fireValidityEventIfNecessary();\n  }\n}\n\n/**\n * Returns the form validator instance.\n *\n * @param {!HTMLFormElement} form\n * @return {!FormValidator}\n */\nexport function getFormValidator(form) {\n  const customValidation = form.getAttribute('custom-validation-reporting');\n  switch (customValidation) {\n    case CustomValidationTypes.AsYouGo:\n      return new AsYouGoValidator(form);\n    case CustomValidationTypes.ShowAllOnSubmit:\n      return new ShowAllOnSubmitValidator(form);\n    case CustomValidationTypes.InteractAndSubmit:\n      return new InteractAndSubmitValidator(form);\n    case CustomValidationTypes.ShowFirstOnSubmit:\n      return new ShowFirstOnSubmitValidator(form);\n  }\n\n  if (isReportValiditySupported(form.ownerDocument)) {\n    return new DefaultValidator(form);\n  }\n\n  return new PolyfillDefaultValidator(form);\n}\n\n/**\n * Returns whether reportValidity API is supported.\n * @param {?Document} doc\n * @return {boolean}\n */\nfunction isReportValiditySupported(doc) {\n  if (doc && reportValiditySupported === undefined) {\n    reportValiditySupported = !!document.createElement('form').reportValidity;\n  }\n  return !!reportValiditySupported;\n}\n\n/**\n * Returns whether reportValidity API is supported.\n * @param {!Document} doc\n * @return {boolean}\n */\nexport function isCheckValiditySupported(doc) {\n  if (checkValiditySupported === undefined) {\n    checkValiditySupported = !!doc.createElement('input').checkValidity;\n  }\n  return checkValiditySupported;\n}\n\n/**\n * Returns invalid error type on the input.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/ValidityState\n * @param {!Element} input\n * @return {?string}\n */\nfunction getInvalidType(input) {\n  // 'badInput' takes precedence over others.\n  const validityTypes = ['badInput'];\n  for (const invalidType in input.validity) {\n    // add other types after\n    if (!validityTypes.includes(invalidType)) {\n      validityTypes.push(invalidType);\n    }\n  }\n  // Finding error type with value true\n  const response = validityTypes.filter(\n    (type) => input.validity[type] === true\n  );\n  return response.length ? response[0] : null;\n}\n", "import {LastAddedResolver} from '#core/data-structures/promise';\nimport {iterateCursor} from '#core/dom';\nimport {isFieldDefault} from '#core/dom/form';\n\nimport {user} from '#utils/log';\n\nexport const FORM_VERIFY_PARAM = '__amp_form_verify';\n\nexport const FORM_VERIFY_OPTOUT = 'no-verify';\n\n/**\n * @typedef {{\n *    name:string,\n *    message:string\n *  }}\n */\nlet VerificationErrorDef;\n\n/**\n * @typedef {{\n *   updatedElements:!Array<!Element>,\n *   errors:!Array<!VerificationErrorDef>\n * }}\n */\nlet UpdatedErrorsDef;\n\n/**\n * Construct the correct form verifier based on whether\n * a config block is present.\n * @param {!HTMLFormElement} form\n * @param {function():Promise<!Response>} xhr\n * @return {!FormVerifier}\n */\nexport function getFormVerifier(form, xhr) {\n  if (form.hasAttribute('verify-xhr')) {\n    return new AsyncVerifier(form, xhr);\n  } else {\n    return new DefaultVerifier(form);\n  }\n}\n\n/**\n * An interface for a form verifier. Implementations could check for duplicate\n * usernames on a remote server, check against an in-memory cache to verify\n * data in ways not possible with standard form validation, or check\n * values against sets of data too large to fit in browser memory\n * e.g. ensuring zip codes match with cities.\n * @visibleForTesting\n * @abstract\n */\nexport class FormVerifier {\n  /**\n   * @param {!HTMLFormElement} form\n   */\n  constructor(form) {\n    /** @protected @const */\n    this.form_ = form;\n  }\n\n  /**\n   * Called when the user has fully set a value to be verified,\n   * e.g. the input's 'change' event\n   * @return {!Promise<!UpdatedErrorsDef>}\n   */\n  onCommit() {\n    this.clearVerificationErrors_();\n    if (this.isDirty_()) {\n      return this.verify_();\n    } else {\n      return Promise.resolve(\n        /** @type {UpdatedErrorsDef} */ ({\n          updatedElements: [],\n          errors: [],\n        })\n      );\n    }\n  }\n\n  /**\n   * Sends the verify request if any group is ready to verify.\n   * @return {!Promise<!UpdatedErrorsDef>} The list of elements whose state\n   *    must change\n   * @protected\n   */\n  verify_() {\n    return Promise.resolve(\n      /** @type {UpdatedErrorsDef} */ ({\n        updatedElements: [],\n        errors: [],\n      })\n    );\n  }\n\n  /**\n   * Checks if the form has been changed from its initial state.\n   * @return {boolean}\n   * @private\n   */\n  isDirty_() {\n    const {elements} = this.form_;\n    for (let i = 0; i < elements.length; i++) {\n      const field = elements[i];\n      if (field.disabled) {\n        continue;\n      }\n\n      if (!isFieldDefault(field)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Removes all custom verification errors from the elements.\n   * @private\n   */\n  clearVerificationErrors_() {\n    const {elements} = this.form_;\n    if (elements) {\n      iterateCursor(elements, (e) => {\n        e.setCustomValidity('');\n      });\n    }\n  }\n}\n\n/**\n * A no-op verifier.\n * @visibleForTesting\n */\nexport class DefaultVerifier extends FormVerifier {}\n\n/**\n * A verifier that verifies values via an XHR\n * @visibleForTesting\n */\nexport class AsyncVerifier extends FormVerifier {\n  /**\n   * @param {!HTMLFormElement} form\n   * @param {function():Promise<!Response>} xhr\n   */\n  constructor(form, xhr) {\n    super(form);\n\n    /** @protected @const*/\n    this.doXhr_ = xhr;\n\n    /** @protected {?LastAddedResolver} */\n    this.xhrResolver_ = null;\n\n    /** @private {!Array<!VerificationErrorDef>} */\n    this.previousErrors_ = [];\n  }\n\n  /** @override */\n  verify_() {\n    const xhrConsumeErrors = this.doXhr_().then(\n      () => {\n        return [];\n      },\n      (error) => {\n        return getResponseErrorData_(/** @type {!Error} */ (error));\n      }\n    );\n\n    return this.addToResolver_(xhrConsumeErrors).then((errors) =>\n      this.applyErrors_(errors)\n    );\n  }\n\n  /**\n   * Prevent race conditions from XHRs that arrive out of order by resolving\n   * only the most recently initiated XHR.\n   * TODO(cvializ): Replace this when the Fetch API adds cancelable fetches.\n   * @param {!Promise} promise\n   * @return {!Promise} The resolver result promise\n   */\n  addToResolver_(promise) {\n    if (!this.xhrResolver_) {\n      this.xhrResolver_ = new LastAddedResolver();\n      const cleanup = () => (this.xhrResolver_ = null);\n      this.xhrResolver_.then(cleanup, cleanup);\n    }\n    return this.xhrResolver_.add(promise);\n  }\n\n  /**\n   * Set errors on elements that failed verification, and clear any\n   * verification state for elements that passed verification.\n   * @param {!Array<!VerificationErrorDef>} errors\n   * @return {!UpdatedErrorsDef} Updated elements e.g. elements with new errors,\n   *    and elements that previously had errors but were fixed. The form will\n   *    update their user-valid/user-invalid state.\n   * @private\n   */\n  applyErrors_(errors) {\n    const errorElements = [];\n\n    const previousErrors = this.previousErrors_;\n    this.previousErrors_ = errors;\n\n    // Set the error message on each element that caused an error.\n    for (let i = 0; i < errors.length; i++) {\n      const error = errors[i];\n      const name = user().assertString(\n        error.name,\n        'Verification errors must have a name property'\n      );\n      const message = user().assertString(\n        error.message,\n        'Verification errors must have a message property'\n      );\n      // If multiple elements share the same name, the first should be selected.\n      // This matches the behavior of HTML5 validation, e.g. with radio buttons.\n      const element = user().assertElement(\n        this.form_./*OK*/ querySelector(`[name=\"${name}\"]`),\n        'Verification error name property must match a field name'\n      );\n\n      // Only put verification errors on elements that are client-side valid.\n      // This prevents errors from appearing on elements that have not been\n      // filled out yet.\n      if (element.checkValidity()) {\n        element.setCustomValidity(message);\n        errorElements.push(element);\n      }\n    }\n\n    // Create a list of form elements that had an error, but are now fixed.\n    const isFixed = (previousError) =>\n      errors.every((error) => previousError.name !== error.name);\n    const fixedElements = previousErrors\n      .filter(isFixed)\n      .map((e) => this.form_./*OK*/ querySelector(`[name=\"${e.name}\"]`));\n\n    return /** @type {!UpdatedErrorsDef} */ ({\n      updatedElements: errorElements.concat(fixedElements),\n      errors,\n    });\n  }\n}\n\n/**\n * @param {!Error} error\n * @return {!Promise<!Array<VerificationErrorDef>>}\n * @private\n */\nfunction getResponseErrorData_(error) {\n  const {response} = error;\n  if (!response) {\n    return Promise.resolve([]);\n  }\n\n  return response.json().then(\n    (json) => json.verifyErrors || [],\n    () => []\n  );\n}\n", "export const CSS = \"form.amp-form-submit-error [submit-error],form.amp-form-submit-success [submit-success],form.amp-form-submitting [submitting]{display:block}textarea[autoexpand]:not(.i-amphtml-textarea-max){overflow:hidden!important}.i-amphtml-textarea-clone{visibility:hidden;position:absolute;top:-9999px;left:-9999px;height:0!important}.i-amphtml-validation-bubble{transform:translate(-50%,-100%);background-color:#fff;box-shadow:0 5px 15px 0 rgba(0,0,0,.5);max-width:200px;position:absolute;display:block;box-sizing:border-box;padding:10px;border-radius:5px}.i-amphtml-validation-bubble:after{content:\\\" \\\";position:absolute;bottom:-8px;left:30px;width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:8px solid #fff}[visible-when-invalid]{color:red}\\n/*# sourceURL=/extensions/amp-form/0.1/amp-form.css*/\";\n", "import {isArray} from '#core/types';\nimport {dict} from '#core/types/object';\n\nimport {userAssert} from '#utils/log';\n\nimport {toStructuredCloneable} from './utils/xhr-utils';\n\n/**\n * @typedef {{\n *   successTemplate: ?(Element|JsonObject|undefined),\n *   errorTemplate: ?(Element|JsonObject|undefined)\n * }}\n */\nexport let SsrTemplateDef;\n\n/**\n * Helper, that manages the proxying of template rendering to the viewer.\n */\nexport class SsrTemplateHelper {\n  /**\n   * @param {string} sourceComponent\n   * @param {!./service/viewer-interface.ViewerInterface} viewer\n   * @param {!./service/template-impl.Templates} templates\n   */\n  constructor(sourceComponent, viewer, templates) {\n    /** @private @const */\n    this.viewer_ = viewer;\n\n    /** @private @const */\n    this.templates_ = templates;\n\n    /** @private @const */\n    this.sourceComponent_ = sourceComponent;\n  }\n\n  /**\n   * Whether the viewer should render templates. A doc-level opt in as\n   * trusted viewers must set this capability explicitly, as a security\n   * measure for potential abuse of feature.\n   * @return {boolean}\n   */\n  isEnabled() {\n    const ampdoc = this.viewer_.getAmpDoc();\n    if (ampdoc.isSingleDoc()) {\n      const htmlElement = ampdoc.getRootNode().documentElement;\n      if (htmlElement.hasAttribute('allow-viewer-render-template')) {\n        return this.viewer_.hasCapability('viewerRenderTemplate');\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Asserts that the viewer is from a trusted origin.\n   *\n   * @param {!Element} element\n   * @return {!Promise}\n   */\n  assertTrustedViewer(element) {\n    return this.viewer_.isTrustedViewer().then((trusted) => {\n      userAssert(\n        trusted,\n        'Refused to attempt SSR in untrusted viewer: ',\n        element\n      );\n    });\n  }\n\n  /**\n   * Proxies xhr and template rendering to the viewer.\n   * Returns the renderable response, for use with applySsrOrCsrTemplate.\n   * @param {!Element} element\n   * @param {!FetchRequestDef} request The fetch/XHR related data.\n   * @param {?SsrTemplateDef=} opt_templates Response templates to pass into\n   *     the payload. If provided, finding the template in the passed in\n   *     element is not attempted.\n   * @param {!Object=} opt_attributes Additional JSON to send to viewer.\n   * @return {!Promise<?JsonObject|string|undefined>}\n   */\n  ssr(element, request, opt_templates = null, opt_attributes = {}) {\n    let mustacheTemplate;\n    if (!opt_templates) {\n      mustacheTemplate = this.templates_.maybeFindTemplate(element);\n    }\n    return this.assertTrustedViewer(element).then(() => {\n      return this.viewer_.sendMessageAwaitResponse(\n        'viewerRenderTemplate',\n        this.buildPayload_(\n          request,\n          mustacheTemplate,\n          opt_templates,\n          opt_attributes\n        )\n      );\n    });\n  }\n\n  /**\n   * Render provided data for the template in the given element.\n   * If SSR is supported, data is assumed to be from ssr() above.\n   * @param {!Element} element\n   * @param {(?JsonObject|string|undefined|!Array)} data\n   * @return {!Promise<(!Element|!Array<!Element>)>}\n   */\n  applySsrOrCsrTemplate(element, data) {\n    let renderTemplatePromise;\n    if (this.isEnabled()) {\n      userAssert(\n        typeof data['html'] === 'string',\n        'Skipping template rendering due to failed fetch'\n      );\n      renderTemplatePromise = this.assertTrustedViewer(element).then(() => {\n        return this.templates_.findAndSetHtmlForTemplate(\n          element,\n          /** @type {string} */ (data['html'])\n        );\n      });\n    } else if (isArray(data)) {\n      renderTemplatePromise = this.templates_.findAndRenderTemplateArray(\n        element,\n        /** @type {!Array} */ (data)\n      );\n    } else {\n      renderTemplatePromise = this.templates_.findAndRenderTemplate(\n        element,\n        /** @type {!JsonObject} */ (data)\n      );\n    }\n\n    return renderTemplatePromise;\n  }\n\n  /**\n   * @param {!FetchRequestDef} request\n   * @param {?Element|undefined} mustacheTemplate\n   * @param {?SsrTemplateDef=} opt_templates\n   * @param {!Object=} opt_attributes\n   * @return {!JsonObject}\n   * @private\n   */\n  buildPayload_(request, mustacheTemplate, opt_templates, opt_attributes = {}) {\n    const ampComponent = dict({'type': this.sourceComponent_});\n\n    const successTemplateKey = 'successTemplate';\n    const successTemplate =\n      opt_templates && opt_templates[successTemplateKey]\n        ? opt_templates[successTemplateKey]\n        : mustacheTemplate;\n    if (successTemplate) {\n      ampComponent[successTemplateKey] = {\n        'type': 'amp-mustache',\n        'payload': successTemplate./*REVIEW*/ innerHTML,\n      };\n    }\n\n    const errorTemplateKey = 'errorTemplate';\n    const errorTemplate =\n      opt_templates && opt_templates[errorTemplateKey]\n        ? opt_templates[errorTemplateKey]\n        : null;\n    if (errorTemplate) {\n      ampComponent[errorTemplateKey] = {\n        'type': 'amp-mustache',\n        'payload': errorTemplate./*REVIEW*/ innerHTML,\n      };\n    }\n\n    if (opt_attributes) {\n      Object.assign(ampComponent, opt_attributes);\n    }\n\n    const data = dict({\n      'originalRequest': toStructuredCloneable(\n        request.xhrUrl,\n        request.fetchOpt\n      ),\n      'ampComponent': ampComponent,\n    });\n\n    return data;\n  }\n}\n", "import {CommonSignals} from '#core/constants/common-signals';\nimport {TickLabel} from '#core/constants/enums';\nimport {insertAfterOrAtStart, waitForBodyOpenPromise} from '#core/dom';\nimport {setStyles} from '#core/dom/style';\nimport {rethrowAsync} from '#core/error';\nimport {map} from '#core/types/object';\n\nimport {Services} from '#service';\n\nimport {dev, devAssert} from '#utils/log';\n\nimport {waitForServices} from './render-delaying-services';\nimport {getAmpdoc} from './service-helpers';\n\nconst TRANSFORMER_PROP = '__AMP_CSS_TR';\nconst STYLE_MAP_PROP = '__AMP_CSS_SM';\n\n/**\n * Adds the given css text to the given ampdoc.\n *\n * The style tags will be at the beginning of the head before all author\n * styles. One element can be the main runtime CSS. This is guaranteed\n * to always be the first stylesheet in the doc.\n *\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc The ampdoc that should get the new styles.\n * @param {string} cssText\n * @param {?function(!Element)|undefined} cb Called when the new styles are available.\n *     Not using a promise, because this is synchronous when possible.\n *     for better performance.\n * @param {boolean=} opt_isRuntimeCss If true, this style tag will be inserted\n *     as the first element in head and all style elements will be positioned\n *     after.\n * @param {string=} opt_ext\n * @return {!Element}\n */\nexport function installStylesForDoc(\n  ampdoc,\n  cssText,\n  cb,\n  opt_isRuntimeCss,\n  opt_ext\n) {\n  const cssRoot = ampdoc.getHeadNode();\n  const style = insertStyleElement(\n    cssRoot,\n    maybeTransform(cssRoot, cssText),\n    opt_isRuntimeCss || false,\n    opt_ext || null\n  );\n\n  if (cb) {\n    const rootNode = ampdoc.getRootNode();\n    // Styles aren't always available synchronously. E.g. if there is a\n    // pending style download, it will have to finish before the new\n    // style is visible.\n    // For this reason we poll until the style becomes available.\n    // Sync case.\n    if (styleLoaded(rootNode, style)) {\n      cb(style);\n      return style;\n    }\n    // Poll until styles are available.\n    const interval = setInterval(() => {\n      if (styleLoaded(rootNode, style)) {\n        clearInterval(interval);\n        cb(style);\n      }\n    }, 4);\n  }\n  return style;\n}\n\n/**\n * Creates the properly configured style element.\n * @param {!Element|!ShadowRoot} cssRoot\n * @param {string} cssText\n * @param {boolean} isRuntimeCss\n * @param {?string} ext\n * @return {!Element}\n */\nfunction insertStyleElement(cssRoot, cssText, isRuntimeCss, ext) {\n  let styleMap = cssRoot[STYLE_MAP_PROP];\n  if (!styleMap) {\n    styleMap = cssRoot[STYLE_MAP_PROP] = map();\n  }\n\n  const isExtCss =\n    !isRuntimeCss && ext && ext != 'amp-custom' && ext != 'amp-keyframes';\n  const key = isRuntimeCss\n    ? 'amp-runtime'\n    : isExtCss\n    ? `amp-extension=${ext}`\n    : null;\n\n  // Check if it has already been created or discovered.\n  if (key) {\n    const existing = getExistingStyleElement(cssRoot, styleMap, key);\n    if (existing) {\n      if (existing.textContent !== cssText) {\n        existing.textContent = cssText;\n      }\n      return existing;\n    }\n  }\n\n  // Create the new style element and append to cssRoot.\n  const doc = cssRoot.ownerDocument || cssRoot;\n  const style = doc.createElement('style');\n  style./*OK*/ textContent = cssText;\n  let afterElement = null;\n  // Make sure that we place style tags after the main runtime CSS. Otherwise\n  // the order is random.\n  if (isRuntimeCss) {\n    style.setAttribute('amp-runtime', '');\n  } else if (isExtCss) {\n    style.setAttribute('amp-extension', ext || '');\n    afterElement = dev().assertElement(\n      getExistingStyleElement(cssRoot, styleMap, 'amp-runtime')\n    );\n  } else {\n    if (ext) {\n      style.setAttribute(ext, '');\n    }\n    afterElement = cssRoot.lastChild;\n  }\n  insertAfterOrAtStart(cssRoot, style, afterElement);\n  if (key) {\n    styleMap[key] = style;\n  }\n  return style;\n}\n\n/**\n * @param {!Element|!ShadowRoot} cssRoot\n * @param {!Object<string, !Element>} styleMap\n * @param {string} key\n * @return {?Element}\n */\nfunction getExistingStyleElement(cssRoot, styleMap, key) {\n  // Already cached.\n  if (styleMap[key]) {\n    return styleMap[key];\n  }\n  // Check if the style has already been added by the server layout.\n  const existing = cssRoot./*OK*/ querySelector(`style[${key}]`);\n  if (existing) {\n    styleMap[key] = existing;\n    return existing;\n  }\n  // Nothing found.\n  return null;\n}\n\n/**\n * Applies a transformer to the CSS text if it has been registered.\n * @param {!Element|!ShadowRoot} cssRoot\n * @param {function(string):string} transformer\n */\nexport function installCssTransformer(cssRoot, transformer) {\n  cssRoot[TRANSFORMER_PROP] = transformer;\n}\n\n/**\n * Applies a transformer to the CSS text if it has been registered.\n * @param {!Element|!ShadowRoot} cssRoot\n * @param {string} cssText\n * @return {string}\n */\nfunction maybeTransform(cssRoot, cssText) {\n  const transformer = cssRoot[TRANSFORMER_PROP];\n  return transformer ? transformer(cssText) : cssText;\n}\n\n/** @private {boolean} */\nlet bodyMadeVisible = false;\n\n/**\n * @param {boolean} value\n * @visibleForTesting\n */\nexport function setBodyMadeVisibleForTesting(value) {\n  bodyMadeVisible = value;\n}\n\n/**\n * Sets the document's body opacity to 1.\n * If the body is not yet available (because our script was loaded\n * synchronously), polls until it is.\n * @param {!Document} doc The document who's body we should make visible.\n */\nexport function makeBodyVisible(doc) {\n  devAssert(doc.defaultView, 'Passed in document must have a defaultView');\n  const win = /** @type {!Window} */ (doc.defaultView);\n  waitForBodyOpenPromise(doc)\n    .then(() => {\n      return waitForServices(win);\n    })\n    .catch((reason) => {\n      rethrowAsync(reason);\n      return [];\n    })\n    .then((services) => {\n      bodyMadeVisible = true;\n      if (INI_LOAD_INOB) {\n        // Force sync measurement to ensure that style recalc is complete\n        // before showing body, which would trigger FCP. This should reduce\n        // make it less likely that a CLS would be triggered after FCP.\n        doc.body./*OK*/ getBoundingClientRect();\n      }\n      setBodyVisibleStyles(doc);\n      const ampdoc = getAmpdoc(doc);\n      ampdoc.signals().signal(CommonSignals.RENDER_START);\n      if (services.length > 0) {\n        const resources = Services.resourcesForDoc(doc.documentElement);\n        resources./*OK*/ schedulePass(1, /* relayoutAll */ true);\n      }\n      try {\n        const perf = Services.performanceFor(win);\n        perf.tick(TickLabel.MAKE_BODY_VISIBLE);\n        perf.flush();\n      } catch (e) {}\n    });\n}\n\n/**\n * Set the document's body opacity to 1. Called in error cases.\n * @param {!Document} doc The document who's body we should make visible.\n */\nexport function makeBodyVisibleRecovery(doc) {\n  devAssert(doc.defaultView, 'Passed in document must have a defaultView');\n  if (bodyMadeVisible) {\n    return;\n  }\n  bodyMadeVisible = true;\n  setBodyVisibleStyles(doc);\n}\n\n/**\n * Make sure that body exists, and make it visible.\n * @param {!Document} doc\n */\nfunction setBodyVisibleStyles(doc) {\n  setStyles(dev().assertElement(doc.body), {\n    opacity: 1,\n    visibility: 'visible',\n    'animation': 'none',\n  });\n}\n\n/**\n * Indicates that the body is always visible. For instance, in case of PWA.\n * This check is on a module level variable, and could be problematic if you are\n * relying on this function across different binaries.\n * @param {!Window} unusedWin\n */\nexport function bodyAlwaysVisible(unusedWin) {\n  bodyMadeVisible = true;\n}\n\n/**\n * Checks whether a style element was registered in the DOM.\n * @param {!Document|!ShadowRoot} doc\n * @param {!Element} style\n * @return {boolean}\n */\nfunction styleLoaded(doc, style) {\n  const sheets = doc.styleSheets;\n  for (let i = 0; i < sheets.length; i++) {\n    const sheet = sheets[i];\n    if (sheet.ownerNode == style) {\n      return true;\n    }\n  }\n  return false;\n}\n", "import {ActionTrust} from '#core/constants/action-constants';\nimport {AmpEvents} from '#core/constants/amp-events';\nimport {\n  AsyncInputAttributes,\n  AsyncInputClasses,\n} from '#core/constants/async-input';\nimport {Keys} from '#core/constants/key-codes';\nimport {Deferred, tryResolve} from '#core/data-structures/promise';\nimport {isAmp4Email} from '#core/document/format';\nimport {\n  createElementWithAttributes,\n  iterateCursor,\n  removeElement,\n  tryFocus,\n} from '#core/dom';\nimport {escapeCssSelectorIdent} from '#core/dom/css-selectors';\nimport {\n  formOrNullForElement,\n  getFormAsObject,\n  setFormForElement,\n} from '#core/dom/form';\nimport {ancestorElementsByTag, childElementByAttr} from '#core/dom/query';\nimport {isArray, toArray} from '#core/types/array';\nimport {deepMerge, dict} from '#core/types/object';\nimport {tryParseJson} from '#core/types/object/json';\nimport {parseQueryString} from '#core/types/string/url';\nimport {toWin} from '#core/window';\n\nimport {Services} from '#service';\n\nimport {triggerAnalyticsEvent} from '#utils/analytics';\nimport {createCustomEvent} from '#utils/event-helper';\nimport {dev, devAssert, user, userAssert} from '#utils/log';\nimport {setupAMPCors, setupInit, setupInput} from '#utils/xhr-utils';\n\nimport {AmpFormTextarea} from './amp-form-textarea';\nimport {FormDirtiness} from './form-dirtiness';\nimport {FormEvents} from './form-events';\nimport {installFormProxy} from './form-proxy';\nimport {FormSubmitService} from './form-submit-service';\nimport {getFormValidator, isCheckValiditySupported} from './form-validators';\nimport {\n  FORM_VERIFY_OPTOUT,\n  FORM_VERIFY_PARAM,\n  getFormVerifier,\n} from './form-verifiers';\n\nimport {CSS} from '../../../build/amp-form-0.1.css';\nimport {createFormDataWrapper} from '../../../src/form-data-wrapper';\nimport {getMode} from '../../../src/mode';\nimport {SsrTemplateHelper} from '../../../src/ssr-template-helper';\nimport {installStylesForDoc} from '../../../src/style-installer';\nimport {\n  SOURCE_ORIGIN_PARAM,\n  addParamsToUrl,\n  isProxyOrigin,\n  serializeQueryString,\n} from '../../../src/url';\n\n/** @const {string} */\nconst TAG = 'amp-form';\n\n/**\n * A list of external dependencies that can be included in forms.\n * @const {!Array<string>}\n */\nconst EXTERNAL_DEPS = ['amp-selector'];\n\n/** @const @enum {string} */\nconst FormState = {\n  INITIAL: 'initial',\n  VERIFYING: 'verifying',\n  VERIFY_ERROR: 'verify-error',\n  SUBMITTING: 'submitting',\n  SUBMIT_ERROR: 'submit-error',\n  SUBMIT_SUCCESS: 'submit-success',\n};\n\n/** @const @enum {string} */\nconst UserValidityState = {\n  NONE: 'none',\n  USER_VALID: 'valid',\n  USER_INVALID: 'invalid',\n};\n\n/** @private @const {string} */\nconst REDIRECT_TO_HEADER = 'AMP-Redirect-To';\n\n/**\n * Time to wait for services / async input before throwing an error.\n * @private @const {number}\n */\nconst SUBMIT_TIMEOUT = 10000;\n\nexport class AmpForm {\n  /**\n   * Adds functionality to the passed form element and listens to submit event.\n   * @param {!HTMLFormElement} element\n   * @param {string} id\n   */\n  constructor(element, id) {\n    //TODO(dvoytenko, #7063): Remove the try catch.\n    try {\n      installFormProxy(element);\n    } catch (e) {\n      dev().error(TAG, 'form proxy failed to install', e);\n    }\n\n    setFormForElement(element, this);\n\n    /** @private @const {string} */\n    this.id_ = id;\n\n    /** @private @const {?Document} */\n    this.doc_ = element.ownerDocument;\n\n    /** @const @private {!Window} */\n    this.win_ = toWin(this.doc_.defaultView);\n\n    /** @const @private {!../../../src/service/timer-impl.Timer} */\n    this.timer_ = Services.timerFor(this.win_);\n\n    /** @const @private {!HTMLFormElement} */\n    this.form_ = element;\n\n    /** @const @private {!../../../src/service/ampdoc-impl.AmpDoc}  */\n    this.ampdoc_ = Services.ampdoc(this.form_);\n\n    /** @private {?Promise} */\n    this.dependenciesPromise_ = null;\n\n    /** @const @private {!../../../src/service/url-replacements-impl.UrlReplacements} */\n    this.urlReplacement_ = Services.urlReplacementsForDoc(this.ampdoc_);\n\n    /** @const @private {!../../../src/service/template-impl.Templates} */\n    this.templates_ = Services.templatesForDoc(this.ampdoc_);\n\n    /** @const @private {!../../../src/service/xhr-impl.Xhr} */\n    this.xhr_ = Services.xhrFor(this.win_);\n\n    /** @const @private {!../../../src/service/action-impl.ActionService} */\n    this.actions_ = Services.actionServiceForDoc(this.ampdoc_);\n\n    /** @const @private {!../../../src/service/mutator-interface.MutatorInterface} */\n    this.mutator_ = Services.mutatorForDoc(this.ampdoc_);\n\n    /** @const @private {!../../../src/service/viewer-interface.ViewerInterface}  */\n    this.viewer_ = Services.viewerForDoc(this.ampdoc_);\n\n    /**\n     * @const {!../../../src/ssr-template-helper.SsrTemplateHelper}\n     * @private\n     */\n    this.ssrTemplateHelper_ = new SsrTemplateHelper(\n      TAG,\n      this.viewer_,\n      this.templates_\n    );\n\n    /** @const @private {string} */\n    this.method_ = (this.form_.getAttribute('method') || 'GET').toUpperCase();\n\n    /** @const @private {string} */\n    this.target_ = this.form_.getAttribute('target');\n\n    /** @private {?string} */\n    this.xhrAction_ = this.getXhrUrl_('action-xhr');\n\n    /** @const @private {?string} */\n    this.xhrVerify_ = this.getXhrUrl_('verify-xhr');\n\n    /** @const @private {?string} */\n    this.encType_ = this.getEncType_('enctype');\n\n    /** @const @private {boolean} */\n    this.shouldValidate_ = !this.form_.hasAttribute('novalidate');\n    // Need to disable browser validation in order to allow us to take full\n    // control of this. This allows us to trigger validation APIs and reporting\n    // when we need to.\n    this.form_.setAttribute('novalidate', '');\n    if (!this.shouldValidate_) {\n      this.form_.setAttribute('amp-novalidate', '');\n    }\n    this.form_.classList.add('i-amphtml-form');\n\n    /** @private {!FormState} */\n    this.state_ = FormState.INITIAL;\n\n    const inputs = this.form_.elements;\n    for (let i = 0; i < inputs.length; i++) {\n      const {name} = inputs[i];\n      userAssert(\n        name != SOURCE_ORIGIN_PARAM && name != FORM_VERIFY_PARAM,\n        'Illegal input name, %s found: %s',\n        name,\n        inputs[i]\n      );\n    }\n\n    /** @const @private {!./form-dirtiness.FormDirtiness} */\n    this.dirtinessHandler_ = new FormDirtiness(this.form_, this.win_);\n\n    /** @const @private {!./form-validators.FormValidator} */\n    this.validator_ = getFormValidator(this.form_);\n\n    /** @const @private {!./form-verifiers.FormVerifier} */\n    this.verifier_ = getFormVerifier(this.form_, () => this.handleXhrVerify_());\n\n    /** If the element is in an email document, allow its `clear` and `submit` actions. */\n    this.actions_.addToAllowlist('FORM', ['clear', 'submit'], ['email']);\n    this.actions_.installActionHandler(\n      this.form_,\n      this.actionHandler_.bind(this)\n    );\n    this.installEventHandlers_();\n    this.installInputMasking_();\n    this.maybeInitializeFromUrl_();\n\n    /** @private {?Promise} */\n    this.xhrSubmitPromise_ = null;\n\n    /** @private {?Promise} */\n    this.renderTemplatePromise_ = null;\n\n    /** @private {?./form-submit-service.FormSubmitService} */\n    this.formSubmitService_ = null;\n    Services.formSubmitForDoc(element).then((service) => {\n      this.formSubmitService_ = service;\n    });\n\n    /** @private */\n    this.isAmp4Email_ = this.doc_ && isAmp4Email(this.doc_);\n  }\n\n  /**\n   * Gets and validates an attribute for form request URLs.\n   * @param {string} attribute\n   * @return {?string}\n   * @private\n   */\n  getXhrUrl_(attribute) {\n    const url = this.form_.getAttribute(attribute);\n    if (url) {\n      const urlService = Services.urlForDoc(this.ampdoc_);\n      urlService.assertHttpsUrl(url, this.form_, attribute);\n      userAssert(\n        !urlService.isProxyOrigin(url),\n        'form %s should not be on AMP CDN: %s',\n        attribute,\n        this.form_\n      );\n    }\n    return url;\n  }\n\n  /**\n   * Gets and validates an attribute for form request encoding type.\n   * @param {string} attribute\n   * @return {?string}\n   * @private\n   */\n  getEncType_(attribute) {\n    const encType = this.form_.getAttribute(attribute);\n    if (\n      encType === 'application/x-www-form-urlencoded' ||\n      encType === 'multipart/form-data'\n    ) {\n      return encType;\n    } else if (encType !== null) {\n      user().warn(\n        TAG,\n        `Unexpected enctype: ${encType}. Defaulting to 'multipart/form-data'.`\n      );\n    }\n    return 'multipart/form-data';\n  }\n\n  /**\n   * @return {string|undefined} the value of the form's xssi-prefix attribute.\n   */\n  getXssiPrefix() {\n    return this.form_.getAttribute('xssi-prefix');\n  }\n\n  /**\n   * Builds fetch request data for amp-form elements.\n   * @param {string} url\n   * @param {string} method\n   * @param {!Object<string, string>=} opt_extraFields\n   * @param {!Array<string>=} opt_fieldDenylist\n   * @return {!FetchRequestDef}\n   */\n  requestForFormFetch(url, method, opt_extraFields, opt_fieldDenylist) {\n    let xhrUrl, body;\n    let headers = dict({'Accept': 'application/json'});\n    const isHeadOrGet = method == 'GET' || method == 'HEAD';\n    if (isHeadOrGet) {\n      this.assertNoSensitiveFields_();\n      const values = this.getFormAsObject_();\n      if (opt_fieldDenylist) {\n        opt_fieldDenylist.forEach((name) => delete values[name]);\n      }\n\n      if (opt_extraFields) {\n        deepMerge(values, opt_extraFields);\n      }\n      xhrUrl = addParamsToUrl(url, values);\n    } else {\n      xhrUrl = url;\n      if (this.encType_ === 'application/x-www-form-urlencoded') {\n        body = serializeQueryString(this.getFormAsObject_());\n        headers = dict({\n          'Accept': 'application/json',\n          'Content-Type': 'application/x-www-form-urlencoded',\n        });\n      } else {\n        // default case: encType_ is 'multipart/form-data'\n        devAssert(this.encType_ === 'multipart/form-data');\n        body = createFormDataWrapper(this.win_, this.form_);\n      }\n      if (opt_fieldDenylist) {\n        opt_fieldDenylist.forEach((name) => body.delete(name));\n      }\n\n      for (const key in opt_extraFields) {\n        body.append(key, opt_extraFields[key]);\n      }\n    }\n\n    /** @type {!FetchRequestDef}*/\n    const request = {\n      xhrUrl,\n      fetchOpt: dict({\n        'body': body,\n        'method': method,\n        'credentials': 'include',\n        'headers': headers,\n      }),\n    };\n    return request;\n  }\n\n  /**\n   * Setter to change cached action-xhr.\n   * @param {string} url\n   */\n  setXhrAction(url) {\n    this.xhrAction_ = url;\n  }\n\n  /**\n   * Handle actions that require at least high trust.\n   * @param {!../../../src/service/action-impl.ActionInvocation} invocation\n   * @return {?Promise}\n   * @private\n   */\n  actionHandler_(invocation) {\n    if (!invocation.satisfiesTrust(ActionTrust.DEFAULT)) {\n      return null;\n    }\n    if (invocation.method == 'submit') {\n      return this.whenDependenciesReady_().then(() => {\n        return this.handleSubmitAction_(invocation);\n      });\n    } else if (invocation.method === 'clear') {\n      this.handleClearAction_();\n    }\n    return null;\n  }\n\n  /**\n   * Returns a promise that will be resolved when all dependencies used inside\n   * the form tag are loaded and built (e.g. amp-selector) or 2 seconds timeout\n   * - whichever is first.\n   * @return {!Promise}\n   * @private\n   */\n  whenDependenciesReady_() {\n    if (this.dependenciesPromise_) {\n      return this.dependenciesPromise_;\n    }\n    const depElements = this.form_./*OK*/ querySelectorAll(\n      EXTERNAL_DEPS.join(',')\n    );\n    // Wait for an element to be built to make sure it is ready.\n    const promises = toArray(depElements).map((el) => el.build());\n    return (this.dependenciesPromise_ = this.waitOnPromisesOrTimeout_(\n      promises,\n      2000\n    ));\n  }\n\n  /** @private */\n  installEventHandlers_() {\n    this.ampdoc_.whenNextVisible().then(() => {\n      const autofocus = this.form_.querySelector('[autofocus]');\n      if (autofocus) {\n        tryFocus(autofocus);\n      }\n    });\n\n    this.form_.addEventListener(\n      'submit',\n      this.handleSubmitEvent_.bind(this),\n      true\n    );\n\n    this.form_.addEventListener(\n      'blur',\n      (e) => {\n        checkUserValidityAfterInteraction_(dev().assertElement(e.target));\n        this.validator_.onBlur(e);\n      },\n      true\n    );\n\n    this.form_.addEventListener(\n      AmpEvents.FORM_VALUE_CHANGE,\n      (e) => {\n        checkUserValidityAfterInteraction_(dev().assertElement(e.target));\n        this.validator_.onInput(e);\n      },\n      true\n    );\n\n    //  Form verification is not supported when SSRing templates is enabled.\n    if (!this.ssrTemplateHelper_.isEnabled()) {\n      this.form_.addEventListener('change', (e) => {\n        this.verifier_.onCommit().then((updatedErrors) => {\n          const {errors, updatedElements} = updatedErrors;\n          updatedElements.forEach(checkUserValidityAfterInteraction_);\n          // Tell the validation to reveal any input.validationMessage added\n          // by the form verifier.\n          this.validator_.onBlur(e);\n\n          // Only make the verify XHR if the user hasn't pressed submit.\n          if (this.state_ === FormState.VERIFYING) {\n            if (errors.length) {\n              this.setState_(FormState.VERIFY_ERROR);\n              this.renderTemplate_(dict({'verifyErrors': errors})).then(() => {\n                this.triggerAction_(\n                  FormEvents.VERIFY_ERROR,\n                  errors,\n                  ActionTrust.DEFAULT // DEFAULT because async after gesture.\n                );\n              });\n            } else {\n              this.setState_(FormState.INITIAL);\n            }\n          }\n        });\n      });\n    }\n\n    this.form_.addEventListener('input', (e) => {\n      checkUserValidityAfterInteraction_(dev().assertElement(e.target));\n      this.validator_.onInput(e);\n    });\n  }\n\n  /** @private */\n  installInputMasking_() {\n    Services.inputmaskServiceForDocOrNull(this.ampdoc_).then(\n      (inputmaskService) => {\n        if (inputmaskService) {\n          inputmaskService.install();\n        }\n      }\n    );\n  }\n\n  /**\n   * Triggers 'amp-form-submit' event in 'amp-analytics' and\n   * generates variables for form fields to be accessible in analytics\n   *\n   * @param {string} eventType\n   * @private\n   */\n  triggerFormSubmitInAnalytics_(eventType) {\n    this.assertSsrTemplate_(false, 'Form analytics not supported');\n    const formDataForAnalytics = dict({});\n    const formObject = this.getFormAsObject_();\n\n    for (const k in formObject) {\n      if (Object.prototype.hasOwnProperty.call(formObject, k)) {\n        formDataForAnalytics['formFields[' + k + ']'] = formObject[k].join(',');\n      }\n    }\n    formDataForAnalytics['formId'] = this.form_.id;\n\n    try {\n      this.analyticsEvent_(eventType, formDataForAnalytics);\n    } catch (err) {\n      dev().error(TAG, 'Sending analytics failed:', err);\n    }\n  }\n\n  /**\n   * Handles submissions through action service invocations.\n   *   e.g. <img on=tap:form.submit>\n   * @param {!../../../src/service/action-impl.ActionInvocation} invocation\n   * @return {!Promise}\n   * @private\n   */\n  handleSubmitAction_(invocation) {\n    if (this.state_ == FormState.SUBMITTING || !this.checkValidity_()) {\n      return Promise.resolve(null);\n    }\n    // \"submit\" has the same trust level as the action that caused it.\n    return this.submit_(invocation.trust, null);\n  }\n\n  /**\n   * Handles clearing the form through action service invocations.\n   * @private\n   */\n  handleClearAction_() {\n    this.form_.reset();\n    this.setState_(FormState.INITIAL);\n    this.form_.classList.remove('user-valid');\n    this.form_.classList.remove('user-invalid');\n\n    const validityElements = this.form_.querySelectorAll(\n      '.user-valid, .user-invalid'\n    );\n    iterateCursor(validityElements, (element) => {\n      element.classList.remove('user-valid');\n      element.classList.remove('user-invalid');\n    });\n\n    const messageElements = this.form_.querySelectorAll(\n      '.visible[validation-for]'\n    );\n    iterateCursor(messageElements, (element) => {\n      element.classList.remove('visible');\n    });\n\n    removeValidityStateClasses(this.form_);\n  }\n\n  /**\n   * Note on stopImmediatePropagation usage here, it is important to emulate\n   * native browser submit event blocking. Otherwise any other submit listeners\n   * would get the event.\n   *\n   * For example, action service shouldn't trigger 'submit' event if form is\n   * actually invalid. stopImmediatePropagation allows us to make sure we don't\n   * trigger it.\n   *\n   * This prevents the default submission event in any of following cases:\n   *   - The form is still finishing a previous submission.\n   *   - The form is invalid.\n   *   - Handling an XHR submission.\n   *   - It's a non-XHR POST submission (unsupported).\n   *\n   * @param {!Event} event\n   * @return {!Promise}\n   * @private\n   */\n  handleSubmitEvent_(event) {\n    if (this.state_ == FormState.SUBMITTING || !this.checkValidity_()) {\n      event.stopImmediatePropagation();\n      event.preventDefault();\n      return Promise.resolve(null);\n    }\n\n    if (this.xhrAction_ || this.method_ == 'POST') {\n      event.preventDefault();\n    }\n\n    // Submits caused by user input have high trust.\n    return this.submit_(ActionTrust.HIGH, event);\n  }\n\n  /**\n   * Helper method that actual handles the different cases (post, get, xhr...).\n   * @param {ActionTrust} trust\n   * @param {?Event} event\n   * @return {!Promise}\n   * @private\n   */\n  submit_(trust, event) {\n    try {\n      const event = {\n        form: this.form_,\n        actionXhrMutator: this.setXhrAction.bind(this),\n      };\n      devAssert(this.formSubmitService_).fire(event);\n    } catch (e) {\n      dev().error(TAG, 'Form submit service failed: %s', e);\n    }\n\n    // Get our special fields\n    const varSubsFields = this.getVarSubsFields_();\n    const asyncInputs = this.form_.getElementsByClassName(\n      AsyncInputClasses.ASYNC_INPUT\n    );\n\n    this.dirtinessHandler_.onSubmitting();\n\n    // Do any assertions we may need to do\n    // For NonXhrGET\n    // That way we can determine if\n    // we can submit synchronously\n    if (!this.xhrAction_ && this.method_ == 'GET') {\n      this.assertSsrTemplate_(false, 'Non-XHR GETs not supported.');\n      this.assertNoSensitiveFields_();\n\n      // If we have no async inputs, we can just submit synchronously\n      if (asyncInputs.length === 0) {\n        for (let i = 0; i < varSubsFields.length; i++) {\n          this.urlReplacement_.expandInputValueSync(varSubsFields[i]);\n        }\n\n        /**\n         * If the submit was called with an event, then we shouldn't\n         * manually submit the form\n         */\n        const shouldSubmitFormElement = !event;\n\n        this.handleNonXhrGet_(shouldSubmitFormElement);\n        this.dirtinessHandler_.onSubmitSuccess();\n        return Promise.resolve();\n      }\n\n      if (event) {\n        event.preventDefault();\n      }\n    }\n\n    // Set ourselves to the SUBMITTING State\n    this.setState_(FormState.SUBMITTING);\n\n    // Promises to run before submit without timeout.\n    const requiredActionPromises = [];\n    // Promises to run before submitting the form\n    const presubmitPromises = [];\n    presubmitPromises.push(this.doVarSubs_(varSubsFields));\n    iterateCursor(asyncInputs, (asyncInput) => {\n      const asyncCall = this.getValueForAsyncInput_(asyncInput);\n      if (\n        asyncInput.classList.contains(AsyncInputClasses.ASYNC_REQUIRED_ACTION)\n      ) {\n        requiredActionPromises.push(asyncCall);\n      } else {\n        presubmitPromises.push(asyncCall);\n      }\n    });\n\n    return Promise.all(requiredActionPromises).then(\n      () => {\n        return this.waitOnPromisesOrTimeout_(\n          presubmitPromises,\n          SUBMIT_TIMEOUT\n        ).then(\n          () => this.handlePresubmitSuccess_(trust),\n          (error) => this.handlePresubmitError_(error, trust)\n        );\n      },\n      (error) => this.handlePresubmitError_(error, trust)\n    );\n  }\n\n  /**\n   * Handle form error for presubmit async calls.\n   * @param {*} error\n   * @param {!ActionTrust} trust\n   * @return {Promise}\n   * @private\n   */\n  handlePresubmitError_(error, trust) {\n    const detail = dict();\n    if (error && error.message) {\n      detail['error'] = error.message;\n    }\n    return this.handleSubmitFailure_(error, detail, trust);\n  }\n\n  /**\n   * Get form fields that require variable substitutions\n   * @return {!IArrayLike<!HTMLInputElement>}\n   * @private\n   */\n  getVarSubsFields_() {\n    // Fields that support var substitutions.\n    return this.form_.querySelectorAll('[type=\"hidden\"][data-amp-replace]');\n  }\n\n  /**\n   * Handle successful presubmit tasks\n   * @param {!ActionTrust} trust\n   * @return {!Promise}\n   */\n  handlePresubmitSuccess_(trust) {\n    if (this.xhrAction_) {\n      return this.handleXhrSubmit_(trust);\n    } else if (this.method_ == 'POST') {\n      this.handleNonXhrPost_();\n    } else if (this.method_ == 'GET') {\n      this.handleNonXhrGet_(/* shouldSubmitFormElement */ true);\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Send the verify request and control the VERIFYING state.\n   * @return {!Promise}\n   * @private\n   */\n  handleXhrVerify_() {\n    if (this.state_ === FormState.SUBMITTING) {\n      return Promise.resolve();\n    }\n    this.setState_(FormState.VERIFYING);\n    this.triggerAction_(FormEvents.VERIFY, /* detail */ null, ActionTrust.HIGH);\n\n    return this.doVarSubs_(this.getVarSubsFields_()).then(() =>\n      this.doVerifyXhr_()\n    );\n  }\n\n  /**\n   * @param {ActionTrust} trust\n   * @return {!Promise}\n   * @private\n   */\n  handleXhrSubmit_(trust) {\n    let p;\n    if (this.ssrTemplateHelper_.isEnabled()) {\n      p = this.handleSsrTemplate_(trust);\n    } else {\n      this.submittingWithTrust_(trust);\n      p = this.doActionXhr_().then(\n        (response) => this.handleXhrSubmitSuccess_(response, trust),\n        (error) => this.handleXhrSubmitFailure_(error, trust)\n      );\n    }\n    if (getMode().test) {\n      this.xhrSubmitPromise_ = p;\n    }\n    return p;\n  }\n\n  /**\n   * Handles the server side proxying and then rendering of the template.\n   * @param {ActionTrust} trust\n   * @return {!Promise}\n   * @private\n   */\n  handleSsrTemplate_(trust) {\n    // Render template for the form submitting state.\n    const values = this.getFormAsObject_();\n    return this.renderTemplate_(values)\n      .then(() => {\n        return this.actions_.trigger(\n          this.form_,\n          FormEvents.SUBMIT,\n          /* event */ null,\n          trust\n        );\n      })\n      .then(() => {\n        const request = this.requestForFormFetch(\n          dev().assertString(this.xhrAction_),\n          this.method_\n        );\n        request.fetchOpt = setupInit(request.fetchOpt);\n        request.fetchOpt = setupAMPCors(\n          this.win_,\n          request.xhrUrl,\n          request.fetchOpt\n        );\n        request.xhrUrl = setupInput(\n          this.win_,\n          request.xhrUrl,\n          request.fetchOpt\n        );\n        return this.ssrTemplateHelper_.ssr(\n          this.form_,\n          request,\n          this.templatesForSsr_()\n        );\n      })\n      .then(\n        (response) => this.handleSsrTemplateResponse_(response, trust),\n        (error) => {\n          const detail = dict();\n          if (error && error.message) {\n            detail['error'] = error.message;\n          }\n          return this.handleSubmitFailure_(error, detail, trust);\n        }\n      );\n  }\n\n  /**\n   * If present, finds and returns the success and error response templates.\n   * Note that we do not render the submitting state template and only\n   * deal with submit-success or submit-error.\n   * @return {!../../../src/ssr-template-helper.SsrTemplateDef}\n   * @private\n   */\n  templatesForSsr_() {\n    let successTemplate;\n    const successContainer = this.form_.querySelector('[submit-success]');\n    if (successContainer) {\n      successTemplate = this.templates_.maybeFindTemplate(successContainer);\n    }\n\n    let errorTemplate;\n    const errorContainer = this.form_.querySelector('[submit-error]');\n    if (errorContainer) {\n      errorTemplate = this.templates_.maybeFindTemplate(errorContainer);\n    }\n    return {successTemplate, errorTemplate};\n  }\n\n  /**\n   * Transition the form to the submit-success or submit-error state depending on the response status.\n   * @param {!JsonObject} response\n   * @param {!ActionTrust} trust\n   * @return {!Promise}\n   * @private\n   */\n  handleSsrTemplateResponse_(response, trust) {\n    const init = response['init'];\n    // response['body'] is serialized as a string in the response.\n    const body = tryParseJson(response['body'], (error) =>\n      user().error(TAG, 'Failed to parse response JSON: %s', error)\n    );\n    if (init) {\n      const status = init['status'];\n      if (status >= 300) {\n        /** HTTP status codes of 300+ mean redirects and errors. */\n        return this.handleSubmitFailure_(status, response, trust, body);\n      }\n    }\n    return this.handleSubmitSuccess_(response, trust, body);\n  }\n\n  /**\n   * Triggers the analytics and renders any template for submitting state.\n   * @param {ActionTrust} trust\n   */\n  submittingWithTrust_(trust) {\n    this.triggerFormSubmitInAnalytics_('amp-form-submit');\n    // After variable substitution\n    const values = this.getFormAsObject_();\n    // At the form submitting state, we want to display any template\n    // messages with the submitting attribute.\n    this.renderTemplate_(values).then(() => {\n      this.actions_.trigger(\n        this.form_,\n        FormEvents.SUBMIT,\n        /* event */ null,\n        trust\n      );\n    });\n  }\n\n  /**\n   * Perform asynchronous variable substitution on the fields that require it.\n   * @param {!IArrayLike<!HTMLInputElement>} varSubsFields\n   * @return {!Promise}\n   * @private\n   */\n  doVarSubs_(varSubsFields) {\n    const varSubPromises = [];\n    for (let i = 0; i < varSubsFields.length; i++) {\n      varSubPromises.push(\n        this.urlReplacement_.expandInputValueAsync(varSubsFields[i])\n      );\n    }\n    return this.waitOnPromisesOrTimeout_(varSubPromises, 100);\n  }\n\n  /**\n   * Call getValue() on Async Input elements, and\n   * Create hidden inputs containing their returned values\n   * @param {!Element} asyncInput\n   * @return {!Promise}\n   * @private\n   */\n  getValueForAsyncInput_(asyncInput) {\n    return asyncInput\n      .getImpl()\n      .then((implementation) => implementation.getValue())\n      .then((value) => {\n        const name = asyncInput.getAttribute(AsyncInputAttributes.NAME);\n        let input = this.form_.querySelector(\n          `input[name=${escapeCssSelectorIdent(name)}]`\n        );\n        if (!input) {\n          input = createElementWithAttributes(\n            this.win_.document,\n            'input',\n            dict({\n              'name': asyncInput.getAttribute(AsyncInputAttributes.NAME),\n              'hidden': 'true',\n            })\n          );\n        }\n        input.setAttribute('value', value);\n        this.form_.appendChild(input);\n      });\n  }\n\n  /**\n   * Send a request to the form's action endpoint.\n   * @return {!Promise<!Response>}\n   * @private\n   */\n  doActionXhr_() {\n    return this.doXhr_(dev().assertString(this.xhrAction_), this.method_);\n  }\n\n  /**\n   * Send a request to the form's verify endpoint.\n   * @return {!Promise<!Response>}\n   * @private\n   */\n  doVerifyXhr_() {\n    const noVerifyFields = toArray(\n      this.form_.querySelectorAll(\n        `[${escapeCssSelectorIdent(FORM_VERIFY_OPTOUT)}]`\n      )\n    );\n    const denylist = noVerifyFields.map((field) => field.name || field.id);\n\n    return this.doXhr_(\n      dev().assertString(this.xhrVerify_),\n      this.method_,\n      /**opt_extraFields*/ {[FORM_VERIFY_PARAM]: true},\n      /**opt_fieldDenylist*/ denylist\n    );\n  }\n\n  /**\n   * Send a request to a form endpoint.\n   * @param {string} url\n   * @param {string} method\n   * @param {!Object<string, string>=} opt_extraFields\n   * @param {!Array<string>=} opt_fieldDenylist\n   * @return {!Promise<!Response>}\n   * @private\n   */\n  doXhr_(url, method, opt_extraFields, opt_fieldDenylist) {\n    this.assertSsrTemplate_(false, 'XHRs should be proxied.');\n    const request = this.requestForFormFetch(\n      url,\n      method,\n      opt_extraFields,\n      opt_fieldDenylist\n    );\n    return this.xhr_.fetch(request.xhrUrl, request.fetchOpt);\n  }\n\n  /**\n   * Returns the action trust for submit-success and submit-error events.\n   * @param {!ActionTrust} incomingTrust\n   * @return {!ActionTrust}\n   * @private\n   */\n  trustForSubmitResponse_(incomingTrust) {\n    // Degrade trust across form submission.\n    return /** @type {!ActionTrust} */ (incomingTrust - 1);\n  }\n\n  /**\n   * @param {!Response} response\n   * @param {!ActionTrust} incomingTrust Trust of the originating submit action.\n   * @return {!Promise}\n   * @private\n   */\n  handleXhrSubmitSuccess_(response, incomingTrust) {\n    return this.xhr_\n      .xssiJson(response, this.getXssiPrefix())\n      .then(\n        (json) =>\n          this.handleSubmitSuccess_(\n            /** @type {!JsonObject} */ (json),\n            incomingTrust\n          ),\n        (error) => user().error(TAG, 'Failed to parse response JSON: %s', error)\n      )\n      .then(() => {\n        this.triggerFormSubmitInAnalytics_('amp-form-submit-success');\n        this.maybeHandleRedirect_(response);\n      });\n  }\n\n  /**\n   * Transition the form to the submit success state.\n   * @param {!JsonObject} result\n   * @param {!ActionTrust} incomingTrust Trust of the originating submit action.\n   * @param {?JsonObject=} opt_eventData\n   * @return {!Promise}\n   * @private\n   */\n  handleSubmitSuccess_(result, incomingTrust, opt_eventData) {\n    this.setState_(FormState.SUBMIT_SUCCESS);\n    // TODO: Investigate if `tryResolve()` can be removed here.\n    return tryResolve(() => {\n      this.renderTemplate_(result || {}).then(() => {\n        const outgoingTrust = this.trustForSubmitResponse_(incomingTrust);\n        this.triggerAction_(\n          FormEvents.SUBMIT_SUCCESS,\n          opt_eventData === undefined ? result : opt_eventData,\n          outgoingTrust\n        );\n        this.dirtinessHandler_.onSubmitSuccess();\n      });\n    });\n  }\n\n  /**\n   * @param {*} e\n   * @param {!ActionTrust} incomingTrust Trust of the originating submit action.\n   * @return {!Promise}\n   * @private\n   */\n  handleXhrSubmitFailure_(e, incomingTrust) {\n    let promise;\n    if (e && e.response) {\n      const error = /** @type {!Error} */ (e);\n      promise = this.xhr_\n        .xssiJson(error.response, this.getXssiPrefix())\n        .catch(() => null);\n    } else {\n      promise = Promise.resolve(null);\n    }\n    return promise.then((responseJson) => {\n      this.handleSubmitFailure_(e, responseJson, incomingTrust);\n      this.triggerFormSubmitInAnalytics_('amp-form-submit-error');\n      this.maybeHandleRedirect_(e.response);\n    });\n  }\n\n  /**\n   * Transition the form the the submit error state.\n   * @param {*} error\n   * @param {!JsonObject} json\n   * @param {!ActionTrust} incomingTrust\n   * @param {?JsonObject=} opt_eventData\n   * @return {!Promise}\n   * @private\n   */\n  handleSubmitFailure_(error, json, incomingTrust, opt_eventData) {\n    this.setState_(FormState.SUBMIT_ERROR);\n    user().error(TAG, 'Form submission failed: %s', error);\n    // TODO: Investigate if `tryResolve()` can be removed here.\n    return tryResolve(() => {\n      this.renderTemplate_(json).then(() => {\n        const outgoingTrust = this.trustForSubmitResponse_(incomingTrust);\n        this.triggerAction_(\n          FormEvents.SUBMIT_ERROR,\n          opt_eventData === undefined ? json : opt_eventData,\n          outgoingTrust\n        );\n        this.dirtinessHandler_.onSubmitError();\n      });\n    });\n  }\n\n  /** @private */\n  handleNonXhrPost_() {\n    // non-XHR POST requests are not supported.\n    userAssert(\n      false,\n      'Only XHR based (via action-xhr attribute) submissions are supported ' +\n        'for POST requests. %s',\n      this.form_\n    );\n  }\n\n  /**\n   * Triggers Submit Analytics,\n   * and Form Element submit if passed by param.\n   * shouldSubmitFormElement should ONLY be true\n   * If the submit event.preventDefault was called\n   * @param {boolean} shouldSubmitFormElement\n   */\n  handleNonXhrGet_(shouldSubmitFormElement) {\n    this.triggerFormSubmitInAnalytics_('amp-form-submit');\n    if (shouldSubmitFormElement) {\n      this.form_.submit();\n    }\n    this.setState_(FormState.INITIAL);\n  }\n\n  /**\n   * Asserts that SSR support is the same as value.\n   * @param {boolean} value\n   * @param {string} msg\n   * @private\n   */\n  assertSsrTemplate_(value, msg) {\n    const supported = this.ssrTemplateHelper_.isEnabled();\n    userAssert(\n      supported === value,\n      '[amp-form]: viewerRenderTemplate | %s',\n      msg\n    );\n  }\n\n  /**\n   * Fail if there are password or file fields present when the function\n   * is called.\n   * @private\n   */\n  assertNoSensitiveFields_() {\n    const fields = this.form_.querySelectorAll(\n      'input[type=password],input[type=file]'\n    );\n    userAssert(\n      fields.length == 0,\n      'input[type=password] or input[type=file] ' +\n        'may only appear in form[method=post]'\n    );\n  }\n\n  /**\n   * @return {boolean} False if the form is invalid.\n   * @private\n   */\n  checkValidity_() {\n    if (isCheckValiditySupported(this.win_.document)) {\n      // Validity checking should always occur, novalidate only circumvent\n      // reporting and blocking submission on non-valid forms.\n      const isValid = checkUserValidityOnSubmission(this.form_);\n      if (this.shouldValidate_) {\n        this.validator_.report();\n        return isValid;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Handles response redirect throught the AMP-Redirect-To response header.\n   * Not applicable if viewer can render templates.\n   * @param {?Response} response\n   * @private\n   */\n  maybeHandleRedirect_(response) {\n    this.assertSsrTemplate_(false, 'Redirects not supported.');\n    if (!response || !response.headers) {\n      return;\n    }\n    const redirectTo = response.headers.get(REDIRECT_TO_HEADER);\n    if (redirectTo) {\n      userAssert(\n        !this.isAmp4Email_,\n        'Redirects not supported in AMP4Email.',\n        this.form_\n      );\n      userAssert(\n        this.target_ != '_blank',\n        'Redirecting to target=_blank using AMP-Redirect-To is currently ' +\n          'not supported, use target=_top instead. %s',\n        this.form_\n      );\n      try {\n        const urlService = Services.urlForDoc(this.ampdoc_);\n        urlService.assertAbsoluteHttpOrHttpsUrl(redirectTo);\n        urlService.assertHttpsUrl(redirectTo, 'AMP-Redirect-To', 'Url');\n      } catch (e) {\n        userAssert(\n          false,\n          'The `AMP-Redirect-To` header value must be an ' +\n            'absolute URL starting with https://. Found %s',\n          redirectTo\n        );\n      }\n      const navigator = Services.navigationForDoc(this.ampdoc_);\n      navigator.navigateTo(this.win_, redirectTo, REDIRECT_TO_HEADER);\n    }\n  }\n\n  /**\n   * Triggers an action e.g. submit success/error with response data.\n   * @param {!FormEvents} name\n   * @param {?JsonObject|!Array<{message: string, name: string}>} detail\n   * @param {!ActionTrust} trust\n   * @private\n   */\n  triggerAction_(name, detail, trust) {\n    const event = createCustomEvent(\n      this.win_,\n      `${TAG}.${name}`,\n      dict({'response': detail})\n    );\n    this.actions_.trigger(this.form_, name, event, trust);\n  }\n\n  /**\n   * Returns a race promise between resolving all promises or timing out.\n   * @param {!Array<!Promise>} promises\n   * @param {number} timeout\n   * @return {!Promise}\n   * @private\n   */\n  waitOnPromisesOrTimeout_(promises, timeout) {\n    return Promise.race([Promise.all(promises), this.timer_.promise(timeout)]);\n  }\n\n  /**\n   * @param {string} eventType\n   * @param {!JsonObject=} opt_vars A map of vars and their values.\n   * @private\n   */\n  analyticsEvent_(eventType, opt_vars) {\n    triggerAnalyticsEvent(this.form_, eventType, opt_vars);\n  }\n\n  /**\n   * Returns form data as an object.\n   * @return {!JsonObject}\n   * @private\n   */\n  getFormAsObject_() {\n    return getFormAsObject(this.form_);\n  }\n\n  /**\n   * Adds proper classes for the state passed.\n   * @param {!FormState} newState\n   * @private\n   */\n  setState_(newState) {\n    const previousState = this.state_;\n    this.form_.classList.remove(`amp-form-${previousState}`);\n    this.form_.classList.add(`amp-form-${newState}`);\n    this.cleanupRenderedTemplate_(previousState);\n    this.state_ = newState;\n  }\n\n  /**\n   * Renders a template based on the form state and its presence in the form.\n   * @param {!JsonObject} data\n   * @return {!Promise}\n   * @private\n   */\n  renderTemplate_(data) {\n    if (isArray(data)) {\n      data = dict();\n      user().warn(\n        TAG,\n        `Unexpected data type: ${data}. Expected non JSON array.`\n      );\n    }\n    const container = this.form_./*OK*/ querySelector(`[${this.state_}]`);\n    let p = Promise.resolve();\n    if (container) {\n      const messageId = `rendered-message-${this.id_}`;\n      container.setAttribute('role', 'alert');\n      container.setAttribute('aria-labeledby', messageId);\n      container.setAttribute('aria-live', 'assertive');\n      if (this.templates_.hasTemplate(container)) {\n        p = this.ssrTemplateHelper_\n          .applySsrOrCsrTemplate(devAssert(container), data)\n          .then((rendered) => {\n            // TODO(#29566): Simplify section appending rendered contents to DOM.\n            let renderContainer;\n            if (isArray(rendered)) {\n              if (rendered.length === 1) {\n                renderContainer = rendered[0];\n              } else {\n                renderContainer = document.createElement('div');\n                rendered.forEach((child) => renderContainer.appendChild(child));\n              }\n            } else {\n              renderContainer = rendered;\n            }\n            renderContainer.id = messageId;\n            renderContainer.setAttribute('i-amphtml-rendered', '');\n            return this.mutator_.mutateElement(\n              dev().assertElement(container),\n              () => {\n                container.appendChild(dev().assertElement(renderContainer));\n                const renderedEvent = createCustomEvent(\n                  this.win_,\n                  AmpEvents.DOM_UPDATE,\n                  /* detail */ null,\n                  {bubbles: true}\n                );\n                container.dispatchEvent(renderedEvent);\n              }\n            );\n          });\n      } else {\n        // TODO(vializ): This is to let AMP know that the AMP elements inside\n        // this container are now visible so they get scheduled for layout.\n        // This will be unnecessary when the AMP Layers implementation is\n        // complete.\n        this.mutator_.mutateElement(container, () => {});\n      }\n    }\n\n    if (getMode().test) {\n      this.renderTemplatePromise_ = p;\n    }\n\n    return p;\n  }\n\n  /**\n   * Removes the template for the passed state.\n   * @param {!FormState} state\n   * @private\n   */\n  cleanupRenderedTemplate_(state) {\n    const container = this.form_./*OK*/ querySelector(`[${state}]`);\n    if (!container) {\n      return;\n    }\n    const previousRender = childElementByAttr(container, 'i-amphtml-rendered');\n    if (previousRender) {\n      removeElement(previousRender);\n    }\n  }\n\n  /**\n   * Initialize form fields from query parameter values if attribute\n   * 'data-initialize-from-url' is present on the form and attribute\n   * 'data-allow-initialization' is present on the field.\n   * @private\n   */\n  maybeInitializeFromUrl_() {\n    if (\n      isProxyOrigin(this.win_.location) ||\n      !this.form_.hasAttribute('data-initialize-from-url')\n    ) {\n      return;\n    }\n\n    const valueTags = ['SELECT', 'TEXTAREA'];\n    const valueInputTypes = [\n      'color',\n      'date',\n      'datetime-local',\n      'email',\n      'hidden',\n      'month',\n      'number',\n      'range',\n      'search',\n      'tel',\n      'text',\n      'time',\n      'url',\n      'week',\n    ];\n    const checkedInputTypes = ['checkbox', 'radio'];\n\n    const maybeFillField = (field, name) => {\n      // Do not interfere with form fields that utilize variable substitutions.\n      // These fields are populated at time of form submission.\n      if (field.hasAttribute('data-amp-replace')) {\n        return;\n      }\n      // Form fields must be allowlisted\n      if (!field.hasAttribute('data-allow-initialization')) {\n        return;\n      }\n\n      const value = queryParams[name] || '';\n      const type = field.getAttribute('type') || 'text';\n      const tag = field.tagName;\n\n      if (tag === 'INPUT') {\n        if (valueInputTypes.includes(type.toLocaleLowerCase())) {\n          if (field.value !== value) {\n            field.value = value;\n          }\n        } else if (checkedInputTypes.includes(type)) {\n          const checked = field.value === value;\n          if (field.checked !== checked) {\n            field.checked = checked;\n          }\n        }\n      } else if (valueTags.includes(tag)) {\n        if (field.value !== value) {\n          field.value = value;\n        }\n      }\n    };\n\n    const queryParams = parseQueryString(this.win_.location.search);\n    Object.keys(queryParams).forEach((key) => {\n      // Typecast since Closure is missing NodeList union type in HTMLFormElement.elements.\n      const formControls = /** @type {(!Element|!NodeList)} */ (\n        this.form_.elements[key]\n      );\n      if (!formControls) {\n        return;\n      }\n\n      if (formControls.nodeType === Node.ELEMENT_NODE) {\n        const field = dev().assertElement(formControls);\n        maybeFillField(field, key);\n      } else if (formControls.length) {\n        const fields = /** @type {!NodeList} */ (formControls);\n        iterateCursor(fields, (field) => maybeFillField(field, key));\n      }\n    });\n  }\n\n  /**\n   * Returns a promise that resolves when tempalte render finishes. The promise\n   * will be null if the template render has not started.\n   * @visibleForTesting\n   * @return {*} TODO(#23582): Specify return type\n   */\n  renderTemplatePromiseForTesting() {\n    return this.renderTemplatePromise_;\n  }\n\n  /**\n   * Returns a promise that resolves when xhr submit finishes. The promise\n   * will be null if xhr submit has not started.\n   * @visibleForTesting\n   * @return {*} TODO(#23582): Specify return type\n   */\n  xhrSubmitPromiseForTesting() {\n    return this.xhrSubmitPromise_;\n  }\n}\n\n/**\n * Checks user validity for all inputs, fieldsets and the form.\n * @param {!HTMLFormElement} form\n * @return {boolean} Whether the form is currently valid or not.\n */\nfunction checkUserValidityOnSubmission(form) {\n  const elements = form.querySelectorAll('input,select,textarea,fieldset');\n  iterateCursor(elements, (element) => checkUserValidity(element));\n  return checkUserValidity(form);\n}\n\n/**\n * Returns the user validity state of the element.\n * @param {!Element} element\n * @return {string}\n */\nfunction getUserValidityStateFor(element) {\n  if (element.classList.contains('user-valid')) {\n    return UserValidityState.USER_VALID;\n  } else if (element.classList.contains('user-invalid')) {\n    return UserValidityState.USER_INVALID;\n  }\n\n  return UserValidityState.NONE;\n}\n\n/**\n * Updates class names on the element to reflect the active invalid types on it.\n *\n * @param {!Element} element\n */\nfunction updateInvalidTypesClasses(element) {\n  if (!element.validity) {\n    return;\n  }\n  for (const validationType in element.validity) {\n    element.classList.toggle(validationType, element.validity[validationType]);\n  }\n}\n\n/**\n * Removes all validity classes from elements in the given form.\n * @param {!Element} form\n */\nfunction removeValidityStateClasses(form) {\n  const dummyInput = document.createElement('input');\n  for (const validityState in dummyInput.validity) {\n    const elements = form.querySelectorAll(\n      `.${escapeCssSelectorIdent(validityState)}`\n    );\n    iterateCursor(elements, (element) => {\n      dev().assertElement(element).classList.remove(validityState);\n    });\n  }\n}\n\n/**\n * Checks user validity which applies .user-valid and .user-invalid AFTER the\n * user interacts with the input by moving away from the input (blur) or by\n * changing its value (input).\n *\n * See :user-invalid spec for more details:\n *   https://drafts.csswg.org/selectors-4/#user-pseudos\n *\n * The specs are still not fully specified. The current solution tries to follow\n * a common sense approach for when to apply these classes. As the specs gets\n * clearer, we should strive to match it as much as possible.\n *\n * @param {!Element} element\n * @param {boolean=} propagate Whether to propagate the user validity to\n * ancestors.\n * @return {boolean} Whether the element is valid or not.\n */\nfunction checkUserValidity(element, propagate = false) {\n  // TODO(mkhatib, #6930): Implement basic validation for custom inputs like\n  // amp-selector.\n  // If this is not a field type with checkValidity don't do anything.\n  if (!element.checkValidity) {\n    return true;\n  }\n  let shouldPropagate = false;\n  const previousValidityState = getUserValidityStateFor(element);\n  const isCurrentlyValid = element.checkValidity();\n  if (\n    previousValidityState != UserValidityState.USER_VALID &&\n    isCurrentlyValid\n  ) {\n    element.classList.add('user-valid');\n    element.classList.remove('user-invalid');\n    // Don't propagate user-valid unless it was marked invalid before.\n    shouldPropagate = previousValidityState == UserValidityState.USER_INVALID;\n  } else if (\n    previousValidityState != UserValidityState.USER_INVALID &&\n    !isCurrentlyValid\n  ) {\n    element.classList.add('user-invalid');\n    element.classList.remove('user-valid');\n    // Always propagate an invalid state change. One invalid input field is\n    // guaranteed to make the fieldset and form invalid as well.\n    shouldPropagate = true;\n  }\n  updateInvalidTypesClasses(element);\n\n  if (propagate && shouldPropagate) {\n    // Propagate user validity to ancestor fieldsets.\n    const ancestors = ancestorElementsByTag(element, 'fieldset');\n    for (let i = 0; i < ancestors.length; i++) {\n      checkUserValidity(ancestors[i]);\n    }\n    // Also update the form user validity.\n    if (element.form) {\n      checkUserValidity(element.form);\n    }\n  }\n\n  return isCurrentlyValid;\n}\n\n/**\n * Responds to user interaction with an input by checking user validity of the\n * input and possibly its input-related ancestors (e.g. feildset, form).\n * @param {!Element} input\n * @private\n */\nexport function checkUserValidityAfterInteraction_(input) {\n  checkUserValidity(input, /* propagate */ true);\n}\n\n/**\n * Bootstraps the amp-form elements\n */\nexport class AmpFormService {\n  /**\n   * @param  {!../../../src/service/ampdoc-impl.AmpDoc} ampdoc\n   */\n  constructor(ampdoc) {\n    /** @const @private {!Promise} */\n    this.whenInitialized_ = this.installStyles_(ampdoc).then(() =>\n      this.installHandlers_(ampdoc)\n    );\n\n    // Dispatch a test-only event for integration tests.\n    if (getMode().test) {\n      this.whenInitialized_.then(() => {\n        const {win} = ampdoc;\n        const event = createCustomEvent(win, FormEvents.SERVICE_INIT, null, {\n          bubbles: true,\n        });\n        win.dispatchEvent(event);\n      });\n    }\n  }\n\n  /**\n   * Returns a promise that resolves when all form implementations (if any)\n   * have been upgraded.\n   * @return {!Promise}\n   */\n  whenInitialized() {\n    return this.whenInitialized_;\n  }\n\n  /**\n   * Install the amp-form CSS\n   * @param  {!../../../src/service/ampdoc-impl.AmpDoc} ampdoc\n   * @return {!Promise}\n   * @private\n   */\n  installStyles_(ampdoc) {\n    const deferred = new Deferred();\n    installStylesForDoc(ampdoc, CSS, deferred.resolve, false, TAG);\n    return deferred.promise;\n  }\n\n  /**\n   * Install the event handlers\n   * @param  {!../../../src/service/ampdoc-impl.AmpDoc} ampdoc\n   * @return {!Promise}\n   * @private\n   */\n  installHandlers_(ampdoc) {\n    return ampdoc.whenReady().then(() => {\n      const root = ampdoc.getRootNode();\n\n      this.installSubmissionHandlers_(root.querySelectorAll('form'));\n      AmpFormTextarea.install(ampdoc);\n      this.installDomUpdateEventListener_(root);\n      this.installFormSubmissionShortcutForTextarea_(root);\n    });\n  }\n\n  /**\n   * Install submission handler on all forms in the document.\n   * @param {?IArrayLike<T>} forms\n   * @template T\n   * @private\n   */\n  installSubmissionHandlers_(forms) {\n    if (!forms) {\n      return;\n    }\n\n    iterateCursor(forms, (form, index) => {\n      const existingAmpForm = formOrNullForElement(form);\n      if (!existingAmpForm) {\n        new AmpForm(form, `amp-form-${index}`);\n      }\n    });\n  }\n\n  /**\n   * Listen for DOM updated messages sent to the document.\n   * @param {!Document|!ShadowRoot} doc\n   * @private\n   */\n  installDomUpdateEventListener_(doc) {\n    doc.addEventListener(AmpEvents.DOM_UPDATE, () => {\n      this.installSubmissionHandlers_(doc.querySelectorAll('form'));\n    });\n  }\n\n  /**\n   * Listen for Ctrl/Cmd + Enter in textarea elements\n   * to trigger form submission when relevant.\n   * @param {!Document|!ShadowRoot} doc\n   */\n  installFormSubmissionShortcutForTextarea_(doc) {\n    doc.addEventListener('keydown', (e) => {\n      if (\n        e.defaultPrevented ||\n        e.key != Keys.ENTER ||\n        !(e.ctrlKey || e.metaKey) ||\n        e.target.tagName !== 'TEXTAREA'\n      ) {\n        return;\n      }\n      const {form} = e.target;\n      const ampForm = form ? formOrNullForElement(form) : null;\n      if (!ampForm) {\n        return;\n      }\n      ampForm.handleSubmitEvent_(e);\n      e.preventDefault();\n    });\n  }\n}\n\nAMP.extension(TAG, '0.1', (AMP) => {\n  AMP.registerServiceForDoc('form-submit-service', FormSubmitService);\n  AMP.registerServiceForDoc(TAG, AmpFormService);\n});\n"],
  "mappings": "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",
  "names": []
}
