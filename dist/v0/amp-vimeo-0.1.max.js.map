{
  "version": 3,
  "sources": ["../../src/core/mode/prod.js", "../../src/core/mode/minified.js", "../../src/core/mode/esm.js", "../../src/core/types/object/index.js", "../../src/core/types/array.js", "../../src/core/types/object/json.js", "../../src/core/window/index.js", "../../src/core/types/index.js", "../../src/core/error/message-helpers.js", "../../src/core/assert/base.js", "../../src/core/assert/dev.js", "../../third_party/css-escape/css-escape.js", "../../src/core/dom/index.js", "../../src/core/dom/layout/index.js", "../../src/core/data-structures/promise.js", "../../src/core/error/index.js", "../../src/core/dom/style.js", "../../src/core/dom/video/index.js", "../../src/core/dom/layout/size-observer.js", "../../src/core/dom/video/pause-helper.js", "../../src/core/types/function/index.js", "../../src/config.js", "../../src/service/extension-script.js", "../../src/utils/log.js", "../../src/service-helpers.js", "../../src/element-service.js", "../../src/service/index.js", "../../src/core/constants/action-constants.js", "../../src/core/dom/layout/viewport-observer.js", "../../src/core/dom/layout/intersection.js", "../../src/core/math.js", "../../src/core/dom/event-helper-listen.js", "../../src/utils/event-helper.js", "../../src/core/data-structures/observable.js", "../../src/service/video-session-manager.js", "../../src/core/dom/static-template.js", "../../src/service/video/autoplay.js", "../../build/video-autoplay.css.js", "../../src/style-installer.js", "../../src/service/video/install-autoplay-styles.js", "../../src/mediasession-helper.js", "../../src/video-interface.js", "../../src/service/video-manager-impl.js", "../../src/core/dom/propagate-attributes.js", "../../src/iframe-video.js", "../../src/url.js", "../../extensions/amp-vimeo/vimeo-api.js", "../../extensions/amp-vimeo/0.1/amp-vimeo.js"],
  "sourcesContent": ["/**\n * Returns true when the build is meant for distribution.\n * This means `amp dist` was called _without_ the --fortesting flag.\n *\n * This is a magic constant replaced by babel.\n *\n * Calls are DCE'd when compiled.\n * @return {boolean}\n */\nexport function isProd() {\n  return IS_PROD;\n}\n", "/**\n * Returns true whenever closure compiler is used.\n * This is a magic constant that is replaced by babel.\n *\n * @return {boolean}\n */\nexport function isMinified() {\n  return IS_MINIFIED;\n}\n", "/**\n * Copyright 2021 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {isProd} from './prod';\n\n/**\n * Returns true when compiling an esm binary.\n * This is a magic constant that is replaced by babel.\n *\n * @return {boolean}\n */\nexport function isEsm() {\n  if (isProd()) {\n    return IS_ESM;\n  }\n\n  return self?.__AMP_MODE?.esm ?? IS_ESM;\n}\n", "/* @const */\nconst {hasOwnProperty: hasOwn_, toString: toString_} = Object.prototype;\n\n/**\n * Determines if value is actually an Object.\n * @param {*} value\n * @return {boolean}\n */\nexport function isObject(value) {\n  return toString_.call(value) === '[object Object]';\n}\n\n/**\n * Returns a map-like object.\n * If opt_initial is provided, copies its own properties into the\n * newly created object.\n * @param {T=} opt_initial This should typically be an object literal.\n * @return {T}\n * @template T\n */\nexport function map(opt_initial) {\n  const obj = Object.create(null);\n  if (opt_initial) {\n    Object.assign(obj, opt_initial);\n  }\n  return obj;\n}\n\n/**\n * Return an empty JsonObject or makes the passed in object literal\n * an JsonObject.\n * The JsonObject type is just a simple object that is at-dict.\n * See\n * https://github.com/google/closure-compiler/wiki/@struct-and-@dict-Annotations\n * for what a dict is type-wise.\n * The linter enforces that the argument is, in fact, at-dict like.\n * @param {!Object=} opt_initial\n * @return {!JsonObject}\n */\nexport function dict(opt_initial) {\n  // We do not copy. The linter enforces that the passed in object is a literal\n  // and thus the caller cannot have a reference to it.\n  return /** @type {!JsonObject} */ (opt_initial || {});\n}\n\n/**\n * Checks if the given key is a property in the map.\n *\n * @param {T}  obj a map like property.\n * @param {string}  key\n * @return {boolean}\n * @template T\n */\nexport function hasOwn(obj, key) {\n  return hasOwn_.call(obj, key);\n}\n\n/**\n * Returns obj[key] iff key is obj's own property (is not inherited).\n * Otherwise, returns undefined.\n *\n * @param {Object} obj\n * @param {string} key\n * @return {*}\n */\nexport function ownProperty(obj, key) {\n  if (hasOwn(obj, key)) {\n    return obj[key];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Deep merges source into target.\n *\n * @param {!Object} target\n * @param {!Object} source\n * @param {number} depth The maximum merge depth. If exceeded, Object.assign\n *                       will be used instead.\n * @return {!Object}\n * @throws {Error} If source contains a circular reference.\n * Note: Only nested objects are deep-merged, primitives and arrays are not.\n */\nexport function deepMerge(target, source, depth = 10) {\n  // Keep track of seen objects to detect recursive references.\n  const seen = [];\n\n  /** @type {!Array<{t: !Object, s: !Object, d: number}>} */\n  const queue = [];\n  queue.push({t: target, s: source, d: 0});\n\n  // BFS to ensure objects don't have recursive references at shallower depths.\n  while (queue.length > 0) {\n    const {d, s, t} = queue.shift();\n    if (seen.includes(s)) {\n      throw new Error('Source object has a circular reference.');\n    }\n    seen.push(s);\n    if (t === s) {\n      continue;\n    }\n    if (d > depth) {\n      Object.assign(t, s);\n      continue;\n    }\n    for (const key of Object.keys(s)) {\n      const newValue = s[key];\n      // Perform a deep merge IFF both target and source have the same key\n      // whose corresponding values are objects.\n      if (hasOwn(t, key)) {\n        const oldValue = t[key];\n        if (isObject(newValue) && isObject(oldValue)) {\n          queue.push({t: oldValue, s: newValue, d: d + 1});\n          continue;\n        }\n      }\n      t[key] = newValue;\n    }\n  }\n  return target;\n}\n\n/**\n * @param {!Object} o An object to remove properties from\n * @param {!Array<string>} props A list of properties to remove from the Object\n * @return {!Object} An object with the given properties removed\n */\nexport function omit(o, props) {\n  return Object.keys(o).reduce((acc, key) => {\n    if (!props.includes(key)) {\n      acc[key] = o[key];\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * @param {!Object|null|undefined} o1\n * @param {!Object|null|undefined} o2\n * @return {boolean}\n */\nexport function objectsEqualShallow(o1, o2) {\n  if (o1 == null || o2 == null) {\n    // Null is only equal to null, and undefined to undefined.\n    return o1 === o2;\n  }\n\n  for (const k in o1) {\n    if (o1[k] !== o2[k]) {\n      return false;\n    }\n  }\n  for (const k in o2) {\n    if (o2[k] !== o1[k]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @param {T} obj\n * @param {string} prop\n * @param {function(T, string):R} factory\n * @return {R}\n * @template T,R\n */\nexport function memo(obj, prop, factory) {\n  let result = /** @type {?R} */ (obj[prop]);\n  if (result === undefined) {\n    result = factory(obj, prop);\n    obj[prop] = result;\n  }\n  return result;\n}\n\n/**\n * Recreates objects with prototype-less copies.\n * @param {!JsonObject} obj\n * @return {!JsonObject}\n */\nexport function recreateNonProtoObject(obj) {\n  const copy = map();\n  for (const k in obj) {\n    if (!hasOwn(obj, k)) {\n      continue;\n    }\n    const v = obj[k];\n    copy[k] = isObject(v) ? recreateNonProtoObject(v) : v;\n  }\n  return /** @type {!JsonObject} */ (copy);\n}\n\n/**\n * Returns a value from an object for a field-based expression. The expression\n * is a simple nested dot-notation of fields, such as `field1.field2`. If any\n * field in a chain does not exist or is not an object or array, the returned\n * value will be `undefined`.\n *\n * @param {!JsonObject} obj\n * @param {string} expr\n * @return {*}\n */\nexport function getValueForExpr(obj, expr) {\n  // The `.` indicates \"the object itself\".\n  if (expr == '.') {\n    return obj;\n  }\n  // Otherwise, navigate via properties.\n  const parts = expr.split('.');\n  let value = obj;\n  for (const part of parts) {\n    if (\n      part &&\n      value &&\n      value[part] !== undefined &&\n      typeof value == 'object' &&\n      hasOwn(value, part)\n    ) {\n      value = value[part];\n      continue;\n    }\n    value = undefined;\n    break;\n  }\n  return value;\n}\n", "/**\n * Converts an array-like object to an array.\n * @param {?IArrayLike<T>|string} arrayLike\n * @return {!Array<T>}\n * @template T\n */\nexport function toArray(arrayLike) {\n  return arrayLike ? Array.prototype.slice.call(arrayLike) : [];\n}\n\n/**\n * Determines if value is actually an Array.\n * @param {*} value\n * @return {boolean}\n */\nexport const {isArray} = Array;\n\n/**\n * If the specified argument is an array, it's returned as is. If it's a\n * single item, the array containing this item is created and returned.\n *\n * The double-template pattern here solves a bug where CC can be passed a value\n * with declared type {string|!Array<string>} and return a value with a type of\n * {!Array<string|Array<string>>}.\n *\n * @param {!Array<T>|S} arrayOrSingleItem\n * @return {!Array<T>|!Array<S>}\n * @template S\n * @template T\n */\nexport function arrayOrSingleItemToArray(arrayOrSingleItem) {\n  return isArray(arrayOrSingleItem)\n    ? /** @type {!Array<T>} */ (arrayOrSingleItem)\n    : [/** @type {!S} */ (arrayOrSingleItem)];\n}\n\n/**\n * Compares if two arrays contains exactly same elements of same number\n * of same order. Note that it does NOT handle NaN case as expected.\n *\n * @param {!Array<T>} arr1\n * @param {!Array<T>} arr2\n * @return {boolean}\n * @template T\n */\nexport function areEqualOrdered(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Removes elements that shouldRemove returns true for from the array.\n *\n * @param {!Array<T>} array\n * @param {function(T, number, !Array<T>):boolean} shouldRemove\n * @return {!Array<T>}\n * @template T\n */\nexport function remove(array, shouldRemove) {\n  const removed = [];\n  let index = 0;\n  for (let i = 0; i < array.length; i++) {\n    const item = array[i];\n    if (shouldRemove(item, i, array)) {\n      removed.push(item);\n    } else {\n      if (index < i) {\n        array[index] = item;\n      }\n      index++;\n    }\n  }\n  if (index < array.length) {\n    array.length = index;\n  }\n  return removed;\n}\n\n/**\n * Returns the index of the first element matching the predicate.\n * Like Array#findIndex.\n *\n * @param {!Array<T>} array\n * @param {function(T, number, !Array<T>):boolean} predicate\n * @return {number}\n * @template T\n */\nexport function findIndex(array, predicate) {\n  for (let i = 0; i < array.length; i++) {\n    if (predicate(array[i], i, array)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Converts the given iterator to an array.\n *\n * @param {!Iterator<T>} iterator\n * @return {Array<T>}\n * @template T\n */\nexport function fromIterator(iterator) {\n  const array = [];\n  for (let e = iterator.next(); !e.done; e = iterator.next()) {\n    array.push(e.value);\n  }\n  return array;\n}\n\n/**\n * Adds item to array if it is not already present.\n *\n * @param {Array<T>} array\n * @param {T} item\n * @return {boolean}\n * @template T\n */\nexport function pushIfNotExist(array, item) {\n  if (array.indexOf(item) < 0) {\n    array.push(item);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes the first matching item in the array. Returns `true` if the array\n * has changed.\n *\n * @param {!Array<T>} array\n * @param {T} item\n * @return {boolean}\n * @template T\n */\nexport function removeItem(array, item) {\n  const index = array.indexOf(item);\n  if (index == -1) {\n    return false;\n  }\n  array.splice(index, 1);\n  return true;\n}\n\n/**\n * Returns the last item in an array.\n *\n * @param {Array<T>} array\n * @template T\n * @return {?T}\n */\nexport function lastItem(array) {\n  return array[array.length - 1];\n}\n", "import {isArray} from '#core/types/array';\n\n/**\n * @fileoverview This module declares JSON types as defined in the\n * {@link http://json.org/}.\n */\n\n// NOTE Type are changed to {*} because of\n// https://github.com/google/closure-compiler/issues/1999\n\n/**\n * JSON scalar. It's either string, number or boolean.\n * @typedef {string|number|boolean|null}\n */\nlet JSONScalarDef;\n\n/**\n * JSON object. It's a map with string keys and JSON values.\n * @typedef {!Object<string, ?*>} (* should be JSONValueDef)\n */\nlet JSONObjectDef;\n\n/**\n * JSON array. It's an array with JSON values.\n * @typedef {!Array<?*>} (* should be JSONValueDef)\n */\nlet JSONArrayDef;\n\n/**\n * JSON value. It's either a scalar, an object or an array.\n * @typedef {!JSONScalarDef|!JSONObjectDef|!JSONArrayDef}\n */\nlet JSONValueDef;\n\n/**\n * @typedef {{\n *   YOU_MUST_USE: string,\n *   jsonLiteral: function(),\n *   TO_MAKE_THIS_TYPE: string,\n * }}\n */\nlet InternalJsonLiteralTypeDef;\n\n/**\n * Simple wrapper around JSON.parse that casts the return value\n * to JsonObject.\n * Create a new wrapper if an array return value is desired.\n * @param {string} json JSON string to parse\n * @return {?JsonObject} May be extend to parse arrays.\n */\nexport function parseJson(json) {\n  return /** @type {?JsonObject} */ (JSON.parse(json));\n}\n\n/**\n * Parses the given `json` string without throwing an exception if not valid.\n * Returns `undefined` if parsing fails.\n * Returns the `Object` corresponding to the JSON string when parsing succeeds.\n * @param {string} json JSON string to parse\n * @param {function(!Error)=} opt_onFailed Optional function that will be called\n *     with the error if parsing fails.\n * @return {?JsonObject} May be extend to parse arrays.\n */\nexport function tryParseJson(json, opt_onFailed) {\n  try {\n    return parseJson(json);\n  } catch (e) {\n    opt_onFailed?.(e);\n    return null;\n  }\n}\n\n/**\n * Deeply checks strict equality of items in nested arrays and objects.\n *\n * @param {JSONValueDef} a\n * @param {JSONValueDef} b\n * @param {number} depth The maximum depth. Must be finite.\n * @return {boolean}\n * @throws {Error} If depth argument is not finite.\n */\nexport function deepEquals(a, b, depth = 5) {\n  if (!isFinite(depth) || depth < 0) {\n    throw new Error('Invalid depth: ' + depth);\n  }\n  if (a === b) {\n    return true;\n  }\n  /** @type {!Array<{a: JSONValueDef, b: JSONValueDef, depth: number}>} */\n  const queue = [{a, b, depth}];\n  while (queue.length > 0) {\n    const {a, b, depth} = queue.shift();\n    // Only check deep equality if depth > 0.\n    if (depth > 0) {\n      if (typeof a !== typeof b) {\n        return false;\n      } else if (isArray(a) && isArray(b)) {\n        if (a.length !== b.length) {\n          return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n          queue.push({a: a[i], b: b[i], depth: depth - 1});\n        }\n        continue;\n      } else if (a && b && typeof a === 'object' && typeof b === 'object') {\n        const keysA = Object.keys(a);\n        const keysB = Object.keys(b);\n        if (keysA.length !== keysB.length) {\n          return false;\n        }\n        for (const k of keysA) {\n          queue.push({a: a[k], b: b[k], depth: depth - 1});\n        }\n        continue;\n      }\n    }\n    // If we get here, then depth == 0 or (a, b) are primitives.\n    if (a !== b) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * This helper function handles configurations specified in a JSON format.\n *\n * It allows the configuration is to be written in plain JS (which has better\n * dev ergonomics like comments and trailing commas), and allows the\n * configuration to be transformed into an efficient JSON-parsed representation\n * in the dist build. See https://v8.dev/blog/cost-of-javascript-2019#json\n *\n * @param {!Object} obj\n * @return {!JsonObject}\n */\nexport function jsonConfiguration(obj) {\n  return /** @type {!JsonObject} */ (obj);\n}\n\n/**\n * This converts an Object into a suitable type to be used in `includeJsonLiteral`.\n * This doesn't actually do any conversion, it only changes the closure type.\n *\n * @param {?JSONValueDef} value\n * @return {!InternalJsonLiteralTypeDef}\n */\nexport function jsonLiteral(value) {\n  return /** @type {!InternalJsonLiteralTypeDef} */ (value);\n}\n\n/**\n * Allows inclusion of a variable (that's wrapped in a jsonLiteral\n * call) to be included inside a jsonConfiguration.\n *\n * @param {!InternalJsonLiteralTypeDef} value\n * @return {*}\n */\nexport function includeJsonLiteral(value) {\n  return value;\n}\n", "/**\n * Externs declare that access `defaultView` from `document` or\n * `ownerDocument` is of type `(Window|null)` but most of our parameter types\n * assume that it is never null. This is OK in practice as we ever only get\n * null on disconnected documents or old IE.\n * This helper function casts it into just a simple Window return type.\n *\n * @param {?Window} winOrNull\n * @return {!Window}\n */\nexport function toWin(winOrNull) {\n  return /** @type {!Window} */ (winOrNull);\n}\n\n/**\n * Returns the associated Window for a node.\n *\n * @param {!Node} node\n * @return {!Window}\n */\nexport function getWin(node) {\n  return toWin(\n    (node.ownerDocument || /** @type {!Document} */ (node)).defaultView\n  );\n}\n", "// Export all type-checking helpers for convenience\nexport {isArray} from './array';\nexport {isEnumValue} from './enum';\nexport {isString} from './string';\nexport {isObject} from './object';\n\n/**\n * Determines if value is an ELement\n * @param {*} value\n * @return {boolean}\n */\nexport function isElement(value) {\n  return value?.nodeType == /* Node.ELEMENT_NODE */ 1;\n}\n\n/**\n * Determines if value is of number type and finite.\n * NaN and Infinity are not considered a finite number.\n * String numbers are not considered numbers.\n * @param {*} value\n * @return {boolean}\n */\nexport function isFiniteNumber(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n", "import {isElement} from '#core/types';\n\n/**\n * Triple zero width space.\n *\n * This is added to user error messages, so that we can later identify\n * them, when the only thing that we have is the message. This is the\n * case in many browsers when the global exception handler is invoked.\n *\n * @const {string}\n */\nexport const USER_ERROR_SENTINEL = '\\u200B\\u200B\\u200B';\n/**\n * Four zero width space.\n *\n * @const {string}\n */\nexport const USER_ERROR_EMBED_SENTINEL = '\\u200B\\u200B\\u200B\\u200B';\n\n/**\n * Converts an element to a readable string; all other types are unchanged.\n * TODO(rcebulko): Unify with log.js\n * @param {*} val\n * @return {*}\n */\nexport function elementStringOrPassThru(val) {\n  // Do check equivalent to `val instanceof Element` without cross-window bug\n  if (isElement(val)) {\n    val = /** @type {Element} */ (val);\n    return val.tagName.toLowerCase() + (val.id ? `#${val.id}` : '');\n  }\n  return val;\n}\n\n/**\n * Tests if an error message contains the user sentinel.\n * @param {string} message\n * @return {boolean} Whether this message was a user error.\n */\nexport function isUserErrorMessage(message) {\n  return message.indexOf(USER_ERROR_SENTINEL) >= 0;\n}\n\n/**\n * @param {string} message\n * @return {boolean} Whether this message was a a user error from an iframe embed.\n */\nexport function isUserErrorEmbedMessage(message) {\n  return message.indexOf(USER_ERROR_EMBED_SENTINEL) >= 0;\n}\n\n/**\n * Strips the user error sentinel from an error message.\n * @param {string} message\n * @return {string} The new message without USER_ERROR_SENTINEL\n */\nexport function stripUserError(message) {\n  return message.replace(USER_ERROR_SENTINEL, '');\n}\n", "import {elementStringOrPassThru} from '#core/error/message-helpers';\nimport {isArray, isElement, isString} from '#core/types';\nimport {remove} from '#core/types/array';\n\n/**\n * @fileoverview This file provides the base implementation for assertion\n * functions. Most files should never import from this; instead, import from\n * `dev` or `user`. It is also used by the Log class for its assertions.\n */\n\n/**\n * A base assertion function, provided to various assertion helpers.\n * @typedef {function(?, string=, ...*):?|function(?, !Array<*>)}\n */\nexport let AssertionFunctionDef;\n\n/**\n * Throws an error if the second argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n * @param {?string} sentinel\n * @param {T} shouldBeTruthy\n * @param {string} opt_message\n * @param {...*} var_args Arguments substituted into %s in the message\n * @return {T}\n * @template T\n * @throws {Error} when shouldBeTruthy is not truthy.\n */\nexport function assert(\n  sentinel,\n  shouldBeTruthy,\n  opt_message = 'Assertion failed',\n  var_args\n) {\n  if (shouldBeTruthy) {\n    return shouldBeTruthy;\n  }\n\n  // Include the sentinel string if provided and not already present\n  if (sentinel && opt_message.indexOf(sentinel) == -1) {\n    opt_message += sentinel;\n  }\n\n  // Skip the first 3 arguments to isolate format params\n  // const messageArgs = Array.prototype.slice.call(arguments, 3);\n  // Index at which message args start\n  let i = 3;\n\n  // Substitute provided values into format string in message\n  const splitMessage = opt_message.split('%s');\n  let message = splitMessage.shift();\n  const messageArray = [message];\n\n  while (splitMessage.length) {\n    const subValue = arguments[i++];\n    const nextConstant = splitMessage.shift();\n\n    message += elementStringOrPassThru(subValue) + nextConstant;\n    messageArray.push(subValue, nextConstant.trim());\n  }\n\n  const error = new Error(message);\n  error.messageArray = remove(messageArray, (x) => x !== '');\n  // __AMP_REPORT_ERROR is installed globally per window in the entry point in\n  // AMP documents. It may not be present for Bento/Preact elements on non-AMP\n  // pages.\n  self.__AMP_REPORT_ERROR?.(error);\n  throw error;\n}\n\n/**\n * Asserts types, backbone of `assertNumber`, `assertString`, etc.\n *\n * It understands array-based \"id\"-contracted messages.\n *\n * Otherwise creates a sprintf syntax string containing the optional message or the\n * default. The `subject` of the assertion is added at the end.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {T} subject\n * @param {*} shouldBeTruthy\n * @param {string} defaultMessage\n * @param {!Array<*>|string=} opt_message\n * @return {T}\n * @template T\n * @private\n */\nfunction assertType_(\n  assertFn,\n  subject,\n  shouldBeTruthy,\n  defaultMessage,\n  opt_message\n) {\n  if (isArray(opt_message)) {\n    assertFn(\n      shouldBeTruthy,\n      /** @type {!Array} */ (opt_message).concat([subject])\n    );\n  } else {\n    assertFn(shouldBeTruthy, `${opt_message || defaultMessage}: %s`, subject);\n  }\n\n  return subject;\n}\n\n/**\n * Throws an error if the first argument isn't an Element.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeElement\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Element} The value of shouldBeTrueish.\n * @throws {Error} when shouldBeElement is not an Element\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertElement(assertFn, shouldBeElement, opt_message) {\n  return /** @type {!Element} */ (\n    assertType_(\n      assertFn,\n      shouldBeElement,\n      isElement(shouldBeElement),\n      'Element expected',\n      opt_message\n    )\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a string. The string can\n * be empty.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeString\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {string} The string value. Can be an empty string.\n * @throws {Error} when shouldBeString is not an String\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertString(assertFn, shouldBeString, opt_message) {\n  return /** @type {string} */ (\n    assertType_(\n      assertFn,\n      shouldBeString,\n      isString(shouldBeString),\n      'String expected',\n      opt_message\n    )\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a number. The allowed values\n * include `0` and `NaN`.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeNumber\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {number} The number value. The allowed values include `0`\n *   and `NaN`.\n * @throws {Error} when shouldBeNumber is not an Number\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertNumber(assertFn, shouldBeNumber, opt_message) {\n  return /** @type {number} */ (\n    assertType_(\n      assertFn,\n      shouldBeNumber,\n      typeof shouldBeNumber == 'number',\n      'Number expected',\n      opt_message\n    )\n  );\n}\n\n/**\n * Throws an error if the first argument is not an array.\n * The array can be empty.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeArray\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Array} The array value\n * @throws {Error} when shouldBeArray is not an Array\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertArray(assertFn, shouldBeArray, opt_message) {\n  return /** @type {!Array} */ (\n    assertType_(\n      assertFn,\n      shouldBeArray,\n      isArray(shouldBeArray),\n      'Array expected',\n      opt_message\n    )\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a boolean.\n *\n * For more details see `assert`.\n *\n * @param {!AssertionFunctionDef} assertFn underlying assertion function to call\n * @param {*} shouldBeBoolean\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {boolean} The boolean value.\n * @throws {Error} when shouldBeBoolean is not an Boolean\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertBoolean(assertFn, shouldBeBoolean, opt_message) {\n  return /** @type {boolean} */ (\n    assertType_(\n      assertFn,\n      shouldBeBoolean,\n      !!shouldBeBoolean === shouldBeBoolean,\n      'Boolean expected',\n      opt_message\n    )\n  );\n}\n", "import * as mode from '#core/mode';\n\nimport * as assertions from './base';\n\n/**\n * @fileoverview This file provides the entrypoint for dev assertions. It's\n * designed so all functions are pure function calls to improve inlining. All\n * functions in this file get DCE'd away during compilation.\n */\n\n/**\n * This will never execute regardless, but will be included on unminified builds\n * builds. It will be DCE'd away from minified builds, and so can be used to\n * validate that Babel is properly removing dev assertions in minified builds.\n */\nfunction devAssertDceCheck() {\n  if (self.__AMP_ASSERTION_CHECK) {\n    console /*OK*/\n      .log('__devAssert_sentinel__');\n  }\n}\n\n/**\n * Throws an error if the first argument isn't trueish. Mirrors devAssert in\n * src/log.js.\n * @param {T} shouldBeTruthy\n * @param {string=} opt_message\n * @param {*=} opt_1 Optional argument (var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {T}\n * @template T\n * @throws {Error} when shouldBeTruthy is not truthy.\n * @closurePrimitive {asserts.truthy}\n */\nexport function devAssert(\n  shouldBeTruthy,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  if (mode.isMinified()) {\n    return shouldBeTruthy;\n  }\n  devAssertDceCheck();\n\n  return assertions.assert(\n    '',\n    shouldBeTruthy,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n\n/**\n * Throws an error if the first argument isn't an Element.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeElement\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Element} The value of shouldBeTrueish.\n * @throws {Error} when shouldBeElement is not an Element\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertElement(shouldBeElement, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {!Element} */ (shouldBeElement);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertElement(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeElement,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a string. The string can\n * be empty.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeString\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {string} The string value. Can be an empty string.\n * @throws {Error} when shouldBeString is not an String\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertString(shouldBeString, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {string} */ (shouldBeString);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertString(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeString,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a number. The allowed values\n * include `0` and `NaN`.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeNumber\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {number} The number value. The allowed values include `0`\n *   and `NaN`.\n * @throws {Error} when shouldBeNumber is not an Number\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertNumber(shouldBeNumber, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {number} */ (shouldBeNumber);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertNumber(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeNumber,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument is not an array.\n * The array can be empty.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeArray\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {!Array} The array value\n * @throws {Error} when shouldBeArray is not an Array\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertArray(shouldBeArray, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {!Array} */ (shouldBeArray);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertArray(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeArray,\n    opt_message\n  );\n}\n\n/**\n * Throws an error if the first argument isn't a boolean.\n *\n * For more details see `assert`.\n *\n * @param {*} shouldBeBoolean\n * @param {!Array<*>|string=} opt_message The assertion message\n * @return {boolean} The boolean value.\n * @throws {Error} when shouldBeBoolean is not an Boolean\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssertBoolean(shouldBeBoolean, opt_message) {\n  if (mode.isMinified()) {\n    return /** @type {boolean} */ (shouldBeBoolean);\n  }\n  devAssertDceCheck();\n\n  return assertions.assertBoolean(\n    /** @type {!assertions.AssertionFunctionDef} */ (devAssert),\n    shouldBeBoolean,\n    opt_message\n  );\n}\n", "/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */\n\n\n/**\n * This regex consists of 4 matching capture groups and one (non-matching) fallback:\n *\n * - (\\0), catch the null terminator character so it may be replaced by UTF\n *   Replacement Char\n * - ^(-)$, catch a solitary dash char, so that it may be backslash escaped.\n *   This is a separate capture group so that the legal-chars (group 4) doesn't\n *   capture it first, since that group doesn't need to escape its dash.\n * - ([\\x01-\\x1f\\x7f]|^-?[0-9]), catch a UTF control char, or any leading\n *   number (with an optional leading dash). The control or the number (but not\n *   the leading dash) must be hex-escaped,.\n * - ([\\x80-\\uffff0-9a-zA-Z_-]+), catch legal-chars, with the exception of a\n *   solitary dash, which will already have matched in group 1.\n * - [^], finally, a catch-all that allows us to backslash escape the char.\n *\n * Together, this matches everything necessary for CSS.escape.\n */\nvar regex = /(\\0)|^(-)$|([\\x01-\\x1f\\x7f]|^-?[0-9])|([\\x80-\\uffff0-9a-zA-Z_-]+)|[^]/g;\n\nfunction escaper(match, nil, dash, hexEscape, chars) {\n  // Chars is the legal-chars (group 4) capture\n  if (chars) {\n    return chars;\n  }\n  // Nil is the null terminator (group 1) capture\n  if (nil) {\n    return '\\uFFFD';\n  }\n  // Both UTF control chars, and leading numbers (with optional leading dash)\n  // (group 3) must be backslash escaped with a trailing space.  Funnily, the\n  // leading dash must not be escaped, but the number. :shrug:\n  if (hexEscape) {\n    return match.slice(0, -1) + '\\\\' + match.slice(-1).charCodeAt(0).toString(16) + ' '\n  }\n  // Finally, the solitary dash and the catch-all chars require backslash\n  // escaping.\n  return '\\\\' + match;\n}\n\n/**\n * https://drafts.csswg.org/cssom/#serialize-an-identifier\n * @param {string} value\n * @return {string}\n */\nexport function cssEscape(value) {\n  return String(value).replace(regex, escaper);\n}\n", "import * as mode from '#core/mode';\nimport {dict} from '#core/types/object';\nimport {parseJson} from '#core/types/object/json';\nimport {getWin} from '#core/window';\n\nimport {childElementsByTag, matches} from './query';\n\nconst HTML_ESCAPE_CHARS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '`': '&#x60;',\n};\nconst HTML_ESCAPE_REGEX = /(&|<|>|\"|'|`)/g;\n\n/**\n * @typedef {{\n *   bubbles: (boolean|undefined),\n *   cancelable: (boolean|undefined),\n * }}\n */\nexport let CustomEventOptionsDef;\n\n/** @const {!CustomEventOptionsDef} */\nconst DEFAULT_CUSTOM_EVENT_OPTIONS = {bubbles: true, cancelable: true};\n\n/**\n * Waits until the child element is constructed. Once the child is found, the\n * callback is executed.\n * @param {!Element} parent\n * @param {function(!Element):boolean} checkFunc\n * @param {function()} callback\n */\nexport function waitForChild(parent, checkFunc, callback) {\n  if (checkFunc(parent)) {\n    callback();\n    return;\n  }\n  const win = getWin(parent);\n  if (mode.isEsm() || win.MutationObserver) {\n    const observer = new win.MutationObserver(() => {\n      if (checkFunc(parent)) {\n        observer.disconnect();\n        callback();\n      }\n    });\n    observer.observe(parent, {childList: true});\n  } else {\n    const interval = win.setInterval(() => {\n      if (checkFunc(parent)) {\n        win.clearInterval(interval);\n        callback();\n      }\n    }, /* milliseconds */ 5);\n  }\n}\n\n/**\n * Waits until the child element is constructed. Once the child is found, the\n * promise is resolved.\n * @param {!Element} parent\n * @param {function(!Element):boolean} checkFunc\n * @return {!Promise}\n */\nexport function waitForChildPromise(parent, checkFunc) {\n  return new Promise((resolve) => {\n    waitForChild(parent, checkFunc, resolve);\n  });\n}\n\n/**\n * Waits for document's body to be available and ready.\n * @param {!Document} doc\n * @param {function()} callback\n */\nexport function waitForBodyOpen(doc, callback) {\n  waitForChild(doc.documentElement, () => !!doc.body, callback);\n}\n\n/**\n * Waits for document's body to be available.\n * @param {!Document} doc\n * @return {!Promise}\n */\nexport function waitForBodyOpenPromise(doc) {\n  return new Promise((resolve) => waitForBodyOpen(doc, resolve));\n}\n\n/**\n * Removes the element.\n * @param {!Element} element\n */\nexport function removeElement(element) {\n  element.parentElement?.removeChild(element);\n}\n\n/**\n * Removes all child nodes of the specified element.\n * @param {!Element|!DocumentFragment} parent\n */\nexport function removeChildren(parent) {\n  while (parent.firstChild) {\n    parent.removeChild(parent.firstChild);\n  }\n}\n\n/**\n * Copies all children nodes of element \"from\" to element \"to\". Child nodes\n * are deeply cloned. Notice, that this method should be used with care and\n * preferably on smaller subtrees.\n * @param {!Element} from\n * @param {!Element|!DocumentFragment} to\n */\nexport function copyChildren(from, to) {\n  const frag = to.ownerDocument.createDocumentFragment();\n  for (let n = from.firstChild; n; n = n.nextSibling) {\n    frag.appendChild(n.cloneNode(true));\n  }\n  to.appendChild(frag);\n}\n\n/**\n * Insert the element in the root after the element named after or\n * if that is null at the beginning.\n * @param {!Element|!ShadowRoot} root\n * @param {!Element} element\n * @param {?Node=} after\n */\nexport function insertAfterOrAtStart(root, element, after = null) {\n  if (!after) {\n    insertAtStart(root, element);\n    return;\n  }\n  const before = after.nextSibling;\n  root.insertBefore(element, before);\n}\n\n/**\n * Insert the element in the root after the element named after or\n * if that is null at the beginning.\n * @param {!Element|!ShadowRoot} root\n * @param {!Element} element\n */\nexport function insertAtStart(root, element) {\n  root.insertBefore(element, root.firstChild);\n}\n\n/**\n * Add attributes to an element.\n * @param {!Element} element\n * @param {!JsonObject<string, string>} attributes\n * @return {!Element} created element\n */\nexport function addAttributesToElement(element, attributes) {\n  for (const attr in attributes) {\n    element.setAttribute(attr, attributes[attr]);\n  }\n  return element;\n}\n\n/**\n * Create a new element on document with specified tagName and attributes.\n * @param {!Document} doc\n * @param {string} tagName\n * @param {!JsonObject<string, string>} attributes\n * @return {!Element} created element\n */\nexport function createElementWithAttributes(doc, tagName, attributes) {\n  const element = doc.createElement(tagName);\n  return addAttributesToElement(element, attributes);\n}\n\n/**\n * Returns true if node is connected (attached).\n * @param {!Node} node\n * @return {boolean}\n * @see https://dom.spec.whatwg.org/#connected\n */\nexport function isConnectedNode(node) {\n  const connected = node.isConnected;\n  if (connected !== undefined) {\n    return connected;\n  }\n\n  // \"An element is connected if its shadow-including root is a document.\"\n  let n = node;\n  do {\n    n = rootNodeFor(n);\n    if (n.host) {\n      n = n.host;\n    } else {\n      break;\n    }\n  } while (true);\n  return n.nodeType === Node.DOCUMENT_NODE;\n}\n\n/**\n * Returns the root for a given node. Does not cross shadow DOM boundary.\n * @param {!Node} node\n * @return {!Node}\n */\nexport function rootNodeFor(node) {\n  if (Node.prototype.getRootNode) {\n    // Type checker says `getRootNode` may return null.\n    return node.getRootNode() || node;\n  }\n  let n;\n  // Check isShadowRoot() is only needed for the polyfill case.\n  for (\n    n = node;\n    !!n.parentNode && !isShadowRoot(/** @type {HTMLElement} */ (n));\n    n = n.parentNode\n  ) {}\n  return n;\n}\n\n/**\n * Determines if value is actually a `ShadowRoot` node.\n * @param {?HTMLElement} value\n * @return {boolean}\n */\nexport function isShadowRoot(value) {\n  if (!value) {\n    return false;\n  }\n  // Node.nodeType == DOCUMENT_FRAGMENT to speed up the tests. Unfortunately,\n  // nodeType of DOCUMENT_FRAGMENT is used currently for ShadowRoot nodes.\n  if (value.tagName == 'I-AMPHTML-SHADOW-ROOT') {\n    return true;\n  }\n  return (\n    value.nodeType == /* DOCUMENT_FRAGMENT */ 11 &&\n    Object.prototype.toString.call(value) === '[object ShadowRoot]'\n  );\n}\n\n/**\n * Returns element data-param- attributes as url parameters key-value pairs.\n * e.g. data-param-some-attr=value -> {someAttr: value}.\n * @param {!HTMLElement} element\n * @param {function(string):string=} opt_computeParamNameFunc to compute the\n *    parameter name, get passed the camel-case parameter name.\n * @param {!RegExp=} opt_paramPattern Regex pattern to match data attributes.\n * @return {!JsonObject}\n */\nexport function getDataParamsFromAttributes(\n  element,\n  opt_computeParamNameFunc,\n  opt_paramPattern\n) {\n  const computeParamNameFunc = opt_computeParamNameFunc || ((key) => key);\n  const {dataset} = element;\n  const params = dict();\n  const paramPattern = opt_paramPattern || /^param(.+)/;\n  for (const key in dataset) {\n    const matches = key.match(paramPattern);\n    if (matches) {\n      const param = matches[1][0].toLowerCase() + matches[1].substr(1);\n      params[computeParamNameFunc(param)] = dataset[key];\n    }\n  }\n  return params;\n}\n\n/**\n * Whether the element have a next node in the document order.\n * This means either:\n *  a. The element itself has a nextSibling.\n *  b. Any of the element ancestors has a nextSibling.\n * @param {!Element} element\n * @param {?Node} opt_stopNode\n * @return {boolean}\n */\nexport function hasNextNodeInDocumentOrder(element, opt_stopNode) {\n  let currentElement = element;\n  do {\n    if (currentElement.nextSibling) {\n      return true;\n    }\n  } while (\n    (currentElement = currentElement.parentNode) &&\n    currentElement != opt_stopNode\n  );\n  return false;\n}\n\n/**\n * Returns a clone of the content of a template element.\n *\n * Polyfill to replace .content access for browsers that do not support\n * HTMLTemplateElements natively.\n *\n * @param {!HTMLTemplateElement|!Element} template\n * @return {!DocumentFragment}\n */\nexport function templateContentClone(template) {\n  if ('content' in template) {\n    return template.content.cloneNode(true);\n  } else {\n    const content = template.ownerDocument.createDocumentFragment();\n    copyChildren(template, content);\n    return content;\n  }\n}\n\n/**\n * Iterate over an array-like.\n * Test cases: https://jsbench.github.io/#f638cacc866a1b2d6e517e6cfa900d6b\n * @param {!IArrayLike<T>} iterable\n * @param {function(T, number)} cb\n * @template T\n */\nexport function iterateCursor(iterable, cb) {\n  const {length} = iterable;\n  for (let i = 0; i < length; i++) {\n    cb(iterable[i], i);\n  }\n}\n\n/**\n * Whether the element is a script tag with application/json type.\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isJsonScriptTag(element) {\n  return (\n    element.tagName == 'SCRIPT' &&\n    element.getAttribute('type')?.toUpperCase() == 'APPLICATION/JSON'\n  );\n}\n\n/**\n * Whether the element is a script tag with application/json type.\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isJsonLdScriptTag(element) {\n  return (\n    element.tagName == 'SCRIPT' &&\n    element.getAttribute('type')?.toUpperCase() == 'APPLICATION/LD+JSON'\n  );\n}\n\n/**\n * Whether the page's direction is right to left or not.\n * @param {!Document} doc\n * @return {boolean}\n */\nexport function isRTL(doc) {\n  const dir =\n    doc.body.getAttribute('dir') ||\n    doc.documentElement.getAttribute('dir') ||\n    'ltr';\n  return dir == 'rtl';\n}\n\n/**\n * Escapes `<`, `>` and other HTML charcaters with their escaped forms.\n * @param {string} text\n * @return {string}\n */\nexport function escapeHtml(text) {\n  if (!text) {\n    return text;\n  }\n  return text.replace(HTML_ESCAPE_REGEX, escapeHtmlChar);\n}\n\n/**\n * @param {string} c\n * @return {string}\n */\nfunction escapeHtmlChar(c) {\n  return HTML_ESCAPE_CHARS[c];\n}\n\n/**\n * Tries to focus on the given element; fails silently if browser throws an\n * exception.\n * @param {!Element} element\n */\nexport function tryFocus(element) {\n  try {\n    element./*OK*/ focus();\n  } catch (e) {\n    // IE <= 7 may throw exceptions when focusing on hidden items.\n  }\n}\n\n/**\n * Whether the given window is in an iframe or not.\n * @param {!Window} win\n * @return {boolean}\n */\nexport function isIframed(win) {\n  return win.parent && win.parent != win;\n}\n\n/**\n * Returns true if node is not disabled.\n *\n * IE8 can return false positives, see {@link matches}.\n * @param {!HTMLInputElement} element\n * @return {boolean}\n * @see https://www.w3.org/TR/html5/forms.html#concept-fe-disabled\n */\nexport function isEnabled(element) {\n  return !(element.disabled || matches(element, ':disabled'));\n}\n\n/**\n * A sorting comparator that sorts elements in DOM tree order.\n * A first sibling is sorted to be before its nextSibling.\n * A parent node is sorted to be before a child.\n * See https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {!Element} element1\n * @param {!Element} element2\n * @return {number}\n */\nexport function domOrderComparator(element1, element2) {\n  if (element1 === element2) {\n    return 0;\n  }\n\n  const pos = element1.compareDocumentPosition(element2);\n  const precedingOrContains =\n    Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS;\n\n  // if fe2 is preceding or contains fe1 then, fe1 is after fe2\n  if (pos & precedingOrContains) {\n    return 1;\n  }\n\n  // if fe2 is following or contained by fe1, then fe1 is before fe2\n  return -1;\n}\n\n/**\n * Like `Element.prototype.toggleAttribute`. This either toggles an attribute\n * on by adding an attribute with an empty value, or toggles it off by removing\n * the attribute. This does not mutate the element if the new state matches\n * the existing state.\n * @param {!Element} element An element to toggle the attribute for.\n * @param {string} name The name of the attribute.\n * @param {boolean=} forced Whether the attribute should be forced on/off. If\n *    not specified, it will be toggled from the current state.\n * @return {boolean} Whether or not the element now has the attribute.\n */\nexport function toggleAttribute(element, name, forced) {\n  const hasAttribute = element.hasAttribute(name);\n  const enabled = forced !== undefined ? forced : !hasAttribute;\n\n  if (enabled !== hasAttribute) {\n    if (enabled) {\n      element.setAttribute(name, '');\n    } else {\n      element.removeAttribute(name);\n    }\n  }\n\n  return enabled;\n}\n\n/**\n * Parses a string as a boolean value using the expanded rules for DOM boolean\n * attributes:\n * - a `null` or `undefined` returns `null`;\n * - an empty string returns `true`;\n * - a \"false\" string returns `false`;\n * - otherwise, `true` is returned.\n *\n * @param {?string|undefined} s\n * @return {boolean|undefined}\n */\nexport function parseBooleanAttribute(s) {\n  return s == null ? undefined : s !== 'false';\n}\n\n/**\n * @param {!Window} win\n * @return {number} The width of the vertical scrollbar, in pixels.\n */\nexport function getVerticalScrollbarWidth(win) {\n  const {documentElement} = win.document;\n  const windowWidth = win./*OK*/ innerWidth;\n  const documentWidth = documentElement./*OK*/ clientWidth;\n  return windowWidth - documentWidth;\n}\n\n/**\n * Dispatches a custom event.\n *\n * @param {!Node} node\n * @param {string} name\n * @param {!Object=} opt_data Event data.\n * @param {!CustomEventOptionsDef=} opt_options\n */\nexport function dispatchCustomEvent(node, name, opt_data, opt_options) {\n  const data = opt_data || {};\n  // Constructors of events need to come from the correct window. Sigh.\n  const event = node.ownerDocument.createEvent('Event');\n\n  // Technically .data is not a property of Event.\n  event.data = data;\n\n  const {bubbles, cancelable} = opt_options || DEFAULT_CUSTOM_EVENT_OPTIONS;\n  event.initEvent(name, bubbles, cancelable);\n  node.dispatchEvent(event);\n}\n\n/**\n * Ensures the child is contained by the parent, but not the parent itself.\n *\n * @param {!Node} parent\n * @param {!Node} child\n * @return {boolean}\n */\nexport function containsNotSelf(parent, child) {\n  return child !== parent && parent.contains(child);\n}\n\n/**\n * Helper method to get the json config from an element <script> tag\n * @param {!Element} element\n * @return {?JsonObject}\n * @throws {!Error} If element does not have exactly one <script> child\n * with type=\"application/json\", or if the <script> contents are not valid JSON.\n */\nexport function getChildJsonConfig(element) {\n  const scripts = childElementsByTag(element, 'script');\n  const {length} = scripts;\n  if (length !== 1) {\n    throw new Error(`Found ${length} <script> children. Expected 1.`);\n  }\n\n  const script = scripts[0];\n  if (!isJsonScriptTag(script)) {\n    throw new Error('<script> child must have type=\"application/json\"');\n  }\n\n  try {\n    return parseJson(script.textContent);\n  } catch {\n    throw new Error('Failed to parse <script> contents. Is it valid JSON?');\n  }\n}\n", "/**\n * @fileoverview Implements element layout. See https://goo.gl/9avXuT for\n * details.\n */\n\nimport {userAssert} from '#core/assert';\nimport {isFiniteNumber} from '#core/types';\n\n/**\n * @enum {string}\n */\nexport const Layout = {\n  NODISPLAY: 'nodisplay',\n  FIXED: 'fixed',\n  FIXED_HEIGHT: 'fixed-height',\n  RESPONSIVE: 'responsive',\n  CONTAINER: 'container',\n  FILL: 'fill',\n  FLEX_ITEM: 'flex-item',\n  FLUID: 'fluid',\n  INTRINSIC: 'intrinsic',\n};\n\n/**\n * Layout priorities to use with BaseElement#getLayoutPriority() and\n * BaseElement#updateLayoutPriority().\n * @enum {number}\n */\nexport const LayoutPriority = {\n  CONTENT: 0,\n  METADATA: 1,\n  ADS: 2,\n  BACKGROUND: 3,\n};\n\n/**\n * CSS Length type. E.g. \"1px\" or \"20vh\".\n * @typedef {string}\n */\nexport let LengthDef;\n\n/**\n * @typedef {{\n *   width: string,\n *   height: string\n * }}\n */\nexport let DimensionsDef;\n\n/**\n * Elements that the progress can be shown for. This set has to be externalized\n * since the element's implementation may not be downloaded yet.\n * This list does not include video players which are found via regex later.\n * @enum {boolean}\n * @private  Visible for testing only!\n */\nexport const LOADING_ELEMENTS_ = {\n  'AMP-AD': true,\n  'AMP-ANIM': true,\n  'AMP-EMBED': true,\n  'AMP-FACEBOOK': true,\n  'AMP-FACEBOOK-COMMENTS': true,\n  'AMP-FACEBOOK-PAGE': true,\n  'AMP-GOOGLE-DOCUMENT-EMBED': true,\n  'AMP-IFRAME': true,\n  'AMP-IMG': true,\n  'AMP-INSTAGRAM': true,\n  'AMP-LIST': true,\n  'AMP-PINTEREST': true,\n  'AMP-PLAYBUZZ': true,\n  'AMP-RENDER': true,\n  'AMP-TIKTOK': true,\n  'AMP-TWITTER': true,\n};\n/**\n * All video player components must either have a) \"video\" or b) \"player\" in\n * their name. A few components don't follow this convention for historical\n * reasons, so they are listed individually.\n * @private @const {!RegExp}\n */\nconst videoPlayerTagNameRe =\n  /^amp\\-(video|.+player)|AMP-BRIGHTCOVE|AMP-DAILYMOTION|AMP-YOUTUBE|AMP-VIMEO|AMP-IMA-VIDEO/i;\n\n/**\n * @param {string} s\n * @return {!Layout|undefined} Returns undefined in case of failure to parse\n *   the layout string.\n */\nexport function parseLayout(s) {\n  for (const k in Layout) {\n    if (Layout[k] == s) {\n      return Layout[k];\n    }\n  }\n  return undefined;\n}\n\n/**\n * @param {!Layout} layout\n * @return {string}\n */\nexport function getLayoutClass(layout) {\n  return 'i-amphtml-layout-' + layout;\n}\n\n/**\n * Whether an element with this layout inherently defines the size.\n * @param {!Layout} layout\n * @return {boolean}\n */\nexport function isLayoutSizeDefined(layout) {\n  return (\n    layout == Layout.FIXED ||\n    layout == Layout.FIXED_HEIGHT ||\n    layout == Layout.RESPONSIVE ||\n    layout == Layout.FILL ||\n    layout == Layout.FLEX_ITEM ||\n    layout == Layout.FLUID ||\n    layout == Layout.INTRINSIC\n  );\n}\n\n/**\n * Whether an element with this layout has a fixed dimension.\n * @param {!Layout} layout\n * @return {boolean}\n */\nexport function isLayoutSizeFixed(layout) {\n  return layout == Layout.FIXED || layout == Layout.FIXED_HEIGHT;\n}\n\n/**\n * Parses the CSS length value. If no units specified, the assumed value is\n * \"px\". Returns undefined in case of parsing error.\n * @param {string|undefined|null} s\n * @return {!LengthDef|undefined}\n */\nexport function parseLength(s) {\n  if (typeof s == 'number') {\n    return s + 'px';\n  }\n  if (!s) {\n    return undefined;\n  }\n  if (!/^\\d+(\\.\\d+)?(px|em|rem|vh|vw|vmin|vmax|cm|mm|q|in|pc|pt)?$/.test(s)) {\n    return undefined;\n  }\n  if (/^\\d+(\\.\\d+)?$/.test(s)) {\n    return s + 'px';\n  }\n  return s;\n}\n\n/**\n * Asserts that the supplied value is a non-percent CSS Length value.\n * @param {!LengthDef|string|null|undefined} length\n * @return {!LengthDef}\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertLength(length) {\n  userAssert(\n    /^\\d+(\\.\\d+)?(px|em|rem|vh|vw|vmin|vmax|cm|mm|q|in|pc|pt)$/.test(length),\n    'Invalid length value: %s',\n    length\n  );\n  return /** @type {!LengthDef} */ (length);\n}\n\n/**\n * Asserts that the supplied value is a CSS Length value\n * (including percent unit).\n * @param {!LengthDef|string} length\n * @return {!LengthDef}\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function assertLengthOrPercent(length) {\n  userAssert(\n    /^\\d+(\\.\\d+)?(px|em|rem|vh|vw|vmin|vmax|%)$/.test(length),\n    'Invalid length or percent value: %s',\n    length\n  );\n  return length;\n}\n\n/**\n * Returns units from the CSS length value.\n * @param {!LengthDef|string|null|undefined} length\n * @return {string}\n */\nexport function getLengthUnits(length) {\n  assertLength(length);\n  const m = userAssert(\n    /[a-z]+/i.exec(length),\n    'Failed to read units from %s',\n    length\n  );\n  return m[0];\n}\n\n/**\n * Returns the numeric value of a CSS length value.\n * @param {!LengthDef|string|null|undefined|number} length\n * @return {number|undefined}\n */\nexport function getLengthNumeral(length) {\n  const res = parseFloat(length);\n  return isFiniteNumber(res) ? res : undefined;\n}\n\n/**\n * Whether the loading can be shown for the specified element. This set has\n * to be externalized since the element's implementation may not be\n * downloaded yet.\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isLoadingAllowed(element) {\n  const tagName = element.tagName.toUpperCase();\n  return LOADING_ELEMENTS_[tagName] || isIframeVideoPlayerComponent(tagName);\n}\n\n/**\n * All video player components must either have a) \"video\" or b) \"player\" in\n * their name. A few components don't follow this convention for historical\n * reasons, so they're present in the LOADING_ELEMENTS_ allowlist.\n * @param {string} tagName\n * @return {boolean}\n */\nexport function isIframeVideoPlayerComponent(tagName) {\n  if (tagName == 'AMP-VIDEO') {\n    return false;\n  }\n  return videoPlayerTagNameRe.test(tagName);\n}\n\n/**\n * Configures the supplied element to have a \"fill content\" layout. The\n * exact interpretation of \"fill content\" depends on the element's layout.\n *\n * If `opt_replacedContent` is specified, it indicates whether the \"replaced\n * content\" styling should be applied. Replaced content is not allowed to\n * have its own paddings or border.\n *\n * @param {!Element} element\n * @param {boolean=} opt_replacedContent\n */\nexport function applyFillContent(element, opt_replacedContent) {\n  element.classList.add('i-amphtml-fill-content');\n  if (opt_replacedContent) {\n    element.classList.add('i-amphtml-replaced-content');\n  }\n}\n", "let resolved;\n\n/**\n * Returns a cached resolved promise.\n * Babel converts direct calls to Promise.resolve() (with no arguments) into\n * calls to this.\n *\n * @return {!Promise<undefined>}\n */\nexport function resolvedPromise() {\n  if (resolved) {\n    return resolved;\n  }\n\n  // It's important that we call with `undefined` here, to prevent a transform\n  // recursion. If we didn't pass an arg, then the transformer would replace\n  // this callsite with a call to `resolvedPromise()`.\n  resolved = Promise.resolve(undefined);\n  return resolved;\n}\n\n/**\n * Returns a Deferred struct, which holds a pending promise and its associated\n * resolve and reject functions.\n *\n * This is preferred instead of creating a Promise instance to extract the\n * resolve/reject functions yourself:\n *\n * ```\n * // Avoid doing\n * let resolve;\n * const promise = new Promise(res => {\n *   resolve = res;\n * });\n *\n * // Good\n * const deferred = new Deferred();\n * const { promise, resolve } = deferred;\n * ```\n *\n * @template T\n */\nexport class Deferred {\n  /** Constructor. */\n  constructor() {\n    /** @const {!Promise<T>} */\n    this.promise = new /*OK*/ Promise((res, rej) => {\n      /** @const {function(T=)} */\n      this.resolve = res;\n      /** @const {function(*=)} */\n      this.reject = rej;\n    });\n  }\n}\n\n/**\n * Creates a promise resolved to the return value of fn.\n * If fn sync throws, it will cause the promise to reject.\n *\n * @param {function():T} fn\n * @return {!Promise<T>}\n * @template T\n */\nexport function tryResolve(fn) {\n  return new Promise((resolve) => {\n    resolve(fn());\n  });\n}\n\n/**\n * Resolves with the result of the last promise added.\n * @implements {IThenable}\n */\nexport class LastAddedResolver {\n  /**\n   * @param {!Array<!IThenable>=} opt_promises\n   */\n  constructor(opt_promises) {\n    /** @private @const {!Deferred} */\n    this.deferred_ = new Deferred();\n\n    /** @private */\n    this.count_ = 0;\n\n    if (opt_promises) {\n      for (const promise of opt_promises) {\n        this.add(promise);\n      }\n    }\n  }\n\n  /**\n   * Add a promise to possibly be resolved.\n   * @param {!IThenable} promise\n   * @return {!Promise}\n   */\n  add(promise) {\n    const countAtAdd = ++this.count_;\n    promise.then(\n      (result) => {\n        if (this.count_ === countAtAdd) {\n          this.deferred_.resolve(result);\n        }\n      },\n      (error) => {\n        // Don't follow behavior of Promise.all and Promise.race error so that\n        // this will only reject when most recently added promise fails.\n        if (this.count_ === countAtAdd) {\n          this.deferred_.reject(error);\n        }\n      }\n    );\n    return this.deferred_.promise;\n  }\n\n  /** @override */\n  then(opt_resolve, opt_reject) {\n    return this.deferred_.promise.then(opt_resolve, opt_reject);\n  }\n}\n", "/**\n * Some exceptions (DOMException, namely) have read-only message.\n * @param {!Error} error\n * @return {!Error}\n */\nexport function duplicateErrorIfNecessary(error) {\n  const messageProperty = Object.getOwnPropertyDescriptor(error, 'message');\n  if (messageProperty?.writable) {\n    return error;\n  }\n\n  const {message, stack} = error;\n  const e = new Error(message);\n  // Copy all the extraneous things we attach.\n  for (const prop in error) {\n    e[prop] = error[prop];\n  }\n  // Ensure these are copied.\n  e.stack = stack;\n  return e;\n}\n\n/**\n * Creates an error object.\n * @param {...*} var_args\n * @return {!Error}\n */\nexport function createError(var_args) {\n  let error = null;\n  let message = '';\n  for (const arg of arguments) {\n    if (arg instanceof Error && !error) {\n      error = duplicateErrorIfNecessary(arg);\n    } else {\n      if (message) {\n        message += ' ';\n      }\n      message += arg;\n    }\n  }\n\n  if (!error) {\n    error = new Error(message);\n  } else if (message) {\n    error.message = message + ': ' + error.message;\n  }\n  return error;\n}\n\n/**\n * Reports an error, if the global error reporting function is defined.\n * @param {!Error} error\n */\nfunction maybeReportError(error) {\n  self.__AMP_REPORT_ERROR?.(error);\n}\n\n/**\n * Constructs and throws an error without terminating the current context. This\n * preserves whether the original error designation is a user error or a dev\n * error.\n * @param {...*} var_args\n */\nexport function rethrowAsync(var_args) {\n  const error = createError.apply(null, arguments);\n  setTimeout(() => {\n    // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n    // It may not exist for Bento components without the runtime.\n    maybeReportError(error);\n    throw error;\n  });\n}\n\n/**\n * Executes the provided callback in a try/catch and rethrows any errors\n * asynchronously.\n *\n * @param {function(S):T} callback\n * @param {S} args\n * @return {T}\n * @template T\n * @template S\n */\nexport function tryCallback(callback, ...args) {\n  try {\n    return callback.apply(null, args);\n  } catch (e) {\n    rethrowAsync(e);\n  }\n}\n\n/**\n * Creates an error object with its expected property set to true.\n * @param {...*} var_args\n * @return {!Error}\n */\nexport function createExpectedError(var_args) {\n  const error = createError.apply(null, arguments);\n  error.expected = true;\n  return error;\n}\n\n/**\n * Reports an error message.\n * @param {string} tag\n * @param {...*} args\n */\nexport function devError(tag, ...args) {\n  const error = createError.apply(null, args);\n  // TODO(rcebulko): Determine if/how this Error#name property is used.\n  error.name = tag || error.name;\n  maybeReportError(error);\n}\n\n/**\n * Reports an error message and marks with an expected property. If the\n * logging is disabled, the error is rethrown asynchronously.\n * @param {string} unusedTag\n * @param {...*} args\n */\nexport function devExpectedError(unusedTag, ...args) {\n  maybeReportError(createExpectedError.apply(null, args));\n}\n", "// Note: loaded by 3p system. Cannot rely on babel polyfills.\nimport {devAssert} from '#core/assert';\nimport {devError} from '#core/error';\nimport {map} from '#core/types/object';\n\n/** @type {Object<string, string>} */\nlet propertyNameCache;\n\n/** @const {!Array<string>} */\nconst vendorPrefixes = ['Webkit', 'webkit', 'Moz', 'moz', 'ms', 'O', 'o'];\n\nconst DISPLAY_STYLE_MESSAGE =\n  '`display` style detected. You must use toggle instead.';\n\nconst EMPTY_CSS_DECLARATION = /** @type {!CSSStyleDeclaration} */ ({\n  'getPropertyPriority': () => '',\n  'getPropertyValue': () => '',\n});\n\n/**\n * @param {string} camelCase camel cased string\n * @return {string} title cased string\n */\nexport function camelCaseToTitleCase(camelCase) {\n  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n}\n\n/**\n  Checks the style if a prefixed version of a property exists and returns\n * it or returns an empty string.\n * @private\n * @param {!Object} style\n * @param {string} titleCase the title case version of a css property name\n * @return {string} the prefixed property name or null.\n */\nfunction getVendorJsPropertyName_(style, titleCase) {\n  for (let i = 0; i < vendorPrefixes.length; i++) {\n    const propertyName = vendorPrefixes[i] + titleCase;\n    if (style[propertyName] !== undefined) {\n      return propertyName;\n    }\n  }\n  return '';\n}\n\n/**\n * Returns the possibly prefixed JavaScript property name of a style property\n * (ex. WebkitTransitionDuration) given a camelCase'd version of the property\n * (ex. transitionDuration).\n * @param {!Object} style\n * @param {string} camelCase the camel cased version of a css property name\n * @param {boolean=} opt_bypassCache bypass the memoized cache of property\n *   mapping\n * @return {string}\n */\nexport function getVendorJsPropertyName(style, camelCase, opt_bypassCache) {\n  if (isVar(camelCase)) {\n    // CSS vars are returned as is.\n    return camelCase;\n  }\n  if (!propertyNameCache) {\n    propertyNameCache = map();\n  }\n  let propertyName = propertyNameCache[camelCase];\n  if (!propertyName || opt_bypassCache) {\n    propertyName = camelCase;\n    if (style[camelCase] === undefined) {\n      const titleCase = camelCaseToTitleCase(camelCase);\n      const prefixedPropertyName = getVendorJsPropertyName_(style, titleCase);\n\n      if (style[prefixedPropertyName] !== undefined) {\n        propertyName = prefixedPropertyName;\n      }\n    }\n    if (!opt_bypassCache) {\n      propertyNameCache[camelCase] = propertyName;\n    }\n  }\n  return propertyName;\n}\n\n/**\n * Sets the CSS styles of the specified element with !important. The styles\n * are specified as a map from CSS property names to their values.\n * @param {!Element} element\n * @param {!Object<string, *>} styles\n */\nexport function setImportantStyles(element, styles) {\n  const {style} = element;\n  for (const k in styles) {\n    style.setProperty(\n      getVendorJsPropertyName(style, k),\n      String(styles[k]),\n      'important'\n    );\n  }\n}\n\n/**\n * Sets the CSS style of the specified element with optional units, e.g. \"px\".\n * @param {?Element} element\n * @param {string} property\n * @param {*} value\n * @param {string=} opt_units\n * @param {boolean=} opt_bypassCache\n */\nexport function setStyle(element, property, value, opt_units, opt_bypassCache) {\n  const propertyName = getVendorJsPropertyName(\n    element.style,\n    property,\n    opt_bypassCache\n  );\n  if (!propertyName) {\n    return;\n  }\n  const styleValue = /** @type {string} */ (\n    opt_units ? value + opt_units : value\n  );\n  if (isVar(propertyName)) {\n    element.style.setProperty(propertyName, styleValue);\n  } else {\n    element.style[propertyName] = styleValue;\n  }\n}\n\n/**\n * Returns the value of the CSS style of the specified element.\n * @param {!Element} element\n * @param {string} property\n * @param {boolean=} opt_bypassCache\n * @return {*}\n */\nexport function getStyle(element, property, opt_bypassCache) {\n  const propertyName = getVendorJsPropertyName(\n    element.style,\n    property,\n    opt_bypassCache\n  );\n  if (!propertyName) {\n    return undefined;\n  }\n  if (isVar(propertyName)) {\n    return element.style.getPropertyValue(propertyName);\n  }\n  return element.style[propertyName];\n}\n\n/**\n * Sets the CSS styles of the specified element. The styles\n * a specified as a map from CSS property names to their values.\n * @param {!Element} element\n * @param {!Object<string, *>} styles\n */\nexport function setStyles(element, styles) {\n  for (const k in styles) {\n    setStyle(element, k, styles[k]);\n  }\n}\n\n/**\n * Sets the initial display style of an element. This is a last resort. If you\n * can set the initial display using CSS, YOU MUST.\n * DO NOT USE THIS TO ARBITRARILY SET THE DISPLAY STYLE AFTER INITIAL SETUP.\n *\n * @param {!Element} el\n * @param {string} value\n */\nexport function setInitialDisplay(el, value) {\n  const {style} = el;\n  devAssert(\n    value !== '' && value !== 'none',\n    'Initial display value must not be \"none\". Use toggle instead.'\n  );\n  devAssert(\n    !style['display'],\n    'setInitialDisplay MUST NOT be used for ' +\n      'resetting the display style. If you are looking for display:none ' +\n      'toggling, use toggle instead.'\n  );\n  style['display'] = value;\n}\n\n/**\n * Shows or hides the specified element.\n * @param {!Element} element\n * @param {boolean=} opt_display\n */\nexport function toggle(element, opt_display) {\n  if (opt_display === undefined) {\n    opt_display = element.hasAttribute('hidden');\n  }\n  if (opt_display) {\n    element.removeAttribute('hidden');\n  } else {\n    element.setAttribute('hidden', '');\n  }\n}\n\n/**\n * Returns a pixel value.\n * @param {number} value\n * @return {string}\n */\nexport function px(value) {\n  return `${value}px`;\n}\n\n/**\n * Returns a degree value.\n * @param {number} value\n * @return {string}\n */\nexport function deg(value) {\n  return `${value}deg`;\n}\n\n/**\n * Coerces a number into a string with units.\n * @param {number|string} value\n * @param {function(number):string} fn\n * @return {string}\n */\nfunction units(value, fn) {\n  return typeof value == 'number' ? fn(value) : value;\n}\n\n/**\n * Returns a \"translateX\" for CSS \"transform\" property.\n * @param {number|string} value\n * @return {string}\n */\nexport function translateX(value) {\n  return `translateX(${units(value, px)})`;\n}\n\n/**\n * Returns a \"translateX\" for CSS \"transform\" property.\n * @param {number|string} x\n * @param {(number|string|null)=} opt_y\n * @return {string}\n */\nexport function translate(x, opt_y) {\n  return opt_y === undefined || opt_y === null\n    ? `translate(${units(x, px)})`\n    : `translate(${units(x, px)}, ${units(opt_y, px)})`;\n}\n\n/**\n * Returns a \"scale\" for CSS \"transform\" property.\n * @param {number|string} value\n * @return {string}\n */\nexport function scale(value) {\n  return `scale(${value})`;\n}\n\n/**\n * Returns a \"rotate\" for CSS \"transform\" property.\n * @param {number|string} value\n * @return {string}\n */\nexport function rotate(value) {\n  return `rotate(${units(value, deg)})`;\n}\n\n/**\n * Remove alpha value from a rgba color value.\n * Return the new color property with alpha equals if has the alpha value.\n * Caller needs to make sure the input color value is a valid rgba/rgb value\n * @param {string} rgbaColor\n * @return {string}\n */\nexport function removeAlphaFromColor(rgbaColor) {\n  return rgbaColor.replace(\n    /\\(([^,]+),([^,]+),([^,)]+),[^)]+\\)/g,\n    '($1,$2,$3, 1)'\n  );\n}\n\n/**\n * Gets the computed style of the element. The helper is necessary to enforce\n * the possible `null` value returned by a buggy Firefox.\n *\n * @param {!Window} win\n * @param {!Element} el\n * @return {!CSSStyleDeclaration}\n */\nexport function computedStyle(win, el) {\n  const style = /** @type {?CSSStyleDeclaration} */ (win.getComputedStyle(el));\n  return style || EMPTY_CSS_DECLARATION;\n}\n\n/**\n * Resets styles that were set dynamically (i.e. inline)\n * @param {!Element} element\n * @param {!Array<string>} properties\n */\nexport function resetStyles(element, properties) {\n  for (let i = 0; i < properties.length; i++) {\n    setStyle(element, properties[i], null);\n  }\n}\n\n/**\n * Propagates the object-fit/position element attributes as styles.\n * @param {!Element} fromEl ie: amp-img\n * @param {!Element} toEl ie: the img within amp-img\n */\nexport function propagateObjectFitStyles(fromEl, toEl) {\n  if (fromEl.hasAttribute('object-fit')) {\n    setStyle(toEl, 'object-fit', fromEl.getAttribute('object-fit'));\n  }\n\n  if (fromEl.hasAttribute('object-position')) {\n    setStyle(toEl, 'object-position', fromEl.getAttribute('object-position'));\n  }\n}\n\n/**\n * @param {string} property\n * @return {boolean}\n */\nfunction isVar(property) {\n  return property.startsWith('--');\n}\n\n/**\n * Asserts that the style is not the `display` style.\n * This is the only possible way to pass a dynamic style to setStyle.\n *\n * If you wish to set `display`, use the `toggle` helper instead. This is so\n * changes to display can trigger necessary updates. See #17475.\n *\n * @param {string} style\n * @return {string}\n */\nexport function assertNotDisplay(style) {\n  // TODO(rcebulko): This calls itself an assert, but doesn't throw an error.\n  // Should it throw sync? If so, this/below can reduce to\n  // `return devAssert(style == 'display', DISPLAY_STYLE_MESSAGE);`\n  if (style === 'display') {\n    devError('STYLE', DISPLAY_STYLE_MESSAGE);\n  }\n  return style;\n}\n\n/**\n * Asserts that the styles does not contain the `display` style.\n * This is the only possible way to pass a dynamic styles object to setStyles\n * and setImportantStyles.\n *\n * If you wish to set `display`, use the `toggle` helper instead. This is so\n * changes to display can trigger necessary updates. See #17475.\n *\n * @param {!Object<string, *>} styles\n * @return {!Object<string, *>}\n */\nexport function assertDoesNotContainDisplay(styles) {\n  if ('display' in styles) {\n    devError('STYLE', DISPLAY_STYLE_MESSAGE);\n  }\n  return styles;\n}\n", "import {devAssertElement} from '#core/assert';\nimport {tryResolve} from '#core/data-structures/promise';\nimport {setStyles} from '#core/dom/style';\nimport {devExpectedError} from '#core/error';\n\n/**\n * @param {!Window} win\n * @return {!Promise<boolean>}\n */\nexport function detectIsAutoplaySupported(win) {\n  // To detect autoplay, we create a video element and call play on it, if\n  // `paused` is true after `play()` call, autoplay is supported. Although\n  // this is unintuitive, it works across browsers and is currently the lightest\n  // way to detect autoplay without using a data source.\n  const detectionElement = /** @type {!HTMLVideoElement} */ (\n    win.document.createElement('video')\n  );\n\n  // NOTE(aghassemi): We need both attributes and properties due to Chrome and\n  // Safari differences when dealing with non-attached elements.\n  detectionElement.setAttribute('muted', '');\n  detectionElement.setAttribute('playsinline', '');\n  detectionElement.setAttribute('webkit-playsinline', '');\n  detectionElement.setAttribute('height', '0');\n  detectionElement.setAttribute('width', '0');\n\n  detectionElement.muted = true;\n  detectionElement.playsInline = true;\n  detectionElement['playsinline'] = true;\n  detectionElement['webkitPlaysinline'] = true;\n\n  setStyles(detectionElement, {\n    position: 'fixed',\n    top: '0',\n    width: '0',\n    height: '0',\n    opacity: '0',\n  });\n\n  // Promise wrapped this way to catch both sync throws and async rejections.\n  // More info: https://github.com/tc39/proposal-promise-try\n  playIgnoringError(detectionElement);\n  return Promise.resolve(!detectionElement.paused);\n}\n\nconst AUTOPLAY_SUPPORTED_WIN_PROP = '__AMP_AUTOPLAY';\n\n/**\n * Determines autoplay support.\n *\n * Note that even if platfrom supports autoplay, users or browsers can disable\n * autoplay to save data / battery. This detects both platfrom support and\n * when autoplay has been disabled by the user.\n *\n * @param {!Window} win\n * @return {!Promise<boolean>}\n */\nexport function isAutoplaySupported(win) {\n  if (win[AUTOPLAY_SUPPORTED_WIN_PROP] == null) {\n    win[AUTOPLAY_SUPPORTED_WIN_PROP] = detectIsAutoplaySupported(win);\n  }\n  return win[AUTOPLAY_SUPPORTED_WIN_PROP];\n}\n\n/**\n * @param {!Window} win\n * @visibleForTesting\n */\nexport function resetIsAutoplaySupported(win) {\n  delete win[AUTOPLAY_SUPPORTED_WIN_PROP];\n}\n\n/**\n * @param {!Element} element\n * @return {!Element}\n */\nexport function getInternalVideoElementFor(element) {\n  return devAssertElement(element.querySelector('video, iframe'));\n}\n\n/**\n * @typedef {{\n *   play: (function(boolean): Promise<undefined>|undefined)\n * }}\n */\nlet VideoOrBaseElementPlayableDef;\n\n/**\n * Tries to play the media element, marking any rejected error as an expected\n * error for reproting.\n *\n * @param {!HTMLMediaElement|VideoOrBaseElementPlayableDef} element\n * @param {boolean=} isAutoplay\n * @return {Promise<undefined>}\n */\nexport function tryPlay(element, isAutoplay) {\n  // Some browsers return undefined, some a boolean, and some a real promise.\n  // Using tryResolve coerces all of those into a real promise.\n  const promise = tryResolve(() => element.play(!!isAutoplay));\n  // Fork the promise chain to report any rejected error as expected. We don't\n  // return the promise returned by `.catch()` so that we don't\n  // introduce any new microtasks.\n  promise.catch((err) => {\n    devExpectedError('TRYPLAY', err);\n  });\n  return promise;\n}\n\n/**\n * Plays the media element, discarding any error without reporting it.\n *\n * @param {!HTMLMediaElement} element\n */\nexport function playIgnoringError(element) {\n  // Some browsers return undefined, some a boolean, and some a real promise.\n  // Using tryResolve coerces all of those into a real promise.\n  tryResolve(() => element.play()).catch(() => {\n    // Empty catch to prevent useless unhandled promise rejection logging.\n    // Play can fail for many reasons such as video getting paused before\n    // play() is finished.\n    // We use events to know the state of the video and do not care about\n    // the success or failure of the play()'s returned promise.\n  });\n}\n", "import {computedStyle} from '#core/dom/style';\nimport {tryCallback} from '#core/error';\nimport {remove} from '#core/types/array';\nimport {getWin} from '#core/window';\n\nimport {LayoutSizeDef} from './rect';\n\n/** @typedef {!LayoutSizeDef|!ResizeObserverSize} TargetSize */\n\n/** @enum {number} */\nconst Type = {\n  /**\n   * Mapped to the `ResizeObserverEntry.contentRect` and returns a\n   * `LayoutSizeDef` value.\n   */\n  CONTENT: 0,\n  /**\n   * Mapped to the `ResizeObserverEntry.borderBoxSize` and returns a\n   * `ResizeObserverSize` value.\n   */\n  BORDER_BOX: 1,\n};\n\nconst VERTICAL_RE = /vertical/;\n\n/** @const {!WeakMap<!Window, !ResizeObserver>} */\nconst observers = /* #__PURE__ */ new WeakMap();\n\n/**\n * @const {!WeakMap<!Element, !Array<{\n *   type: !Type,\n *   callback: (function(!LayoutSizeDef)|function(!ResizeObserverSize))\n * }>>}\n */\nconst targetObserverMultimap = /* #__PURE__ */ new WeakMap();\n\n/** @const {!WeakMap<!Element, !ResizeObserverEntry>} */\nconst targetEntryMap = /* #__PURE__ */ new WeakMap();\n\n/**\n * @param {!Element} element\n * @param {function(!LayoutSizeDef)} callback\n */\nexport function observeContentSize(element, callback) {\n  observeSize(element, Type.CONTENT, callback);\n}\n\n/**\n * @param {!Element} element\n * @param {function(!LayoutSizeDef)} callback\n */\nexport function unobserveContentSize(element, callback) {\n  unobserveSize(element, Type.CONTENT, callback);\n}\n\n/**\n * @param {!Element} element\n * @return {!Promise<!LayoutSizeDef>}\n */\nexport function measureContentSize(element) {\n  return new Promise((resolve) => {\n    const onSize = (size) => {\n      resolve(size);\n      unobserveContentSize(element, onSize);\n    };\n    observeContentSize(element, onSize);\n  });\n}\n\n/**\n * Note: this method doesn't support multi-fragment border boxes.\n * @param {!Element} element\n * @param {function(!ResizeObserverSize)} callback\n */\nexport function observeBorderBoxSize(element, callback) {\n  observeSize(element, Type.BORDER_BOX, callback);\n}\n\n/**\n * Note: this method doesn't support multi-fragment border boxes.\n * @param {!Element} element\n * @param {function(!ResizeObserverSize)} callback\n */\nexport function unobserveBorderBoxSize(element, callback) {\n  unobserveSize(element, Type.BORDER_BOX, callback);\n}\n\n/**\n * Note: this method doesn't support multi-fragment border boxes.\n * @param {!Element} element\n * @return {!Promise<!ResizeObserverSize>}\n */\nexport function measureBorderBoxSize(element) {\n  return new Promise((resolve) => {\n    const onSize = (size) => {\n      resolve(size);\n      unobserveBorderBoxSize(element, onSize);\n    };\n    observeBorderBoxSize(element, onSize);\n  });\n}\n\n/**\n * @param {!Element} element\n * @param {!Type} type\n * @param {function(!LayoutSizeDef)|function(!ResizeObserverSize)} callback\n */\nfunction observeSize(element, type, callback) {\n  const win = element.ownerDocument.defaultView;\n  if (!win) {\n    return;\n  }\n  let callbacks = targetObserverMultimap.get(element);\n  if (!callbacks) {\n    callbacks = [];\n    targetObserverMultimap.set(element, callbacks);\n    getObserver(win).observe(element);\n  }\n  const exists = callbacks.some(\n    (cb) => cb.callback === callback && cb.type === type\n  );\n  if (!exists) {\n    callbacks.push({type, callback});\n    const entry = targetEntryMap.get(element);\n    if (entry) {\n      setTimeout(() => computeAndCall(type, callback, entry));\n    }\n  }\n}\n\n/**\n * @param {!Element} element\n * @param {!Type} type\n * @param {function(!LayoutSizeDef)|function(!ResizeObserverSize)} callback\n */\nfunction unobserveSize(element, type, callback) {\n  const callbacks = targetObserverMultimap.get(element);\n  if (!callbacks) {\n    return;\n  }\n  remove(callbacks, (cb) => cb.callback === callback && cb.type === type);\n  if (callbacks.length == 0) {\n    targetObserverMultimap.delete(element);\n    targetEntryMap.delete(element);\n    const win = element.ownerDocument.defaultView;\n    if (win) {\n      getObserver(win).unobserve(element);\n    }\n  }\n}\n\n/**\n * @param {!Window} win\n * @return {!ResizeObserver}\n */\nfunction getObserver(win) {\n  let observer = observers.get(win);\n  if (!observer) {\n    observer = new win.ResizeObserver(processEntries);\n    observers.set(win, observer);\n  }\n  return observer;\n}\n\n/**\n * @param {!Array<!ResizeObserverEntry>} entries\n */\nfunction processEntries(entries) {\n  const seen = new Set();\n  for (let i = entries.length - 1; i >= 0; i--) {\n    const entry = entries[i];\n    const {target} = entry;\n    if (seen.has(target)) {\n      continue;\n    }\n    seen.add(target);\n    const callbacks = targetObserverMultimap.get(target);\n    if (!callbacks) {\n      continue;\n    }\n    targetEntryMap.set(target, entry);\n    for (let k = 0; k < callbacks.length; k++) {\n      const {callback, type} = callbacks[k];\n      computeAndCall(type, callback, entry);\n    }\n  }\n}\n\n/**\n * @param {Type} type\n * @param {function(!LayoutSizeDef)|function(!ResizeObserverSize)} callback\n * @param {!ResizeObserverEntry} entry\n */\nfunction computeAndCall(type, callback, entry) {\n  if (type == Type.CONTENT) {\n    const {contentRect} = entry;\n    const {height, width} = contentRect;\n    /** @type {!LayoutSizeDef} */\n    const size = {width, height};\n    tryCallback(callback, size);\n  } else if (type == Type.BORDER_BOX) {\n    const {borderBoxSize: borderBoxSizeArray} = entry;\n    /** @type {!ResizeObserverSize} */\n    let borderBoxSize;\n    if (borderBoxSizeArray) {\n      // `borderBoxSize` is supported. Only single-fragment border boxes are\n      // supported here (`borderBoxSize[0]`).\n      if (borderBoxSizeArray.length > 0) {\n        borderBoxSize = borderBoxSizeArray[0];\n      } else {\n        borderBoxSize = /** @type {!ResizeObserverSize} */ ({\n          inlineSize: 0,\n          blockSize: 0,\n        });\n      }\n    } else {\n      // `borderBoxSize` is not supported: polyfill it via blocking measures.\n      const {target} = entry;\n      const win = getWin(target);\n      const isVertical = VERTICAL_RE.test(\n        computedStyle(win, target)['writing-mode']\n      );\n      const {offsetHeight, offsetWidth} = /** @type {!HTMLElement} */ (target);\n      let inlineSize, blockSize;\n      if (isVertical) {\n        blockSize = offsetWidth;\n        inlineSize = offsetHeight;\n      } else {\n        inlineSize = offsetWidth;\n        blockSize = offsetHeight;\n      }\n      borderBoxSize = {inlineSize, blockSize};\n    }\n    tryCallback(callback, borderBoxSize);\n  }\n}\n", "import {\n  observeBorderBoxSize,\n  unobserveBorderBoxSize,\n} from '#core/dom/layout/size-observer';\n\nexport class PauseHelper {\n  /**\n   * @param {!AmpElement} element\n   */\n  constructor(element) {\n    /**\n     * @private\n     * @const\n     * @type {!AmpElement}\n     */\n    this.element_ = element;\n\n    /** @private {boolean} */\n    this.isPlaying_ = false;\n\n    /** @private {boolean} */\n    this.hasSize_ = false;\n\n    this.pauseWhenNoSize_ = this.pauseWhenNoSize_.bind(this);\n  }\n\n  /**\n   * @param {boolean} isPlaying\n   */\n  updatePlaying(isPlaying) {\n    if (isPlaying === this.isPlaying_) {\n      return;\n    }\n    this.isPlaying_ = isPlaying;\n    if (isPlaying) {\n      // Pause will not be called until transitioning from \"has size\" to\n      // \"no size\". Which means a measurement must first be received that\n      // has size, then a measurement that does not have size.\n      this.hasSize_ = false;\n      observeBorderBoxSize(this.element_, this.pauseWhenNoSize_);\n    } else {\n      unobserveBorderBoxSize(this.element_, this.pauseWhenNoSize_);\n    }\n  }\n\n  /**\n   * @param {!ResizeObserverSize} size\n   * @private\n   */\n  pauseWhenNoSize_({blockSize, inlineSize}) {\n    const hasSize = inlineSize > 0 && blockSize > 0;\n    if (hasSize === this.hasSize_) {\n      return;\n    }\n    this.hasSize_ = hasSize;\n\n    /** @type {!PausableInterface} */\n    const element = this.element_;\n    if (!hasSize) {\n      element.pause();\n    }\n  }\n}\n", "/** @fileoverview Helpers to wrap functions. */\n\n/**\n * Creates a function that is evaluated only once and returns the cached result\n * subsequently.\n *\n * Please note that `once` only takes the function definition into account,\n * so it will return the same cached value even when the arguments are\n * different.\n *\n * @param {function(...):T} fn\n * @return {function(...):T}\n * @template T\n */\nexport function once(fn) {\n  let evaluated = false;\n  let retValue = null;\n  let callback = fn;\n  return (...args) => {\n    if (!evaluated) {\n      retValue = callback.apply(self, args);\n      evaluated = true;\n      callback = null; // GC\n    }\n    return retValue;\n  };\n}\n\n/**\n * Wraps a given callback and applies a rate limit.\n * It throttles the calls so that no consequent calls have time interval\n * smaller than the given minimal interval.\n *\n * @param {!Window} win\n * @param {function(...T):R} callback\n * @param {number} minInterval the minimum time interval in millisecond\n * @return {function(...T)}\n * @template T\n * @template R\n */\nexport function throttle(win, callback, minInterval) {\n  let locker = 0;\n  let nextCallArgs = null;\n\n  /**\n   * @param {!Object} args\n   */\n  function fire(args) {\n    nextCallArgs = null;\n    // Lock the fire for minInterval milliseconds\n    locker = win.setTimeout(waiter, minInterval);\n\n    callback.apply(null, args);\n  }\n\n  /**\n   * Waiter function\n   */\n  function waiter() {\n    locker = 0;\n    // If during the period there're invocations queued up, fire once.\n    if (nextCallArgs) {\n      fire(nextCallArgs);\n    }\n  }\n\n  return function (...args) {\n    if (locker) {\n      nextCallArgs = args;\n    } else {\n      fire(args);\n    }\n  };\n}\n\n/**\n * Wraps a given callback and applies a wait timer, so that minInterval\n * milliseconds must pass since the last call before the callback is actually\n * invoked.\n *\n * @param {!Window} win\n * @param {function(...T):R} callback\n * @param {number} minInterval the minimum time interval in millisecond\n * @return {function(...T)}\n * @template T\n * @template R\n */\nexport function debounce(win, callback, minInterval) {\n  let locker = 0;\n  let timestamp = 0;\n  let nextCallArgs = null;\n\n  /**\n   * @param {?Array} args\n   */\n  function fire(args) {\n    nextCallArgs = null;\n    callback.apply(null, args);\n  }\n\n  /**\n   * Wait function for debounce\n   */\n  function waiter() {\n    locker = 0;\n    const remaining = minInterval - (win.Date.now() - timestamp);\n    if (remaining > 0) {\n      locker = win.setTimeout(waiter, remaining);\n    } else {\n      fire(nextCallArgs);\n    }\n  }\n\n  return function (...args) {\n    timestamp = win.Date.now();\n    nextCallArgs = args;\n    if (!locker) {\n      locker = win.setTimeout(waiter, minInterval);\n    }\n  };\n}\n", "/**\n * Allows for runtime configuration. Internally, the runtime should\n * use the src/config.js module for various constants. We can use the\n * AMP_CONFIG global to translate user-defined configurations to this\n * module.\n * @type {!Object<string, string>}\n */\nconst env = self.AMP_CONFIG || {};\n\nconst thirdPartyFrameRegex =\n  (typeof env['thirdPartyFrameRegex'] == 'string'\n    ? new RegExp(env['thirdPartyFrameRegex'])\n    : env['thirdPartyFrameRegex']) || /^d-\\d+\\.ampproject\\.net$/;\n\nconst cdnProxyRegex =\n  (typeof env['cdnProxyRegex'] == 'string'\n    ? new RegExp(env['cdnProxyRegex'])\n    : env['cdnProxyRegex']) ||\n  /^https:\\/\\/([a-zA-Z0-9_-]+\\.)?cdn\\.ampproject\\.org$/;\n\n/**\n * Check for a custom URL definition in special <meta> tags. Note that this does\n * not allow for distinct custom URLs in AmpDocShadow instances. The shell is\n * allowed to define one set of custom URLs via AMP_CONFIG (recommended) or by\n * including <meta> tags in the shell <head>. Those custom URLs then apply to\n * all AMP documents loaded in the shell.\n * @param {string} name\n * @return {?string}\n * @private\n */\nfunction getMetaUrl(name) {\n  // Avoid exceptions in unit tests\n  if (!self.document || !self.document.head) {\n    return null;\n  }\n\n  // Disallow on proxy origins\n  if (self.location && cdnProxyRegex.test(self.location.origin)) {\n    return null;\n  }\n\n  const metaEl = self.document.head./*OK*/ querySelector(\n    `meta[name=\"${name}\"]`\n  );\n  return (metaEl && metaEl.getAttribute('content')) || null;\n}\n\n/**\n * @typedef {{\n *   thirdParty: string,\n *   thirdPartyFrameHost: string,\n *   thirdPartyFrameRegex: !RegExp,\n *   cdn: string,\n *   cdnProxyRegex: !RegExp,\n *   localhostRegex: !RegExp,\n *   errorReporting: string,\n *   betaErrorReporting: string,\n *   localDev: boolean,\n *   trustedViewerHosts: !Array<!RegExp>,\n *   geoApi: ?string,\n * }}\n */\nexport const urls = {\n  thirdParty: env['thirdPartyUrl'] || 'https://3p.ampproject.net',\n  thirdPartyFrameHost: env['thirdPartyFrameHost'] || 'ampproject.net',\n  thirdPartyFrameRegex,\n  cdn:\n    env['cdnUrl'] || getMetaUrl('runtime-host') || 'https://cdn.ampproject.org',\n  /* Note that cdnProxyRegex is only ever checked against origins\n   * (proto://host[:port]) so does not need to consider path\n   */\n  cdnProxyRegex,\n  localhostRegex: /^https?:\\/\\/localhost(:\\d+)?$/,\n  errorReporting:\n    env['errorReportingUrl'] ||\n    'https://us-central1-amp-error-reporting.cloudfunctions.net/r',\n  betaErrorReporting:\n    env['betaErrorReportingUrl'] ||\n    'https://us-central1-amp-error-reporting.cloudfunctions.net/r-beta',\n  localDev: env['localDev'] || false,\n  /**\n   * These domains are trusted with more sensitive viewer operations such as\n   * propagating the referrer. If you believe your domain should be here,\n   * file the issue on GitHub to discuss. The process will be similar\n   * (but somewhat more stringent) to the one described in the [3p/README.md](\n   * https://github.com/ampproject/amphtml/blob/main/3p/README.md)\n   *\n   * {!Array<!RegExp>}\n   */\n  trustedViewerHosts: [\n    /(^|\\.)google\\.(com?|[a-z]{2}|com?\\.[a-z]{2}|cat)$/,\n    /(^|\\.)gmail\\.(com|dev)$/,\n  ],\n  // Optional fallback API if amp-geo is left unpatched\n  geoApi: env['geoApiUrl'] || getMetaUrl('amp-geo-api'),\n};\n\nexport const config = {\n  urls,\n};\n", "import * as mode from '#core/mode';\n\nimport {urls} from '../config';\nimport {getMode} from '../mode';\n\nconst CUSTOM_TEMPLATES = ['amp-mustache'];\nconst LATEST_VERSION = 'latest';\n\n/**\n * Calculate the base url for any scripts.\n * @param {!Location} location The window's location\n * @param {boolean=} opt_isLocalDev\n * @return {string}\n */\nexport function calculateScriptBaseUrl(location, opt_isLocalDev) {\n  if (opt_isLocalDev) {\n    let prefix = `${location.protocol}//${location.host}`;\n    if (\n      location.protocol == 'about:' ||\n      location.protocol == 'blob:' ||\n      location.protocol == 'data:'\n    ) {\n      prefix = '';\n    }\n    return `${prefix}/dist`;\n  }\n  return urls.cdn;\n}\n\n/**\n * Calculate script url for an extension.\n * @param {!Location} location The window's location\n * @param {string} extensionId\n * @param {string} version\n * @param {boolean=} opt_isLocalDev\n * @return {string}\n */\nexport function calculateExtensionScriptUrl(\n  location,\n  extensionId,\n  version,\n  opt_isLocalDev\n) {\n  const fileExtension = mode.isEsm() ? '.mjs' : '.js';\n  const base = calculateScriptBaseUrl(location, opt_isLocalDev);\n  const rtv = getMode().rtvVersion;\n  const extensionVersion = version ? '-' + version : '';\n  return `${base}/rtv/${rtv}/v0/${extensionId}${extensionVersion}${fileExtension}`;\n}\n\n/**\n * Calculate script url for an entry point.\n * If `opt_rtv` is true, returns the URL matching the current RTV.\n * @param {!Location} location The window's location\n * @param {string} entryPoint\n * @param {boolean=} isLocalDev\n * @param {boolean=} opt_rtv\n * @return {string}\n */\nexport function calculateEntryPointScriptUrl(\n  location,\n  entryPoint,\n  isLocalDev,\n  opt_rtv\n) {\n  const fileExtension = mode.isEsm() ? '.mjs' : '.js';\n  const base = calculateScriptBaseUrl(location, isLocalDev);\n  if (isLocalDev) {\n    return `${base}/${entryPoint}${fileExtension}`;\n  }\n  if (opt_rtv) {\n    return `${base}/rtv/${getMode().rtvVersion}/${entryPoint}${fileExtension}`;\n  }\n  return `${base}/${entryPoint}${fileExtension}`;\n}\n\n/**\n * Parse the extension version from a given script URL.\n * @param {string} scriptUrl\n * @return {?{extensionId: string, extensionVersion: string}}\n */\nexport function parseExtensionUrl(scriptUrl) {\n  if (!scriptUrl) {\n    return null;\n  }\n  // Note that the \"(\\.max)?\" group only applies to local dev.\n  const matches = scriptUrl.match(\n    /^(.*)\\/(.*)-([0-9.]+|latest)(\\.max)?\\.(?:js|mjs)$/i\n  );\n  const extensionId = matches ? matches[2] : undefined;\n  const extensionVersion = matches ? matches[3] : undefined;\n  if (!extensionId || !extensionVersion) {\n    return null;\n  }\n  return {extensionId, extensionVersion};\n}\n\n/**\n * Create the missing amp extension HTML script element.\n * @param {!Window} win\n * @param {string} extensionId\n * @param {string} version\n * @return {!Element} Script object\n */\nexport function createExtensionScript(win, extensionId, version) {\n  const scriptElement = win.document.createElement('script');\n  scriptElement.async = true;\n  if (isIntermediateExtension(extensionId)) {\n    version = '';\n  } else {\n    scriptElement.setAttribute(\n      CUSTOM_TEMPLATES.indexOf(extensionId) >= 0\n        ? 'custom-template'\n        : 'custom-element',\n      extensionId\n    );\n  }\n  scriptElement.setAttribute('data-script', extensionId);\n  scriptElement.setAttribute('i-amphtml-inserted', '');\n  if (mode.isEsm()) {\n    scriptElement.setAttribute('type', 'module');\n  }\n\n  // Propagate nonce to all generated script tags.\n  const currentScript = win.document.head.querySelector('script[nonce]');\n  if (currentScript) {\n    scriptElement.setAttribute('nonce', currentScript.getAttribute('nonce'));\n  }\n\n  // Allow error information to be collected\n  // https://github.com/ampproject/amphtml/issues/7353\n  scriptElement.setAttribute('crossorigin', 'anonymous');\n  let loc = win.location;\n  if (getMode(win).test && win.testLocation) {\n    loc = win.testLocation;\n  }\n  const scriptSrc = calculateExtensionScriptUrl(\n    loc,\n    extensionId,\n    version,\n    getMode(win).localDev\n  );\n  scriptElement.src = scriptSrc;\n  return scriptElement;\n}\n\n/**\n * Returns the extension <script> element and attribute for the given\n * extension ID, if it exists. Otherwise, returns null.\n * @param {!Window} win\n * @param {string} extensionId\n * @param {string} version\n * @param {boolean} latest\n * @param {boolean=} includeInserted If true, includes script elements that\n *   are inserted by the runtime dynamically. Default is true.\n * @return {!Array<!Element>}\n */\nexport function getExtensionScripts(\n  win,\n  extensionId,\n  version,\n  latest,\n  includeInserted = true\n) {\n  // Always ignore <script> elements that have a mismatched RTV.\n  const modifier =\n    ':not([i-amphtml-loaded-new-version])' +\n    (includeInserted ? '' : ':not([i-amphtml-inserted])');\n  // We have to match against \"src\" because a few extensions, such as\n  // \"amp-viewer-integration\", do not have \"custom-element\" attribute.\n  const matches = win.document.head./*OK*/ querySelectorAll(\n    `script[src*=\"/${extensionId}-\"]${modifier}`\n  );\n  const filtered = [];\n  for (let i = 0; i < matches.length; i++) {\n    const match = matches[i];\n    const urlParts = parseExtensionUrl(match.src);\n    if (!urlParts) {\n      continue;\n    }\n    const {\n      extensionId: scriptExtensionId,\n      extensionVersion: scriptExtensionVersion,\n    } = urlParts;\n    if (\n      scriptExtensionId == extensionId &&\n      (isIntermediateExtension(extensionId) ||\n        scriptExtensionVersion == version ||\n        (scriptExtensionVersion == LATEST_VERSION && latest))\n    ) {\n      filtered.push(match);\n    }\n  }\n  return filtered;\n}\n\n/**\n * Get list of all the extension JS files.\n * @param {HTMLHeadElement|Element|ShadowRoot|Document} head\n * @return {!Array<{script: HTMLScriptElement, extensionId: string, extensionVersion: string}>}\n */\nexport function extensionScriptsInNode(head) {\n  // ampdoc.getHeadNode() can return null.\n  if (!head) {\n    return [];\n  }\n  // Note: Some extensions don't have [custom-element] or [custom-template]\n  // e.g. amp-viewer-integration.\n  const list = head.querySelectorAll(\n    'script[custom-element],script[custom-template]'\n  );\n  const scripts = [];\n  for (let i = 0; i < list.length; i++) {\n    const script = list[i];\n    const extensionId =\n      script.getAttribute('custom-element') ||\n      script.getAttribute('custom-template');\n    const urlParts = parseExtensionUrl(script.src);\n    if (extensionId && urlParts) {\n      scripts.push({\n        script,\n        extensionId,\n        extensionVersion: urlParts.extensionVersion,\n      });\n    }\n  }\n  return scripts;\n}\n\n/**\n * Verifies that an extension script is present in head for\n * installation.\n * @param {!Window} win\n * @param {string} id\n * @param {string} version\n * @return {boolean}\n */\nexport function extensionScriptInNode(win, id, version) {\n  return extensionScriptsInNode(win.document.head).some(\n    ({extensionId, extensionVersion}) =>\n      id == extensionId && version == extensionVersion\n  );\n}\n\n/**\n * @param {string} extensionId\n * @return {boolean}\n */\nfunction isIntermediateExtension(extensionId) {\n  return extensionId.startsWith('_');\n}\n", "import * as assertions from '#core/assert/base';\nimport {\n  createError,\n  createExpectedError,\n  duplicateErrorIfNecessary,\n} from '#core/error';\nimport {\n  USER_ERROR_EMBED_SENTINEL,\n  USER_ERROR_SENTINEL,\n  elementStringOrPassThru,\n  isUserErrorMessage,\n  stripUserError,\n} from '#core/error/message-helpers';\nimport * as mode from '#core/mode';\nimport {isArray, isString} from '#core/types';\nimport {once} from '#core/types/function';\nimport {getHashParams} from '#core/types/string/url';\n\nimport {urls} from '../config';\nimport {getMode} from '../mode';\n\nconst noop = () => {};\n\n// These are exported here despite being defined elswhere to avoid updating\n// imports across many files for now.\nexport {USER_ERROR_SENTINEL, isUserErrorMessage};\n\n/**\n * Sets reportError function. Called from error-reporting.js to break cyclic\n * dependency.\n * @param {function(this:Window, Error, (?Element)=): ?|undefined} fn\n */\nexport function setReportError(fn) {\n  self.__AMP_REPORT_ERROR = fn;\n}\n\n/**\n * @enum {number}\n */\nexport const LogLevel = {\n  OFF: 0,\n  ERROR: 1,\n  WARN: 2,\n  INFO: 3,\n  FINE: 4,\n};\n\n/**\n * @type {!LogLevel|undefined}\n * @private\n */\nlet levelOverride_ = undefined;\n\n/**\n * @param {!LogLevel} level\n */\nexport function overrideLogLevel(level) {\n  levelOverride_ = level;\n}\n\n/**\n * Prefixes `internalRuntimeVersion` with the `01` channel signifier (for prod.) for\n * extracted message URLs.\n * (Specific channel is irrelevant: message tables are invariant on internal version.)\n * @return {string}\n */\nconst messageUrlRtv = () => `01${mode.version()}`;\n\n/**\n * Gets a URL to display a message on amp.dev.\n * @param {string} id\n * @param {!Array} interpolatedParts\n * @return {string}\n */\nconst externalMessageUrl = (id, interpolatedParts) =>\n  interpolatedParts.reduce(\n    (prefix, arg) => `${prefix}&s[]=${messageArgToEncodedComponent(arg)}`,\n    `https://log.amp.dev/?v=${messageUrlRtv()}&id=${encodeURIComponent(id)}`\n  );\n\n/**\n * URL to simple log messages table JSON file, which contains an Object<string, string>\n * which maps message id to full message template.\n * @return {string}\n */\nconst externalMessagesSimpleTableUrl = () =>\n  `${urls.cdn}/rtv/${messageUrlRtv()}/log-messages.simple.json`;\n\n/**\n * @param {*} arg\n * @return {string}\n */\nconst messageArgToEncodedComponent = (arg) =>\n  encodeURIComponent(String(elementStringOrPassThru(arg)));\n\n/**\n * @param {!Window=} opt_win\n * @return {number}\n */\nexport const logHashParam = (opt_win) =>\n  parseInt(getHashParams(opt_win)['log'], 10);\n\n/**\n * Logging class. Use of sentinel string instead of a boolean to check user/dev\n * errors because errors could be rethrown by some native code as a new error,\n * and only a message would survive. Also, some browser don\u2019t support a 5th\n * error object argument in window.onerror. List of supporting browser can be\n * found here:\n * https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html\n * @final\n * @private Visible for testing only.\n */\nexport class Log {\n  /**\n   * opt_suffix will be appended to error message to identify the type of the\n   * error message. We can't rely on the error object to pass along the type\n   * because some browsers do not have this param in its window.onerror API.\n   * See:\n   * https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html\n   *\n   * @param {!Window} win\n   * @param {function(number, boolean):!LogLevel} levelFunc\n   * @param {string=} opt_suffix\n   */\n  constructor(win, levelFunc, opt_suffix = '') {\n    /**\n     * In tests we use the main test window instead of the iframe where\n     * the tests runs because only the former is relayed to the console.\n     * @const {!Window}\n     */\n    this.win = getMode().test && win.__AMP_TEST_IFRAME ? win.parent : win;\n\n    /** @private @const {function(number, boolean):!LogLevel} */\n    this.levelFunc_ = levelFunc;\n\n    /** @private @const {!LogLevel} */\n    this.level_ = this.defaultLevel_();\n\n    /** @private @const {string} */\n    this.suffix_ = opt_suffix;\n\n    /** @private {?JsonObject} */\n    this.messages_ = null;\n\n    this.fetchExternalMessagesOnce_ = once(() => {\n      win\n        .fetch(externalMessagesSimpleTableUrl())\n        .then((response) => response.json(), noop)\n        .then((opt_messages) => {\n          if (opt_messages) {\n            this.messages_ = /** @type {!JsonObject} */ (opt_messages);\n          }\n        });\n    });\n\n    // This bound assertion function is capable of handling the format used when\n    // error/assertion messages are extracted. This logic hasn't yet been\n    // migrated to an AMP-independent form for use in core. This binding allows\n    // Log assertion helpers to maintain message-extraction capabilities until\n    // that logic can be moved to core.\n    this.boundAssertFn_ = /** @type {!assertions.AssertionFunctionDef} */ (\n      this.assert.bind(this)\n    );\n  }\n\n  /**\n   * @return {!LogLevel}\n   * @private\n   */\n  defaultLevel_() {\n    const {win} = this;\n    // No console - can't enable logging.\n    if (\n      !win.console?.log ||\n      // Logging has been explicitly disabled.\n      logHashParam(win) == 0\n    ) {\n      return LogLevel.OFF;\n    }\n\n    // Logging is enabled for tests directly.\n    if (getMode().test && win.ENABLE_LOG) {\n      return LogLevel.FINE;\n    }\n\n    // LocalDev by default allows INFO level, unless overriden by `#log`.\n    if (getMode().localDev) {\n      return LogLevel.INFO;\n    }\n\n    return this.defaultLevelWithFunc_();\n  }\n\n  /**\n   * @param {!Window=} opt_win provided for testing\n   * @return {!LogLevel}\n   * @private\n   */\n  defaultLevelWithFunc_(opt_win) {\n    // Delegate to the specific resolver.\n    return this.levelFunc_(logHashParam(opt_win), getMode().development);\n  }\n\n  /**\n   * @param {string} tag\n   * @param {!LogLevel} level\n   * @param {!Array} messages\n   * @return {boolean} true if a the message was logged\n   */\n  msg_(tag, level, messages) {\n    if (level > (levelOverride_ ?? this.level_)) {\n      return false;\n    }\n\n    const cs = this.win.console;\n    const fn =\n      {\n        [LogLevel.ERROR]: cs.error,\n        [LogLevel.INFO]: cs.info,\n        [LogLevel.WARN]: cs.warn,\n      }[level] ?? cs.log;\n\n    const args = this.maybeExpandMessageArgs_(messages);\n    // Prefix console message with \"[tag]\".\n    const prefix = `[${tag}]`;\n    if (isString(args[0])) {\n      // Prepend string to avoid breaking string substitutions e.g. %s.\n      args[0] = prefix + ' ' + args[0];\n    } else {\n      args.unshift(prefix);\n    }\n    fn.apply(cs, args);\n\n    return true;\n  }\n\n  /**\n   * Reports a fine-grained message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  fine(tag, ...args) {\n    this.msg_(tag, LogLevel.FINE, args);\n  }\n\n  /**\n   * Reports a informational message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  info(tag, ...args) {\n    this.msg_(tag, LogLevel.INFO, args);\n  }\n\n  /**\n   * Reports a warning message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  warn(tag, ...args) {\n    this.msg_(tag, LogLevel.WARN, args);\n  }\n\n  /**\n   * Reports an error message.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  error(tag, ...args) {\n    if (!this.msg_(tag, LogLevel.ERROR, args)) {\n      const error = this.createError.apply(this, args);\n      error.name = tag || error.name;\n      self.__AMP_REPORT_ERROR?.(error);\n    }\n  }\n\n  /**\n   * Reports an error message and marks with an expected property. If the\n   * logging is disabled, the error is rethrown asynchronously.\n   * @param {string} tag\n   * @param {...*} args\n   */\n  expectedError(tag, ...args) {\n    if (!this.msg_(tag, LogLevel.ERROR, args)) {\n      self.__AMP_REPORT_ERROR?.(this.createExpectedError.apply(this, args));\n    }\n  }\n\n  /**\n   * Creates an error object.\n   * @param {...*} var_args\n   * @return {!Error}\n   */\n  createError(var_args) {\n    return this.setErrorSuffix_(createError.apply(null, arguments));\n  }\n\n  /**\n   * Creates an error object with its expected property set to true.\n   * @param {...*} var_args\n   * @return {!Error}\n   */\n  createExpectedError(var_args) {\n    return this.setErrorSuffix_(createExpectedError.apply(null, arguments));\n  }\n\n  /**\n   * @param {!Error} error\n   * @return {!Error}\n   * @private\n   */\n  setErrorSuffix_(error) {\n    error = duplicateErrorIfNecessary(error);\n\n    if (this.suffix_) {\n      if (!error.message) {\n        error.message = this.suffix_;\n      } else if (error.message.indexOf(this.suffix_) == -1) {\n        error.message += this.suffix_;\n      }\n    } else if (isUserErrorMessage(error.message)) {\n      error.message = stripUserError(error.message);\n    }\n\n    return error;\n  }\n\n  /**\n   * @param {!Array} args\n   * @return {!Array}\n   * @private\n   */\n  maybeExpandMessageArgs_(args) {\n    return isArray(args[0])\n      ? this.expandMessageArgs_(/** @type {!Array} */ (args[0]))\n      : args;\n  }\n\n  /**\n   * Either redirects a pair of (errorId, ...args) to a URL where the full\n   * message is displayed, or displays it from a fetched table.\n   *\n   * This method is used by the output of the `transform-log-methods` babel\n   * plugin. It should not be used directly. Use the (*error|assert*|info|warn)\n   * methods instead.\n   *\n   * @param {!Array} parts\n   * @return {!Array}\n   * @private\n   */\n  expandMessageArgs_(parts) {\n    // First value should exist.\n    const id = parts.shift();\n    // Best effort fetch of message template table.\n    // Since this is async, the first few logs might be indirected to a URL even\n    // if in development mode. Message table is ~small so this should be a short\n    // gap.\n    if (getMode(this.win).development) {\n      this.fetchExternalMessagesOnce_();\n    }\n\n    return this.messages_?.[id]\n      ? [this.messages_[id]].concat(parts)\n      : [`More info at ${externalMessageUrl(id, parts)}`];\n  }\n\n  /**\n   * Throws an error if the first argument isn't trueish.\n   *\n   * Supports argument substitution into the message via %s placeholders.\n   *\n   * Throws an error object that has two extra properties:\n   * - associatedElement: This is the first element provided in the var args.\n   *   It can be used for improved display of error messages.\n   * - messageArray: The elements of the substituted message as non-stringified\n   *   elements in an array. When e.g. passed to console.error this yields\n   *   native displays of things like HTML elements.\n   *\n   * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n   *     not evaluate to true.\n   * @param {!Array|string=} opt_message The assertion message\n   * @param {...*} var_args Arguments substituted into %s in the message.\n   * @return {T} The value of shouldBeTrueish.\n   * @throws {!Error} When `value` is falsey.\n   * @template T\n   * @closurePrimitive {asserts.truthy}\n   */\n  assert(shouldBeTrueish, opt_message, var_args) {\n    if (isArray(opt_message)) {\n      return this.assert.apply(\n        this,\n        [shouldBeTrueish].concat(\n          this.expandMessageArgs_(/** @type {!Array} */ (opt_message))\n        )\n      );\n    }\n\n    return assertions.assert.apply(\n      null,\n      [this.suffix_].concat(Array.prototype.slice.call(arguments))\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't an Element\n   *\n   * Otherwise see `assert` for usage\n   *\n   * @param {*} shouldBeElement\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {!Element} The value of shouldBeTrueish.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertElement(shouldBeElement, opt_message) {\n    return assertions.assertElement(\n      this.boundAssertFn_,\n      shouldBeElement,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't a string. The string can\n   * be empty.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeString\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {string} The string value. Can be an empty string.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertString(shouldBeString, opt_message) {\n    return assertions.assertString(\n      this.boundAssertFn_,\n      shouldBeString,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't a number. The allowed values\n   * include `0` and `NaN`.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeNumber\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {number} The number value. The allowed values include `0`\n   *   and `NaN`.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertNumber(shouldBeNumber, opt_message) {\n    return assertions.assertNumber(\n      this.boundAssertFn_,\n      shouldBeNumber,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument is not an array.\n   * The array can be empty.\n   *\n   * @param {*} shouldBeArray\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {!Array} The array value\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertArray(shouldBeArray, opt_message) {\n    return assertions.assertArray(\n      this.boundAssertFn_,\n      shouldBeArray,\n      opt_message\n    );\n  }\n\n  /**\n   * Throws an error if the first argument isn't a boolean.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeBoolean\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {boolean} The boolean value.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertBoolean(shouldBeBoolean, opt_message) {\n    return assertions.assertBoolean(\n      this.boundAssertFn_,\n      shouldBeBoolean,\n      opt_message\n    );\n  }\n}\n\n/**\n * Cache for logs. We do not use a Service since the service module depends\n * on Log and closure literally can't even.\n * @type {{user: ?Log, dev: ?Log, userForEmbed: ?Log}}\n */\nself.__AMP_LOG = self.__AMP_LOG || {\n  user: null,\n  dev: null,\n  userForEmbed: null,\n};\n\nconst logs = self.__AMP_LOG;\n\n/**\n * Eventually holds a constructor for Log objects. Lazily initialized, so we\n * can avoid ever referencing the real constructor except in JS binaries\n * that actually want to include the implementation.\n * @type {?typeof Log}\n */\nlet logConstructor = null;\n\n/**\n * Initializes log constructor.\n */\nexport function initLogConstructor() {\n  logConstructor = Log;\n  // Initialize instances for use. If a binary (an extension for example) that\n  // does not call `initLogConstructor` invokes `dev()` or `user()` earlier than\n  // the binary that does call `initLogConstructor` (amp.js), the extension will\n  // throw an error as that extension will never be able to initialize the log\n  // instances and we also don't want it to call `initLogConstructor` either\n  // (since that will cause the Log implementation to be bundled into that\n  // binary). So we must initialize the instances eagerly so that they are ready\n  // for use (stored globally) after the main binary calls `initLogConstructor`.\n  dev();\n  user();\n}\n\n/**\n * Resets log constructor for testing.\n */\nexport function resetLogConstructorForTesting() {\n  logConstructor = null;\n}\n\n/**\n * Calls the log constructor with a given level function and suffix.\n * @param {function(number, boolean):!LogLevel} levelFunc\n * @param {string=} opt_suffix\n * @return {!Log}\n */\nfunction callLogConstructor(levelFunc, opt_suffix) {\n  if (!logConstructor) {\n    throw new Error('failed to call initLogConstructor');\n  }\n  return new logConstructor(self, levelFunc, opt_suffix);\n}\n\n/**\n * Publisher level log.\n *\n * Enabled in the following conditions:\n *  1. Not disabled using `#log=0`.\n *  2. Development mode is enabled via `#development=1` or logging is explicitly\n *     enabled via `#log=D` where D >= 1.\n *  3. AMP.setLogLevel(D) is called, where D >= 1.\n *\n * @param {!Element=} opt_element\n * @return {!Log}\n */\nexport function user(opt_element) {\n  // logs.user must exist first to perform the logs.user.win check below\n  if (!logs.user) {\n    logs.user = getUserLogger(USER_ERROR_SENTINEL);\n  }\n\n  if (isFromEmbed(logs.user.win, opt_element)) {\n    return (\n      logs.userForEmbed ||\n      (logs.userForEmbed = getUserLogger(USER_ERROR_EMBED_SENTINEL))\n    );\n  }\n  return logs.user;\n}\n\n/**\n * Getter for user logger\n * @param {string=} suffix\n * @return {!Log}\n */\nfunction getUserLogger(suffix) {\n  return callLogConstructor(\n    (logNum, development) =>\n      development || logNum >= 1 ? LogLevel.FINE : LogLevel.WARN,\n    suffix\n  );\n}\n\n/**\n * AMP development log. Calls to `devLog().assert` and `dev.fine` are stripped\n * in the PROD binary. However, `devLog().assert` result is preserved in either\n * case.\n *\n * Enabled in the following conditions:\n *  1. Not disabled using `#log=0`.\n *  2. Logging is explicitly enabled via `#log=D`, where D >= 2.\n *  3. AMP.setLogLevel(D) is called, where D >= 2.\n *\n * @return {!Log}\n */\nexport function dev() {\n  return (\n    logs.dev ||\n    (logs.dev = callLogConstructor((logNum) =>\n      logNum >= 3 ? LogLevel.FINE : logNum >= 2 ? LogLevel.INFO : LogLevel.OFF\n    ))\n  );\n}\n\n/**\n * @param {!Window} win\n * @param {!Element=} opt_element\n * @return {boolean} isEmbed\n */\nfunction isFromEmbed(win, opt_element) {\n  return opt_element && opt_element.ownerDocument.defaultView != win;\n}\n\n/**\n * Throws an error if the first argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - associatedElement: This is the first element provided in the var args.\n *   It can be used for improved display of error messages.\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n *\n * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n *     not evaluate to true.\n * @param {!Array|string=} opt_message The assertion message\n * @param {*=} opt_1 Optional argument (Var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {T} The value of shouldBeTrueish.\n * @throws {!Error} When `shouldBeTrueish` is falsey.\n * @template T\n * @closurePrimitive {asserts.truthy}\n */\nexport function devAssert(\n  shouldBeTrueish,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  if (mode.isMinified()) {\n    return shouldBeTrueish;\n  }\n  if (self.__AMP_ASSERTION_CHECK) {\n    // This will never execute regardless, but will be included on unminified\n    // builds. It will be DCE'd away from minified builds, and so can be used to\n    // validate that Babel is properly removing dev assertions in minified\n    // builds.\n    console /*OK*/\n      .log('__devAssert_sentinel__');\n  }\n\n  return dev()./*Orig call*/ assert(\n    shouldBeTrueish,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n\n/**\n * Throws an error if the first argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - associatedElement: This is the first element provided in the var args.\n *   It can be used for improved display of error messages.\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n *\n * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n *     not evaluate to true.\n * @param {!Array|string=} opt_message The assertion message\n * @param {*=} opt_1 Optional argument (Var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {T} The value of shouldBeTrueish.\n * @throws {!Error} When `shouldBeTrueish` is falsey.\n * @template T\n * @closurePrimitive {asserts.truthy}\n */\nexport function userAssert(\n  shouldBeTrueish,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  return user()./*Orig call*/ assert(\n    shouldBeTrueish,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n", "/**\n * @fileoverview Registration and getter functions for AMP services.\n *\n * Invariant: Service getters never return null for registered services.\n */\n\nimport {Deferred} from '#core/data-structures/promise';\nimport {getWin} from '#core/window';\n\nimport {dev, devAssert} from '#utils/log';\n\n/**\n * Holds info about a service.\n * - obj: Actual service implementation when available.\n * - promise: Promise for the obj.\n * - resolve: Function to resolve the promise with the object.\n * - context: Argument for ctor, either a window or an ampdoc.\n * - ctor: Function that constructs and returns the service.\n * @typedef {{\n *   obj: (?Object),\n *   promise: (?Promise),\n *   resolve: (?function(!Object)),\n *   reject: (?function((*))),\n *   context: (?Window|?./service/ampdoc-impl.AmpDoc),\n *   ctor: (function(new:Object, !Window)|\n *          function(new:Object, !./service/ampdoc-impl.AmpDoc)),\n * }}\n */\nlet ServiceHolderDef;\n\n/**\n * This interface provides a `dispose` method that will be called by\n * runtime when a service needs to be disposed of.\n * @interface\n */\nexport class Disposable {\n  /**\n   * Instructs the service to release any resources it might be holding. Can\n   * be called only once in the lifecycle of a service.\n   */\n  dispose() {}\n}\n\n/**\n * Installs a service override on amp-doc level.\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {string} id\n * @param {!Object} service The service.\n */\nexport function installServiceInEmbedDoc(ampdoc, id, service) {\n  registerServiceInternal(\n    getAmpdocServiceHolder(ampdoc),\n    ampdoc,\n    id,\n    function () {\n      return service;\n    },\n    /* override */ true\n  );\n}\n\n/**\n * Installs a service override in the scope of an embedded window.\n * @param {!Window} embedWin\n * @param {string} id\n * @param {function(new:Object, !Window)} constructor\n */\nexport function registerServiceBuilderInEmbedWin(embedWin, id, constructor) {\n  registerServiceInternal(\n    embedWin,\n    embedWin,\n    id,\n    constructor,\n    /* override */ true\n  );\n}\n\n/**\n * Registers a service given a class to be used as implementation.\n * @param {!Window} win\n * @param {string} id of the service.\n * @param {function(new:Object, !Window)} constructor\n * @param {boolean=} opt_instantiate Whether to immediately create the service\n */\nexport function registerServiceBuilder(win, id, constructor, opt_instantiate) {\n  win = getTopWindow(win);\n  registerServiceInternal(win, win, id, constructor);\n  if (opt_instantiate) {\n    getServiceInternal(win, id);\n  }\n}\n\n/**\n * Returns a service and registers it given a class to be used as\n * implementation.\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @param {string} id of the service.\n * @param {function(new:Object, !./service/ampdoc-impl.AmpDoc)} constructor\n * @param {boolean=} opt_instantiate Whether to immediately create the service\n */\nexport function registerServiceBuilderForDoc(\n  nodeOrDoc,\n  id,\n  constructor,\n  opt_instantiate\n) {\n  const ampdoc = getAmpdoc(nodeOrDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  registerServiceInternal(holder, ampdoc, id, constructor);\n  if (opt_instantiate) {\n    getServiceInternal(holder, id);\n  }\n}\n\n/**\n * Reject a service promise.\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @param {string} id\n * @param {*} error\n */\nexport function rejectServicePromiseForDoc(nodeOrDoc, id, error) {\n  const ampdoc = getAmpdoc(nodeOrDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  rejectServicePromiseInternal(holder, id, error);\n}\n\n/**\n * Returns a service for the given id and window (a per-window singleton). Users\n * should typically wrap this as a special purpose function (e.g.\n * `Services.vsyncFor(win)`) for type safety and because the factory should not\n * be passed around.\n * @param {!Window} win\n * @param {string} id of the service.\n * @template T\n * @return {T}\n */\nexport function getService(win, id) {\n  win = getTopWindow(win);\n  return getServiceInternal(win, id);\n}\n\n/**\n * Returns a service for the given id and window (a per-window singleton). But\n * it looks in the immediate window scope, not the top-level window.\n * @param {!Window} win\n * @param {string} id of the service.\n * @template T\n * @return {T}\n */\nexport function getServiceInEmbedWin(win, id) {\n  return getServiceInternal(win, id);\n}\n\n/**\n * Returns a promise for a service for the given id and window. Also expects an\n * element that has the actual implementation. The promise resolves when the\n * implementation loaded. Users should typically wrap this as a special purpose\n * function (e.g. `Services.vsyncFor(win)`) for type safety and because the\n * factory should not be passed around.\n * @param {!Window} win\n * @param {string} id of the service.\n * @return {!Promise<!Object>}\n */\nexport function getServicePromise(win, id) {\n  return getServicePromiseInternal(win, id);\n}\n\n/**\n * Returns a service or null with the given id.\n * @param {!Window} win\n * @param {string} id\n * @return {?Object} The service.\n */\nexport function getExistingServiceOrNull(win, id) {\n  win = getTopWindow(win);\n  if (isServiceRegistered(win, id)) {\n    return getServiceInternal(win, id);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Like getServicePromise but returns null if the service was never registered.\n * @param {!Window} win\n * @param {string} id\n * @return {?Promise<!Object>}\n */\nexport function getServicePromiseOrNull(win, id) {\n  return getServicePromiseOrNullInternal(win, id);\n}\n\n/**\n * Returns a service for the given id and ampdoc (a per-ampdoc singleton).\n * Expects service `id` to be registered.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {T}\n * @template T\n */\nexport function getServiceForDoc(elementOrAmpDoc, id) {\n  const ampdoc = getAmpdoc(elementOrAmpDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  return getServiceInternal(holder, id);\n}\n\n/**\n * Returns a service for the given id and ampdoc (a per-ampdoc singleton).\n * If service `id` is not registered, returns null.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {?Object}\n */\nexport function getServiceForDocOrNull(elementOrAmpDoc, id) {\n  const ampdoc = getAmpdoc(elementOrAmpDoc);\n  const holder = getAmpdocServiceHolder(ampdoc);\n  if (isServiceRegistered(holder, id)) {\n    return getServiceInternal(holder, id);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Returns a promise for a service for the given id and ampdoc. Also expects\n * a service that has the actual implementation. The promise resolves when\n * the implementation loaded.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {!Promise<!Object>}\n */\nexport function getServicePromiseForDoc(elementOrAmpDoc, id) {\n  return getServicePromiseInternal(getAmpdocServiceHolder(elementOrAmpDoc), id);\n}\n\n/**\n * Like getServicePromiseForDoc but returns null if the service was never\n * registered for this ampdoc.\n * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n * @param {string} id\n * @return {?Promise<!Object>}\n */\nexport function getServicePromiseOrNullForDoc(elementOrAmpDoc, id) {\n  return getServicePromiseOrNullInternal(\n    getAmpdocServiceHolder(elementOrAmpDoc),\n    id\n  );\n}\n\n/**\n * Set the parent and top windows on a child window (friendly iframe).\n * @param {!Window} win\n * @param {!Window} parentWin\n */\nexport function setParentWindow(win, parentWin) {\n  win.__AMP_PARENT = parentWin;\n  win.__AMP_TOP = getTopWindow(parentWin);\n}\n\n/**\n * Returns the parent window for a child window (friendly iframe).\n * @param {!Window} win\n * @return {!Window}\n */\nexport function getParentWindow(win) {\n  return win.__AMP_PARENT || win;\n}\n\n/**\n * Returns the top window where AMP Runtime is installed for a child window\n * (friendly iframe).\n * @param {!Window} win\n * @return {!Window}\n */\nexport function getTopWindow(win) {\n  return win.__AMP_TOP || (win.__AMP_TOP = win);\n}\n\n/**\n * Returns the parent \"friendly\" iframe if the node belongs to a child window.\n * @param {!Node} node\n * @param {!Window=} opt_topWin\n * @return {?HTMLIFrameElement}\n */\nexport function getParentWindowFrameElement(node, opt_topWin) {\n  const childWin = (node.ownerDocument || node).defaultView;\n  const topWin = opt_topWin || getTopWindow(childWin);\n  if (childWin && childWin != topWin && getTopWindow(childWin) == topWin) {\n    try {\n      return /** @type {?HTMLIFrameElement} */ (childWin.frameElement);\n    } catch (e) {\n      // Ignore the error.\n    }\n  }\n  return null;\n}\n\n/**\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @return {!./service/ampdoc-impl.AmpDoc}\n */\nexport function getAmpdoc(nodeOrDoc) {\n  if (nodeOrDoc.nodeType) {\n    const win = getWin(nodeOrDoc);\n    return getAmpdocService(win).getAmpDoc(/** @type {!Node} */ (nodeOrDoc));\n  }\n  return /** @type {!./service/ampdoc-impl.AmpDoc} */ (nodeOrDoc);\n}\n\n/**\n * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrDoc\n * @return {!./service/ampdoc-impl.AmpDoc|!Window}\n */\nfunction getAmpdocServiceHolder(nodeOrDoc) {\n  const ampdoc = getAmpdoc(nodeOrDoc);\n  return ampdoc.isSingleDoc() ? ampdoc.win : ampdoc;\n}\n\n/**\n * This is essentially a duplicate of `ampdoc.js`, but necessary to avoid\n * circular dependencies.\n * @param {!Window} win\n * @return {!./service/ampdoc-impl.AmpDocService}\n */\nfunction getAmpdocService(win) {\n  return /** @type {!./service/ampdoc-impl.AmpDocService} */ (\n    getService(win, 'ampdoc')\n  );\n}\n\n/**\n * Get service `id` from `holder`. Assumes the service\n * has already been registered.\n * @param {!Object} holder Object holding the service instance.\n * @param {string} id of the service.\n * @return {Object}\n */\nfunction getServiceInternal(holder, id) {\n  devAssert(\n    isServiceRegistered(holder, id),\n    `Expected service ${id} to be registered`\n  );\n  const services = getServices(holder);\n  const s = services[id];\n  if (!s.obj) {\n    devAssert(s.ctor, `Service ${id} registered without ctor nor impl.`);\n    devAssert(s.context, `Service ${id} registered without context.`);\n    s.obj = new s.ctor(s.context);\n    devAssert(s.obj, `Service ${id} constructed to null.`);\n    s.context = null;\n    // The service may have been requested already, in which case we have a\n    // pending promise we need to fulfill.\n    if (s.resolve) {\n      s.resolve(s.obj);\n    }\n  }\n  return s.obj;\n}\n\n/**\n * @param {!Object} holder Object holding the service instance.\n * @param {!Window|!./service/ampdoc-impl.AmpDoc} context Win or AmpDoc.\n * @param {string} id of the service.\n * @param {?function(new:Object, !Window)|?function(new:Object, !./service/ampdoc-impl.AmpDoc)} ctor Constructor function to new the service. Called with context.\n * @param {boolean=} opt_override\n * @param {boolean=} opt_sharedInstance\n */\nfunction registerServiceInternal(\n  holder,\n  context,\n  id,\n  ctor,\n  opt_override,\n  opt_sharedInstance\n) {\n  const services = getServices(holder);\n  let s = services[id];\n\n  if (!s) {\n    s = services[id] = {\n      obj: null,\n      promise: null,\n      resolve: null,\n      reject: null,\n      context: null,\n      ctor: null,\n      sharedInstance: opt_sharedInstance || false,\n    };\n  }\n\n  if (!opt_override && s.ctor) {\n    // Service already registered.\n    return;\n  }\n\n  s.ctor = ctor;\n  s.context = context;\n  s.sharedInstance = opt_sharedInstance || false;\n\n  // The service may have been requested already, in which case there is a\n  // pending promise that needs to fulfilled.\n  if (s.resolve) {\n    // getServiceInternal will resolve the promise.\n    getServiceInternal(holder, id);\n  }\n}\n\n/**\n * @param {!Object} holder\n * @param {string} id of the service.\n * @return {!Promise<!Object>}\n */\nfunction getServicePromiseInternal(holder, id) {\n  const cached = getServicePromiseOrNullInternal(holder, id);\n  if (cached) {\n    return cached;\n  }\n  // Service is not registered.\n\n  // TODO(@cramforce): Add a check that if the element is eventually registered\n  // that the service is actually provided and this promise resolves.\n  const services = getServices(holder);\n  services[id] = emptyServiceHolderWithPromise();\n  return /** @type {!Promise<!Object>} */ (services[id].promise);\n}\n\n/**\n * @param {!Object} holder\n * @param {string} id of the service.\n * @param {*} error\n */\nfunction rejectServicePromiseInternal(holder, id, error) {\n  const services = getServices(holder);\n  const s = services[id];\n  if (s) {\n    if (s.reject) {\n      s.reject(error);\n    }\n    return;\n  }\n\n  services[id] = emptyServiceHolderWithPromise();\n  services[id].reject(error);\n}\n\n/**\n * Returns a promise for service `id` if the service has been registered\n * on `holder`.\n * @param {!Object} holder\n * @param {string} id of the service.\n * @return {?Promise<!Object>}\n */\nfunction getServicePromiseOrNullInternal(holder, id) {\n  const services = getServices(holder);\n  const s = services[id];\n  if (s) {\n    if (s.promise) {\n      return s.promise;\n    } else {\n      // Instantiate service if not already instantiated.\n      getServiceInternal(holder, id);\n      return (s.promise = Promise.resolve(/** @type {!Object} */ (s.obj)));\n    }\n  }\n  return null;\n}\n\n/**\n * Returns the object that holds the services registered in a holder.\n * @param {!Object} holder\n * @return {!Object<string,!ServiceHolderDef>}\n */\nfunction getServices(holder) {\n  let services = holder.__AMP_SERVICES;\n  if (!services) {\n    services = holder.__AMP_SERVICES = {};\n  }\n  return services;\n}\n\n/**\n * Whether the specified service implements `Disposable` interface.\n * @param {!Object} service\n * @return {boolean}\n */\nexport function isDisposable(service) {\n  return typeof service.dispose == 'function';\n}\n\n/**\n * Asserts that the specified service implements `Disposable` interface and\n * typecasts the instance to `Disposable`.\n * @param {!Object} service\n * @return {!Disposable}\n */\nexport function assertDisposable(service) {\n  devAssert(isDisposable(service), 'required to implement Disposable');\n  return /** @type {!Disposable} */ (service);\n}\n\n/**\n * Disposes all disposable (implements `Disposable` interface) services in\n * ampdoc scope.\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n */\nexport function disposeServicesForDoc(ampdoc) {\n  disposeServicesInternal(ampdoc);\n}\n\n/**\n * Disposes all disposable (implements `Disposable` interface) services in\n * embed scope.\n * @param {!Window} embedWin\n */\nexport function disposeServicesForEmbed(embedWin) {\n  disposeServicesInternal(embedWin);\n}\n\n/**\n * @param {!Object} holder Object holding the service instances.\n */\nfunction disposeServicesInternal(holder) {\n  const services = getServices(holder);\n  for (const id in services) {\n    if (!Object.prototype.hasOwnProperty.call(services, id)) {\n      continue;\n    }\n    const serviceHolder = services[id];\n    if (serviceHolder.sharedInstance) {\n      continue;\n    }\n    if (serviceHolder.obj) {\n      disposeServiceInternal(id, serviceHolder.obj);\n    } else if (serviceHolder.promise) {\n      serviceHolder.promise.then((instance) =>\n        disposeServiceInternal(id, instance)\n      );\n    }\n  }\n}\n\n/**\n * @param {string} id\n * @param {!Object} service\n */\nfunction disposeServiceInternal(id, service) {\n  if (!isDisposable(service)) {\n    return;\n  }\n  try {\n    assertDisposable(service).dispose();\n  } catch (e) {\n    // Ensure that a failure to dispose a service does not disrupt other\n    // services.\n    dev().error('SERVICE', 'failed to dispose service', id, e);\n  }\n}\n\n/**\n * This adopts the service **instance** from the parent.\n *\n * This function is dangerous! Sharing an instance means data can leak to and\n * from a child ampdoc.\n *\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {string} id\n */\nexport function adoptServiceForEmbedDoc(ampdoc, id) {\n  const service = getServiceInternal(\n    getAmpdocServiceHolder(devAssert(ampdoc.getParent())),\n    id\n  );\n  registerServiceInternal(\n    getAmpdocServiceHolder(ampdoc),\n    ampdoc,\n    id,\n    function () {\n      return service;\n    },\n    /* override */ false,\n    /* sharedInstance */ true\n  );\n}\n\n/**\n * This adopts the service **factory** from the parent.\n *\n * This function is safer than sharing the service instance, since each ampdoc\n * will create its own instance of the factory (and each instance will have its\n * own instance data). Note that static data is still shared, so it's not 100%\n * foolproof.\n *\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc\n * @param {string} id\n */\nexport function adoptServiceFactoryForEmbedDoc(ampdoc, id) {\n  const parentHolder = getAmpdocServiceHolder(devAssert(ampdoc.getParent()));\n  devAssert(\n    isServiceRegistered(parentHolder, id),\n    `Expected service ${id} to be registered`\n  );\n  const service = getServices(parentHolder)[id];\n  registerServiceInternal(\n    getAmpdocServiceHolder(ampdoc),\n    ampdoc,\n    id,\n    devAssert(service.ctor)\n  );\n}\n\n/**\n * Resets a single service, so it gets recreated on next getService invocation.\n * @param {!Object} holder\n * @param {string} id of the service.\n */\nexport function resetServiceForTesting(holder, id) {\n  if (holder.__AMP_SERVICES) {\n    holder.__AMP_SERVICES[id] = null;\n  }\n}\n\n/**\n * @param {!Object} holder Object holding the service instance.\n * @param {string} id of the service.\n * @return {boolean}\n */\nfunction isServiceRegistered(holder, id) {\n  const service = holder.__AMP_SERVICES && holder.__AMP_SERVICES[id];\n  // All registered services must have a constructor.\n  return !!(service && service.ctor);\n}\n\n/** @return {!ServiceHolderDef} */\nfunction emptyServiceHolderWithPromise() {\n  const deferred = new Deferred();\n  const {promise, reject, resolve} = deferred;\n  promise.catch(() => {}); // avoid uncaught exception when service gets rejected\n  return {\n    obj: null,\n    promise,\n    resolve,\n    reject,\n    context: null,\n    ctor: null,\n  };\n}\n", "import * as dom from '#core/dom';\n\nimport {extensionScriptInNode} from '#service/extension-script';\n\nimport {userAssert} from '#utils/log';\n\nimport {\n  getAmpdoc,\n  getService,\n  getServiceForDocOrNull,\n  getServicePromise,\n  getServicePromiseForDoc,\n  getServicePromiseOrNull,\n  getServicePromiseOrNullForDoc,\n} from './service-helpers';\n\n/**\n * Same as getElementService but produces null if the given element is not\n * actually available on the current page.\n * @param {!Window} win\n * @param {string} id of the service.\n * @param {string} extension Name of the custom extension that provides the\n *     implementation of this service.\n * @param {string} version The extension version.\n * @param {boolean=} opt_element Whether this service is provided by an\n *     element, not the extension.\n * @return {!Promise<?Object>}\n */\nexport function getElementServiceIfAvailable(\n  win,\n  id,\n  extension,\n  version,\n  opt_element\n) {\n  const s = getServicePromiseOrNull(win, id);\n  if (s) {\n    return /** @type {!Promise<?Object>} */ (s);\n  }\n  return getElementServicePromiseOrNull(\n    win,\n    id,\n    extension,\n    version,\n    opt_element\n  );\n}\n\n/**\n * Returns a promise for a service for the given id and window. Also expects an\n * element that has the actual implementation. The promise resolves when the\n * implementation loaded. Users should typically wrap this as a special purpose\n * function (e.g. Services.viewportForDoc(...)) for type safety and because the\n * factory should not be passed around.\n * @param {!Element|!ShadowRoot} element\n * @param {string} id of the service.\n * @param {string} extension Name of the custom extension that provides the\n *     implementation of this service.\n * @param {boolean=} opt_element Whether this service is provided by an element,\n *     not the extension.\n * @return {!Promise<*>}\n */\nexport function getElementServiceForDoc(element, id, extension, opt_element) {\n  return getElementServiceIfAvailableForDoc(\n    element,\n    id,\n    extension,\n    opt_element\n  ).then((service) => assertService(service, id, extension));\n}\n\n/**\n * Same as getElementService but produces null if the given element is not\n * actually available on the current page.\n * @param {!Element|!ShadowRoot} element\n * @param {string} id of the service.\n * @param {string} extension Name of the custom extension that provides the\n *     implementation of this service.\n * @param {boolean=} opt_element Whether this service is provided by an\n *     element, not the extension.\n * @return {!Promise<?Object>}\n */\nexport function getElementServiceIfAvailableForDoc(\n  element,\n  id,\n  extension,\n  opt_element\n) {\n  const s = getServicePromiseOrNullForDoc(element, id);\n  if (s) {\n    return /** @type {!Promise<?Object>} */ (s);\n  }\n  const ampdoc = getAmpdoc(element);\n  return ampdoc\n    .whenExtensionsKnown()\n    .then(() => {\n      const version = ampdoc.getExtensionVersion(extension);\n      if (!version) {\n        return null;\n      }\n      const extensions = getService(ampdoc.win, 'extensions');\n      return extensions.waitForExtension(extension, version);\n    })\n    .then((ext) => {\n      if (!ext) {\n        return null;\n      }\n      // If this service is provided by an element, then we can't depend on\n      // the service (they may not use the element).\n      if (opt_element) {\n        return getServicePromiseOrNullForDoc(element, id);\n      }\n      return getServicePromiseForDoc(element, id);\n    });\n}\n\n/**\n * Returns a promise for service for the given id in the embed scope of\n * a given element, if it exists. Falls back to ampdoc scope if the element\n * is not embedded.\n *\n * @param {!Element|!ShadowRoot} element\n * @param {string} id of the service.\n * @param {string} extension Name of the custom element that provides\n *     the implementation of this service.\n * @return {!Promise<?Object>}\n */\nexport function getElementServiceIfAvailableForDocInEmbedScope(\n  element,\n  id,\n  extension\n) {\n  const s = getServiceForDocOrNull(element, id);\n  if (s) {\n    return /** @type {!Promise<?Object>} */ (Promise.resolve(s));\n  }\n  return getElementServiceIfAvailableForDoc(element, id, extension);\n}\n\n/**\n * Throws user error if `service` is null.\n * @param {Object} service\n * @param {string} id\n * @param {string} extension\n * @return {!Object}\n * @private\n * @closurePrimitive {asserts.matchesReturn}\n */\nfunction assertService(service, id, extension) {\n  return /** @type {!Object} */ (\n    userAssert(\n      service,\n      'Service %s was requested to be provided through %s, ' +\n        'but %s is not loaded in the current page. To fix this ' +\n        'problem load the JavaScript file for %s in this page.',\n      id,\n      extension,\n      extension,\n      extension\n    )\n  );\n}\n\n/**\n * Returns the promise for service with `id` on the given window if available.\n * Otherwise, resolves with null (service was not registered).\n * @param {!Window} win\n * @param {string} id\n * @param {string} extension\n * @param {string} version\n * @param {boolean=} opt_element\n * @return {!Promise<Object>}\n * @private\n */\nfunction getElementServicePromiseOrNull(\n  win,\n  id,\n  extension,\n  version,\n  opt_element\n) {\n  return dom\n    .waitForBodyOpenPromise(win.document)\n    .then(() => {\n      // If there is an extension script wait for it to load before trying\n      // to get the service. Prevents a race condition when everything but\n      // the extensions is in cache. If there is no script then it's either\n      // not present, or the service was defined by a test. In those cases\n      // we don't wait around for an extension that does not exist.\n      const extensions = getService(win, 'extensions');\n\n      // TODO(jpettitt) investigate registerExtension to short circuit\n      // the dom call in extensionScriptsInNode()\n      if (!extensionScriptInNode(extensions.win, extension, version)) {\n        return null;\n      }\n      return extensions.waitForExtension(extension, version);\n    })\n    .then((ext) => {\n      if (!ext) {\n        return null;\n      }\n      // If this service is provided by an element, then we can't depend on\n      // the service (they may not use the element).\n      if (opt_element) {\n        return getServicePromiseOrNull(win, id);\n      }\n      return getServicePromise(win, id);\n    });\n}\n", "import {\n  getElementServiceForDoc,\n  getElementServiceIfAvailable,\n  getElementServiceIfAvailableForDoc,\n  getElementServiceIfAvailableForDocInEmbedScope,\n} from '../element-service';\nimport {\n  getAmpdoc,\n  getExistingServiceOrNull,\n  getService,\n  getServiceForDoc,\n  getServiceForDocOrNull,\n  getServiceInEmbedWin,\n  getServicePromiseForDoc,\n} from '../service-helpers';\n\n/** @typedef {!../extensions/amp-subscriptions/0.1/amp-subscriptions.SubscriptionService} */\nexport let SubscriptionService;\n\nexport class Services {\n  /**\n   * Hint: Add extensions folder path to compile.js with\n   * warnings cannot find modules.\n   */\n\n  /**\n   * Returns a promise for the Access service.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-access/0.1/amp-access.AccessService>}\n   */\n  static accessServiceForDoc(element) {\n    return /** @type {!Promise<!../extensions/amp-access/0.1/amp-access.AccessService>} */ (\n      getElementServiceForDoc(element, 'access', 'amp-access')\n    );\n  }\n\n  /**\n   * Returns a promise for the Access service or a promise for null if the\n   * service is not available on the current page.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-access/0.1/amp-access.AccessService>}\n   */\n  static accessServiceForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-access/0.1/amp-access.AccessService>} */ (\n      getElementServiceIfAvailableForDoc(element, 'access', 'amp-access')\n    );\n  }\n\n  /**\n   * Returns a promise for the Subscriptions service.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!SubscriptionService>}\n   */\n  static subscriptionsServiceForDoc(element) {\n    return /** @type {!Promise<!SubscriptionService>} */ (\n      getElementServiceForDoc(element, 'subscriptions', 'amp-subscriptions')\n    );\n  }\n\n  /**\n   * Returns a promise for the Subscriptions service.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?SubscriptionService>}\n   */\n  static subscriptionsServiceForDocOrNull(element) {\n    return /** @type {!Promise<?SubscriptionService>} */ (\n      getElementServiceIfAvailableForDoc(\n        element,\n        'subscriptions',\n        'amp-subscriptions'\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/action-impl.ActionService}\n   */\n  static actionServiceForDoc(element) {\n    return /** @type {!./service/action-impl.ActionService} */ (\n      getServiceForDocOrNull(element, 'action')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/standard-actions-impl.StandardActions}\n   */\n  static standardActionsForDoc(element) {\n    return /** @type {!./service/standard-actions-impl.StandardActions} */ (\n      getServiceForDocOrNull(element, 'standard-actions')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-analytics/0.1/activity-impl.Activity>}\n   */\n  static activityForDoc(element) {\n    return /** @type {!Promise<!../extensions/amp-analytics/0.1/activity-impl.Activity>} */ (\n      getElementServiceForDoc(element, 'activity', 'amp-analytics')\n    );\n  }\n\n  /**\n   * Returns the global instance of the `AmpDocService` service that can be\n   * used to resolve an ampdoc for any node: either in the single-doc or\n   * shadow-doc environment.\n   * @param {!Window} window\n   * @return {!./service/ampdoc-impl.AmpDocService}\n   */\n  static ampdocServiceFor(window) {\n    return /** @type {!./service/ampdoc-impl.AmpDocService} */ (\n      getService(window, 'ampdoc')\n    );\n  }\n\n  /**\n   * Returns the AmpDoc for the specified context node.\n   * @param {!Node|!./service/ampdoc-impl.AmpDoc} nodeOrAmpDoc\n   * @return {!./service/ampdoc-impl.AmpDoc}\n   */\n  static ampdoc(nodeOrAmpDoc) {\n    return getAmpdoc(nodeOrAmpDoc);\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @param {boolean=} loadAnalytics\n   * @return {!Promise<!../extensions/amp-analytics/0.1/instrumentation.InstrumentationService>}\n   */\n  static analyticsForDoc(element, loadAnalytics = false) {\n    if (loadAnalytics) {\n      // Get Extensions service and force load analytics extension.\n      const ampdoc = getAmpdoc(element);\n      Services.extensionsFor(ampdoc.win)./*OK*/ installExtensionForDoc(\n        ampdoc,\n        'amp-analytics'\n      );\n    }\n    return /** @type {!Promise<!../extensions/amp-analytics/0.1/instrumentation.InstrumentationService>} */ (\n      getElementServiceForDoc(\n        element,\n        'amp-analytics-instrumentation',\n        'amp-analytics'\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-analytics/0.1/instrumentation.InstrumentationService>}\n   */\n  static analyticsForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-analytics/0.1/instrumentation.InstrumentationService>} */ (\n      getElementServiceIfAvailableForDoc(\n        element,\n        'amp-analytics-instrumentation',\n        'amp-analytics'\n      )\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/batched-xhr-impl.BatchedXhr}\n   */\n  static batchedXhrFor(window) {\n    return /** @type {!./service/batched-xhr-impl.BatchedXhr} */ (\n      getService(window, 'batched-xhr')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-bind/0.1/bind-impl.Bind>}\n   */\n  static bindForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-bind/0.1/bind-impl.Bind>} */ (\n      getElementServiceIfAvailableForDocInEmbedScope(\n        element,\n        'bind',\n        'amp-bind'\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-script/0.1/amp-script.AmpScriptService>}\n   */\n  static scriptForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-script/0.1/amp-script.AmpScriptService>} */ (\n      getElementServiceIfAvailableForDocInEmbedScope(\n        element,\n        'amp-script',\n        'amp-script'\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/cid-impl.CidDef>}\n   */\n  static cidForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/cid-impl.CidDef>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'cid')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/navigation.Navigation}\n   */\n  static navigationForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/navigation.Navigation} */ (\n      getServiceForDoc(elementOrAmpDoc, 'navigation')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-loader/0.1/amp-loader.LoaderService>}\n   */\n  static loaderServiceForDoc(element) {\n    return /** @type {!Promise<!../extensions/amp-loader/0.1/amp-loader.LoaderService>} */ (\n      getElementServiceForDoc(element, 'loader', 'amp-loader')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-standalone/0.1/amp-standalone.StandaloneService>}\n   */\n  static standaloneServiceForDoc(element) {\n    return /** @type {!Promise<!../extensions/amp-standalone/0.1/amp-standalone.StandaloneService>} */ (\n      getElementServiceForDoc(element, 'standalone', 'amp-standalone')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/crypto-impl.Crypto}\n   */\n  static cryptoFor(window) {\n    return /** @type {!./service/crypto-impl.Crypto} */ (\n      getService(window, 'crypto')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/document-info-impl.DocumentInfoDef} Info about the doc\n   */\n  static documentInfoForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/document-info-impl.DocInfo} */ (\n      getServiceForDoc(elementOrAmpDoc, 'documentInfo')\n    ).get();\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/extensions-impl.Extensions}\n   */\n  static extensionsFor(window) {\n    return /** @type {!./service/extensions-impl.Extensions} */ (\n      getService(window, 'extensions')\n    );\n  }\n\n  /**\n   * Returns a service to register callbacks we wish to execute when an\n   * amp-form is submitted.\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<../extensions/amp-form/0.1/form-submit-service.FormSubmitService>}\n   */\n  static formSubmitForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<../extensions/amp-form/0.1/form-submit-service.FormSubmitService>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'form-submit-service')\n    );\n  }\n\n  /**\n   * Returns service to listen for `hidden` attribute mutations.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/hidden-observer-impl.HiddenObserver}\n   */\n  static hiddenObserverForDoc(element) {\n    return /** @type {!./service/hidden-observer-impl.HiddenObserver} */ (\n      getServiceForDocOrNull(element, 'hidden-observer')\n    );\n  }\n\n  /**\n   * Returns service implemented in service/history-impl.\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/history-impl.History}\n   */\n  static historyForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/history-impl.History} */ (\n      getServiceForDoc(elementOrAmpDoc, 'history')\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {!./input.Input}\n   */\n  static inputFor(win) {\n    return getService(win, 'input');\n  }\n\n  /**s\n   * Returns a promise for the Inputmask service.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-inputmask/0.1/amp-inputmask.AmpInputmaskService>}\n   */\n  static inputmaskServiceForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-inputmask/0.1/amp-inputmask.AmpInputmaskService>} */ (\n      getElementServiceIfAvailableForDoc(element, 'inputmask', 'amp-inputmask')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {?./service/loading-indicator.LoadingIndicatorImpl}\n   */\n  static loadingIndicatorOrNull(elementOrAmpDoc) {\n    return /** @type {?./service/loading-indicator.LoadingIndicatorImpl} */ (\n      getServiceForDocOrNull(elementOrAmpDoc, 'loadingIndicator')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!../extensions/amp-next-page/1.0/service.NextPageService}\n   */\n  static nextPageServiceForDoc(elementOrAmpDoc) {\n    return /** @type {!../extensions/amp-next-page/1.0/service.NextPageService} */ (\n      getServiceForDoc(elementOrAmpDoc, 'next-page')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/mutator-interface.MutatorInterface}\n   */\n  static mutatorForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/mutator-interface.MutatorInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'mutator')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/owners-interface.OwnersInterface}\n   */\n  static ownersForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/owners-interface.OwnersInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'owners')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/performance-impl.Performance}\n   */\n  static performanceFor(window) {\n    return /** @type {!./service/performance-impl.Performance}*/ (\n      getService(window, 'performance')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/performance-impl.Performance}\n   */\n  static performanceForOrNull(window) {\n    return /** @type {!./service/performance-impl.Performance}*/ (\n      getExistingServiceOrNull(window, 'performance')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/platform-impl.Platform}\n   */\n  static platformFor(window) {\n    return /** @type {!./service/platform-impl.Platform} */ (\n      getService(window, 'platform')\n    );\n  }\n\n  /**\n   * Not installed by default; must be installed in extension code before use.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/position-observer/position-observer-impl.PositionObserver}\n   * @throws If the service is not installed.\n   */\n  static positionObserverForDoc(element) {\n    return /** @type {!./service/position-observer/position-observer-impl.PositionObserver} */ (\n      getServiceForDoc(element, 'position-observer')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./preconnect.PreconnectService}\n   */\n  static preconnectFor(window) {\n    return getService(window, 'preconnect');\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/resources-interface.ResourcesInterface}\n   */\n  static resourcesForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/resources-interface.ResourcesInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'resources')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/resources-interface.ResourcesInterface>}\n   */\n  static resourcesPromiseForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/resources-interface.ResourcesInterface>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'resources')\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?Promise<?../extensions/amp-story/1.0/variable-service.AmpStoryVariableService>}\n   */\n  static storyVariableServiceForOrNull(win) {\n    return (\n      /** @type {!Promise<?../extensions/amp-story/1.0/variable-service.AmpStoryVariableService>} */\n      (getElementServiceIfAvailable(win, 'story-variable', 'amp-story', '1.0'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/variable-service.AmpStoryVariableService}\n   */\n  static storyVariableService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/variable-service.AmpStoryVariableService} */\n      (getExistingServiceOrNull(win, 'story-variable'))\n    );\n  }\n\n  /**\n   * Version of the story store service depends on which version of amp-story\n   * the publisher is loading. They all have the same implementation.\n   * @param {!Window} win\n   * @return {?Promise<?../extensions/amp-story/1.0/amp-story-store-service.AmpStoryStoreService>}\n   */\n  static storyStoreServiceForOrNull(win) {\n    return (\n      /** @type {!Promise<?../extensions/amp-story/1.0/amp-story-store-service.AmpStoryStoreService>} */\n      (getElementServiceIfAvailable(win, 'story-store', 'amp-story', '1.0'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/amp-story-store-service.AmpStoryStoreService}\n   */\n  static storyStoreService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/amp-story-store-service.AmpStoryStoreService} */\n      (getExistingServiceOrNull(win, 'story-store'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/amp-story-media-query-service.AmpStoryMediaQueryService}\n   */\n  static storyMediaQueryService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/amp-story-media-query-service.AmpStoryMediaQueryService} */\n      (getExistingServiceOrNull(win, 'story-media-query'))\n    );\n  }\n\n  /**\n   * Get promise with story request service\n   * @param {!Window} win\n   * @return {?Promise<?../extensions/amp-story/1.0/amp-story-request-service.AmpStoryRequestService>}\n   */\n  static storyRequestServiceForOrNull(win) {\n    return (\n      /** @type {!Promise<?../extensions/amp-story/1.0/amp-story-request-service.AmpStoryRequestService>} */\n      (getElementServiceIfAvailable(win, 'story-request', 'amp-story', '1.0'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/amp-story-request-service.AmpStoryRequestService}\n   */\n  static storyRequestService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/amp-story-request-service.AmpStoryRequestService} */\n      (getExistingServiceOrNull(win, 'story-request'))\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/media-performance-metrics-service.MediaPerformanceMetricsService}\n   */\n  static mediaPerformanceMetricsService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/media-performance-metrics-service.MediaPerformanceMetricsService} */\n      (getExistingServiceOrNull(win, 'media-performance-metrics'))\n    );\n  }\n\n  /**\n   * @param {!Element} el\n   * @return {!Promise<./service/localization.LocalizationService>}\n   */\n  static localizationServiceForOrNull(el) {\n    return /** @type {!Promise<?./service/localization.LocalizationService>} */ (\n      getServicePromiseForDoc(el, 'localization')\n    );\n  }\n\n  /**\n   * @param {!Element} element\n   * @return {?./service/localization.LocalizationService}\n   */\n  static localizationForDoc(element) {\n    return /** @type {?./service/localization.LocalizationService} */ (\n      getServiceForDocOrNull(element, 'localization')\n    );\n  }\n\n  /**\n   * TODO(#14357): Remove this when amp-story:0.1 is deprecated.\n   * @param {!Window} win\n   * @return {!Promise<?../extensions/amp-story/1.0/story-analytics.StoryAnalyticsService>}\n   */\n  static storyAnalyticsServiceForOrNull(win) {\n    return (\n      /** @type {!Promise<?../extensions/amp-story/1.0/story-analytics.StoryAnalyticsService>} */\n      (\n        getElementServiceIfAvailable(\n          win,\n          'story-analytics',\n          'amp-story',\n          '1.0',\n          true\n        )\n      )\n    );\n  }\n\n  /**\n   * @param {!Window} win\n   * @return {?../extensions/amp-story/1.0/story-analytics.StoryAnalyticsService}\n   */\n  static storyAnalyticsService(win) {\n    return (\n      /** @type {?../extensions/amp-story/1.0/story-analytics.StoryAnalyticsService} */\n      (getExistingServiceOrNull(win, 'story-analytics'))\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-animation/0.1/web-animation-service.WebAnimationService>}\n   */\n  static webAnimationServiceFor(element) {\n    return (\n      /** @type {!Promise<!../extensions/amp-animation/0.1/web-animation-service.WebAnimationService>} */\n      (getElementServiceForDoc(element, 'web-animation', 'amp-animation'))\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/real-time-config/real-time-config-impl.RealTimeConfigManager>}\n   */\n  static realTimeConfigForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/real-time-config/real-time-config-impl.RealTimeConfigManager>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'real-time-config')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/storage-impl.Storage>}\n   */\n  static storageForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/storage-impl.Storage>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'storage')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/storage-impl.Storage>}\n   * TODO(dmanek): Add tests for this method.\n   */\n  static storageForTopLevelDoc(elementOrAmpDoc) {\n    const thisAmpdoc = Services.ampdoc(elementOrAmpDoc);\n    const ampdocService = Services.ampdocServiceFor(thisAmpdoc.win);\n    const topAmpdoc = ampdocService.isSingleDoc()\n      ? ampdocService.getSingleDoc()\n      : null;\n    // We need to verify that ampdocs are on the same origin, therefore\n    // we compare the windows of both.\n    const ampdoc =\n      topAmpdoc && topAmpdoc.win == thisAmpdoc.win ? topAmpdoc : thisAmpdoc;\n    return /** @type {!Promise<!./service/storage-impl.Storage>} */ (\n      getServicePromiseForDoc(ampdoc, 'storage')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/template-impl.Templates}\n   */\n  static templatesForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/template-impl.Templates} */ (\n      getServiceForDoc(elementOrAmpDoc, 'templates')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/timer-impl.Timer}\n   */\n  static timerFor(window) {\n    // TODO(alabiaga): This will always return the top window's Timer service.\n    return /** @type {!./service/timer-impl.Timer} */ (\n      getServiceInEmbedWin(window, 'timer')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/url-replacements-impl.UrlReplacements}\n   */\n  static urlReplacementsForDoc(element) {\n    return /** @type {!./service/url-replacements-impl.UrlReplacements} */ (\n      getServiceForDocOrNull(element, 'url-replace')\n    );\n  }\n\n  /**\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<!../extensions/amp-user-notification/0.1/amp-user-notification.UserNotificationManager>}\n   */\n  static userNotificationManagerForDoc(element) {\n    return (\n      /** @type {!Promise<!../extensions/amp-user-notification/0.1/amp-user-notification.UserNotificationManager>} */\n      (\n        getElementServiceForDoc(\n          element,\n          'userNotificationManager',\n          'amp-user-notification'\n        )\n      )\n    );\n  }\n\n  /**\n   * Returns a promise for the consentPolicy Service or a promise for null if\n   * the service is not available on the current page.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-consent/0.1/consent-policy-manager.ConsentPolicyManager>}\n   */\n  static consentPolicyServiceForDocOrNull(element) {\n    return (\n      /** @type {!Promise<?../extensions/amp-consent/0.1/consent-policy-manager.ConsentPolicyManager>} */\n      (\n        getElementServiceIfAvailableForDoc(\n          element,\n          'consentPolicyManager',\n          'amp-consent'\n        )\n      )\n    );\n  }\n\n  /**\n   * Returns a promise for the geo service or a promise for null if\n   * the service is not available on the current page.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-geo/0.1/amp-geo.GeoDef>}\n   */\n  static geoForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-geo/0.1/amp-geo.GeoDef>} */ (\n      getElementServiceIfAvailableForDoc(element, 'geo', 'amp-geo', true)\n    );\n  }\n\n  /**\n   * Unlike most service getters, passing `Node` is necessary for some FIE-scope\n   * services since sometimes we only have the FIE Document for context.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!./service/url-impl.Url}\n   */\n  static urlForDoc(element) {\n    return /** @type {!./service/url-impl.Url} */ (\n      getServiceForDocOrNull(element, 'url')\n    );\n  }\n\n  /**\n   * Returns a promise for the experiment variants or a promise for null if it\n   * is not available on the current page.\n   * @param {!Element|!ShadowRoot} element\n   * @return {!Promise<?../extensions/amp-experiment/0.1/variant.Variants>}\n   */\n  static variantsForDocOrNull(element) {\n    return /** @type {!Promise<?../extensions/amp-experiment/0.1/variant.Variants>} */ (\n      getElementServiceIfAvailableForDoc(\n        element,\n        'variant',\n        'amp-experiment',\n        true\n      )\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/video-manager-impl.VideoManager}\n   */\n  static videoManagerForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/video-manager-impl.VideoManager} */ (\n      getServiceForDoc(elementOrAmpDoc, 'video-manager')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/viewer-interface.ViewerInterface}\n   */\n  static viewerForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/viewer-interface.ViewerInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'viewer')\n    );\n  }\n\n  /**\n   * Returns promise for the viewer. This is an unusual case and necessary only\n   * for services that need reference to the viewer before it has been\n   * initialized. Most of the code, however, just should use `viewerForDoc`.\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<!./service/viewer-interface.ViewerInterface>}\n   */\n  static viewerPromiseForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<!./service/viewer-interface.ViewerInterface>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'viewer')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/vsync-impl.Vsync}\n   */\n  static vsyncFor(window) {\n    return /** @type {!./service/vsync-impl.Vsync} */ (\n      getService(window, 'vsync')\n    );\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!./service/viewport/viewport-interface.ViewportInterface}\n   */\n  static viewportForDoc(elementOrAmpDoc) {\n    return /** @type {!./service/viewport/viewport-interface.ViewportInterface} */ (\n      getServiceForDoc(elementOrAmpDoc, 'viewport')\n    );\n  }\n\n  /**\n   * @param {!Window} window\n   * @return {!./service/xhr-impl.Xhr}\n   */\n  static xhrFor(window) {\n    return /** @type {!./service/xhr-impl.Xhr} */ (getService(window, 'xhr'));\n  }\n\n  /**\n   * @param {!Element|!./service/ampdoc-impl.AmpDoc} elementOrAmpDoc\n   * @return {!Promise<../amp-cache-url/amp-cache-url.AmpCacheUrlService>}\n   */\n  static cacheUrlServicePromiseForDoc(elementOrAmpDoc) {\n    return /** @type {!Promise<?../amp-cache-url/amp-cache-url.AmpCacheUrlService>} */ (\n      getServicePromiseForDoc(elementOrAmpDoc, 'cache-url')\n    );\n  }\n}\n", "import {devAssert} from '#core/assert';\n\n/**\n * Key string in an action arguments map for an unparsed object literal string.\n *\n * E.g. for the action in <p on=\"tap:AMP.setState({foo: 'bar'})\",\n * then `args[RAW_OBJECT_ARGS_KEY]` is the string \"{foo: 'bar'}\".\n *\n * The action service delegates parsing of object literals to the corresponding\n * extension (in the example above, amp-bind).\n *\n * @see ./service/action-impl.ActionInfoDef\n * @const {string}\n */\nexport const RAW_OBJECT_ARGS_KEY = '__AMP_OBJECT_STRING__';\n\n/**\n * Identifier for an element's default action.\n *\n * @const {string}\n */\nexport const DEFAULT_ACTION = 'activate';\n\n/**\n * Corresponds to degree of user intent, i.e. events triggered with strong\n * user intent have high trust.\n *\n * @enum {number}\n */\nexport const ActionTrust = {\n  /**\n   * Events that are triggered without a user gesture, or triggered by a user\n   * gesture with weak intent (e.g. scroll) are \"low trust\".\n   *\n   * Actions that have low impact on the page's visual state should require\n   * \"low trust\" (e.g. pausing a video).\n   */\n  LOW: 1,\n  /**\n   * Events that are triggered nearly immediately (up to a few seconds) after\n   * a user gesture with strong intent (e.g. tap or swipe) are \"default trust\".\n   *\n   * Actions that can modify the page's visual state (e.g. content jumping)\n   * should require \"default trust\". This is the default required trust level\n   * for actions.\n   */\n  DEFAULT: 2,\n  /**\n   * Events that are triggered immediately after a user gesture with\n   * strong intent (e.g. tap or swipe) are \"high trust\".\n   *\n   * There are no actions yet that require high trust.\n   */\n  HIGH: 3,\n};\n\n/**\n * @param {!ActionTrust} actionTrust\n * @return {string}\n */\nexport function actionTrustToString(actionTrust) {\n  switch (actionTrust) {\n    case ActionTrust.LOW:\n      return 'low';\n    case ActionTrust.HIGH:\n      return 'high';\n    default:\n      devAssert(actionTrust === ActionTrust.DEFAULT);\n      return 'default';\n  }\n}\n", "import {isIframed} from '#core/dom';\nimport {removeItem} from '#core/types/array';\nimport {getWin} from '#core/window';\n\n/**\n * Returns an IntersectionObserver tracking the Viewport.\n *\n * @param {function(!Array<!IntersectionObserverEntry>)} ioCallback\n * @param {!Window} win\n * @param {{\n *   threshold: (number|!Array<number>|undefined),\n *   needsRootBounds: (boolean|undefined),\n * }=} opts\n * @return {!IntersectionObserver}\n */\nexport function createViewportObserver(ioCallback, win, opts = {}) {\n  const {needsRootBounds, threshold} = opts;\n  // The Document -> Element type conversion is necessary to satisfy the\n  // `IntersectionObserver` constructor extern that only accepts `Element`.\n  const root =\n    isIframed(win) && needsRootBounds\n      ? /** @type {?} */ (win.document)\n      : undefined;\n  return new win.IntersectionObserver(ioCallback, {\n    threshold,\n    root,\n  });\n}\n\n/** @type {!WeakMap<!Window, !IntersectionObserver>} */\nconst viewportObservers = new WeakMap();\n\n/** @type {!WeakMap<!Element, !Array<function(IntersectionObserverEntry)>>} */\nconst viewportCallbacks = new WeakMap();\n\n/**\n * Lazily creates an IntersectionObserver per Window to track when elements\n * enter and exit the viewport. Fires viewportCallback when this happens.\n *\n * @param {!Element} element\n * @param {function(IntersectionObserverEntry)} callback\n * @return {!UnlistenDef} clean up closure to unobserve the element\n */\nexport function observeIntersections(element, callback) {\n  const win = getWin(element);\n  let viewportObserver = viewportObservers.get(win);\n  if (!viewportObserver) {\n    viewportObservers.set(\n      win,\n      (viewportObserver = createViewportObserver(ioCallback, win))\n    );\n  }\n  let callbacks = viewportCallbacks.get(element);\n  if (!callbacks) {\n    callbacks = [];\n    viewportCallbacks.set(element, callbacks);\n  }\n  callbacks.push(callback);\n  viewportObserver.observe(element);\n  return () => {\n    unobserveIntersections(element, callback);\n  };\n}\n\n/**\n * Unsubscribes a callback from receiving IntersectionObserver updates for an element.\n *\n * @param {!Element} element\n * @param {function(IntersectionObserverEntry)} callback\n */\nfunction unobserveIntersections(element, callback) {\n  const callbacks = viewportCallbacks.get(element);\n  if (!callbacks) {\n    return;\n  }\n  if (!removeItem(callbacks, callback)) {\n    return;\n  }\n  if (callbacks.length) {\n    return;\n  }\n  // If an element has no more observer callbacks, then unobserve it.\n  const win = getWin(element);\n  const viewportObserver = viewportObservers.get(win);\n  viewportObserver?.unobserve(element);\n  viewportCallbacks.delete(element);\n}\n\n/**\n * Call the registered callbacks for each element that has crossed the\n * viewport boundary.\n *\n * @param {!Array<!IntersectionObserverEntry>} entries\n */\nfunction ioCallback(entries) {\n  const seen = new Set();\n  for (let i = entries.length - 1; i >= 0; i--) {\n    const entry = entries[i];\n    const {target} = entry;\n    if (seen.has(target)) {\n      continue;\n    }\n    seen.add(target);\n    const callbacks = viewportCallbacks.get(target);\n    if (!callbacks) {\n      continue;\n    }\n    for (let k = 0; k < callbacks.length; k++) {\n      const callback = callbacks[k];\n      callback(entry);\n    }\n  }\n}\n", "import {Deferred} from '#core/data-structures/promise';\nimport {dict} from '#core/types/object';\nimport {getWin} from '#core/window';\n\nimport {LayoutRectDef, layoutRectFromDomRect} from './rect';\nimport {createViewportObserver} from './viewport-observer';\n\n/** @type {!WeakMap<!Element, !Deferred<!IntersectionObserverEntry>>|undefined} */\nlet intersectionDeferreds;\n\n/** @type {!WeakMap<!Window, !IntersectionObserver>|undefined} */\nlet intersectionObservers;\n\n/**\n * @param {!Window} win\n * @return {!IntersectionObserver}\n */\nfunction getInOb(win) {\n  if (!intersectionDeferreds) {\n    intersectionDeferreds = new WeakMap();\n    intersectionObservers = new WeakMap();\n  }\n\n  let observer = intersectionObservers.get(win);\n  if (!observer) {\n    observer = createViewportObserver(\n      (entries) => {\n        const seen = new Set();\n        for (let i = entries.length - 1; i >= 0; i--) {\n          const {target} = entries[i];\n          if (seen.has(target)) {\n            continue;\n          }\n          seen.add(target);\n\n          observer.unobserve(target);\n          intersectionDeferreds.get(target).resolve(entries[i]);\n          intersectionDeferreds.delete(target);\n        }\n      },\n      win,\n      {needsRootBounds: true}\n    );\n    intersectionObservers.set(win, observer);\n  }\n  return observer;\n}\n\n/**\n * Returns a promise that resolves with the intersection entry for the given element.\n *\n * If multiple measures for the same element occur very quickly, they will\n * dedupe to the same promise.\n *\n * @param {!Element} el\n * @return {!Promise<!IntersectionObserverEntry>}\n */\nexport function measureIntersection(el) {\n  if (intersectionDeferreds && intersectionDeferreds.has(el)) {\n    return intersectionDeferreds.get(el).promise;\n  }\n\n  const inOb = getInOb(getWin(el));\n  inOb.observe(el);\n\n  const deferred = new Deferred();\n  intersectionDeferreds.set(el, deferred);\n  return deferred.promise;\n}\n\n/**\n * Convert an IntersectionObserverEntry to a regular object to make it serializable.\n *\n * @param {!IntersectionObserverEntry} entry\n * @return {!JsonObject}\n */\nexport function intersectionEntryToJson(entry) {\n  return dict({\n    'time': entry.time,\n    'rootBounds': safeLayoutRectFromDomRect(entry.rootBounds),\n    'boundingClientRect': safeLayoutRectFromDomRect(entry.boundingClientRect),\n    'intersectionRect': safeLayoutRectFromDomRect(entry.intersectionRect),\n    'intersectionRatio': entry.intersectionRatio,\n  });\n}\n\n/**\n * @param {?} rect\n * @return {?LayoutRectDef}\n */\nfunction safeLayoutRectFromDomRect(rect) {\n  if (rect === null) {\n    return null;\n  }\n  return layoutRectFromDomRect(/** @type {!ClientRect} */ (rect));\n}\n", "import {devAssert} from '#core/assert';\n\n/**\n * Maps a value in a first range to its equivalent in a second range\n * Ex.: 5 in the range [0,10] gives 60 in the range[40,80]\n *\n * NOTE: lower/upper bounds on the source range are detected automatically,\n * however the bounds on the target range are not altered (thus the target\n * range could be decreasing).\n * Ex1: 8 in the range [0, 10] gives 2 in the range [10, 0]\n * Ex2: also, 8 in the range [10, 0] gives 2 in the range [10, 0]\n *\n * NOTE: Input value is enforced to be bounded inside the source range\n * Ex1: -2 in the range [0, 10] is interpreted as 0 and thus gives 40 in [40,80]\n * Ex2: 19 in the range [0, 5] is interpreted as 5 and thus gives 80 in [40,80]\n *\n * @param {number} val the value in the source range\n * @param {number} min1 the lower bound of the source range\n * @param {number} max1 the upper bound of the source range\n * @param {number} min2 the lower bound of the target range\n * @param {number} max2 the upper bound of the target range\n * @return {number} the equivalent value in the target range\n */\nexport function mapRange(val, min1, max1, min2, max2) {\n  let max1Bound = max1;\n  let min1Bound = min1;\n  if (min1 > max1) {\n    max1Bound = min1;\n    min1Bound = max1;\n  }\n\n  if (val < min1Bound) {\n    val = min1Bound;\n  } else if (val > max1Bound) {\n    val = max1Bound;\n  }\n\n  return ((val - min1) * (max2 - min2)) / (max1 - min1) + min2;\n}\n\n/**\n * Computes the modulus of values `a` and `b`.\n *\n * This is needed because the % operator in JavaScript doesn't implement\n * modulus behavior as can be seen by the spec here:\n * http://www.ecma-international.org/ecma-262/5.1/#sec-11.5.3.\n * It instead is used to obtain the remainder of a division.\n * This function uses the remainder (%) operator to determine the modulus.\n * Derived from here:\n * https://stackoverflow.com/questions/25726760/javascript-modular-arithmetic/47354356#47354356\n *\n * @param {number} a\n * @param {number} b\n * @return {number} returns the modulus of the two numbers.\n * @example\n *\n * _.min(10, 5);\n * // => 0\n *\n * _.mod(-1, 5);\n * // => 4\n */\nexport function mod(a, b) {\n  return a > 0 && b > 0 ? a % b : ((a % b) + b) % b;\n}\n\n/**\n * Restricts a number to be in the given min/max range. The minimum value must\n * be less than or equal to the maximum value.\n *\n * Examples:\n * clamp(0.5, 0, 1) -> 0.5\n * clamp(1.5, 0, 1) -> 1\n * clamp(-0.5, 0, 1) -> 0\n *\n * @param {number} val the value to clamp.\n * @param {number} min the lower bound.\n * @param {number} max the upper bound.\n * @return {number} the clamped value.\n */\nexport function clamp(val, min, max) {\n  devAssert(min <= max, 'Minimum value is greater than the maximum.');\n  return Math.min(Math.max(val, min), max);\n}\n\n/**\n * Returns value bound to min and max values +/- extent. The lower bound must\n * be less than or equal to the upper bound.\n * @param {number} val the value to bound.\n * @param {number} min the lower bound.\n * @param {number} max the upper bound\n * @param {number} extent the allowed extent beyond the bounds.\n * @return {number} the bounded value.\n */\nexport function boundValue(val, min, max, extent) {\n  devAssert(min <= max, 'Lower bound is greater than the upper bound.');\n  return clamp(val, min - extent, max + extent);\n}\n\n/**\n * Returns the length of a vector given in X- and Y-coordinates.\n * @param {number} deltaX distance in the X direction.\n * @param {number} deltaY distance in the Y direction.\n * @return {number} the magnitude of the vector.\n */\nexport function magnitude(deltaX, deltaY) {\n  return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n}\n\n/**\n * Returns the distance between two points.\n * @param {number} x1 X-coordinate of the first point.\n * @param {number} y1 Y-coordinate of the first point.\n * @param {number} x2 X-coordinate of the second point.\n * @param {number} y2 Y-coordinate of the second point.\n * @return {number} the distance between the two points.\n */\nexport function distance(x1, y1, x2, y2) {\n  return magnitude(x2 - x1, y2 - y1);\n}\n\n/**\n * @param {number} centerX\n * @param {number} centerY\n * @param {number} radius\n * @param {number} angleInDegrees\n * @return {{\n *  x: number,\n *  y: number,\n * }}\n */\nexport function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n  const angleInRadians = ((angleInDegrees - 90) * Math.PI) / 180.0;\n\n  return {\n    x: centerX + radius * Math.cos(angleInRadians),\n    y: centerY + radius * Math.sin(angleInRadians),\n  };\n}\n\n/**\n * Sums up the values of the given array and returns the result\n * @param {Array<number>} values\n * @return {number}\n */\nexport function sum(values) {\n  return values.reduce(function (a, b) {\n    return a + b;\n  });\n}\n", "/**\n * Whether addEventListener supports options or only takes capture as a boolean\n * @type {boolean|undefined}\n * @visibleForTesting\n */\nlet optsSupported;\n\n/**\n * Whether addEventListener supports options or only takes passive as a boolean\n * @type {boolean|undefined}\n */\nlet passiveSupported;\n\n/**\n * Options supported by addEventListener\n * @typedef AddEventListenerOptsDef\n * @property {undefined|boolean} [capture]\n * @property {undefined|boolean} [once]\n * @property {undefined|boolean} [passive]\n * @property {undefined|!AbortSignal} [signal]\n * }}\n */\nlet AddEventListenerOptsDef;\n\n/**\n * Listens for the specified event on the element.\n *\n * Do not use this directly. This method is implemented as a shared\n * dependency. Use `listen()` in either `event-helper` or\n * `#core/3p-frame-messaging`, depending on your use case.\n *\n * @param {!EventTarget} element\n * @param {string} eventType\n * @param {function(!Event)} listener\n * @param {!AddEventListenerOptsDef=} opt_evtListenerOpts\n * @return {!UnlistenDef}\n */\nexport function internalListenImplementation(\n  element,\n  eventType,\n  listener,\n  opt_evtListenerOpts\n) {\n  let localElement = element;\n  let localListener = listener;\n  /** @type {?function(!Event)} */\n  let wrapped = (event) => {\n    try {\n      return localListener(event);\n    } catch (e) {\n      // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n      self.__AMP_REPORT_ERROR?.(e);\n      throw e;\n    }\n  };\n  const optsSupported = detectEvtListenerOptsSupport();\n  const capture = !!opt_evtListenerOpts?.capture;\n\n  localElement.addEventListener(\n    eventType,\n    wrapped,\n    optsSupported ? opt_evtListenerOpts : capture\n  );\n  return () => {\n    localElement?.removeEventListener(\n      eventType,\n      wrapped,\n      optsSupported ? opt_evtListenerOpts : capture\n    );\n    // Ensure these are GC'd\n    localListener = null;\n    localElement = null;\n    wrapped = null;\n  };\n}\n\n/**\n * Tests whether the browser supports options as an argument of addEventListener\n * or not.\n *\n * @return {boolean}\n */\nexport function detectEvtListenerOptsSupport() {\n  // Only run the test once\n  if (optsSupported !== undefined) {\n    return optsSupported;\n  }\n\n  optsSupported = false;\n  try {\n    // Test whether browser supports EventListenerOptions or not\n    const options = {\n      get capture() {\n        optsSupported = true;\n      },\n    };\n    self.addEventListener('test-options', null, options);\n    self.removeEventListener('test-options', null, options);\n  } catch (err) {\n    // EventListenerOptions are not supported\n  }\n  return optsSupported;\n}\n\n/**\n * Resets the test for whether addEventListener supports options or not.\n */\nexport function resetEvtListenerOptsSupportForTesting() {\n  optsSupported = undefined;\n}\n\n/**\n * Return boolean. if listener option is supported, return `true`.\n * if not supported, return `false`\n * @param {!Window} win\n * @return {boolean}\n */\nexport function supportsPassiveEventListener(win) {\n  if (passiveSupported !== undefined) {\n    return passiveSupported;\n  }\n\n  passiveSupported = false;\n  try {\n    const options = {\n      get passive() {\n        // This function will be called when the browser\n        // attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      },\n    };\n\n    win.addEventListener('test-options', null, options);\n    win.removeEventListener('test-options', null, options);\n  } catch (err) {\n    // EventListenerOptions are not supported\n  }\n  return passiveSupported;\n}\n\n/**\n * Resets the test for whether addEventListener supports passive options or not.\n */\nexport function resetPassiveSupportedForTesting() {\n  passiveSupported = undefined;\n}\n", "import {internalListenImplementation} from '#core/dom/event-helper-listen';\nimport {lastChildElement} from '#core/dom/query';\nimport * as mode from '#core/mode';\n\nimport {user} from '#utils/log';\n\n/** @const {string}  */\nconst LOAD_FAILURE_PREFIX = 'Failed to load:';\n\n/** @const {string} */\nexport const MEDIA_LOAD_FAILURE_SRC_PROPERTY = '__AMP_MEDIA_LOAD_FAILURE_SRC';\n\n/**\n * Returns a CustomEvent with a given type and detail; supports fallback for IE.\n * @param {!Window} win\n * @param {string} type\n * @param {!JsonObject|string|undefined|null} detail\n * @param {EventInit=} opt_eventInit\n * @return {!Event}\n */\nexport function createCustomEvent(win, type, detail, opt_eventInit) {\n  const eventInit = /** @type {!CustomEventInit} */ ({detail});\n  Object.assign(eventInit, opt_eventInit);\n  // win.CustomEvent is a function on Edge, Chrome, FF, Safari but\n  // is an object on IE 11.\n  if (mode.isEsm() || typeof win.CustomEvent == 'function') {\n    return new win.CustomEvent(type, eventInit);\n  } else {\n    // Deprecated fallback for IE.\n    const e = win.document.createEvent('CustomEvent');\n    e.initCustomEvent(\n      type,\n      !!eventInit.bubbles,\n      !!eventInit.cancelable,\n      detail\n    );\n    return e;\n  }\n}\n\n/**\n * Listens for the specified event on the element.\n * @param {!EventTarget} element\n * @param {string} eventType\n * @param {function(!Event)} listener\n * @param {Object=} opt_evtListenerOpts\n * @return {!UnlistenDef}\n */\nexport function listen(element, eventType, listener, opt_evtListenerOpts) {\n  return internalListenImplementation(\n    element,\n    eventType,\n    listener,\n    opt_evtListenerOpts\n  );\n}\n\n/**\n * Returns the data property of an event with the correct type.\n * @param {!Event|{data: !JsonObject}} event\n * @return {?JsonObject|string|undefined}\n */\nexport function getData(event) {\n  return /** @type {?JsonObject|string|undefined} */ (event.data);\n}\n\n/**\n * Returns the detail property of an event with the correct type.\n * @param {!Event|{detail: !JsonObject}} event\n * @return {?JsonObject|string|undefined}\n */\nexport function getDetail(event) {\n  return /** @type {?JsonObject|string|undefined} */ (event.detail);\n}\n\n/**\n * Listens for the specified event on the element and removes the listener\n * as soon as event has been received.\n * @param {!EventTarget} element\n * @param {string} eventType\n * @param {function(!Event)} listener\n * @param {Object=} opt_evtListenerOpts\n * @return {!UnlistenDef}\n */\nexport function listenOnce(element, eventType, listener, opt_evtListenerOpts) {\n  let localListener = listener;\n  const unlisten = internalListenImplementation(\n    element,\n    eventType,\n    (event) => {\n      try {\n        localListener(event);\n      } finally {\n        // Ensure listener is GC'd\n        localListener = null;\n        unlisten();\n      }\n    },\n    opt_evtListenerOpts\n  );\n  return unlisten;\n}\n\n/**\n * Returns  a promise that will resolve as soon as the specified event has\n * fired on the element.\n * @param {!EventTarget} element\n * @param {string} eventType\n * @param {Object=} opt_evtListenerOpts\n * @param {function(!UnlistenDef)=} opt_cancel An optional function that, when\n *     provided, will be called with the unlistener. This gives the caller\n *     access to the unlistener, so it may be called manually when necessary.\n * @return {!Promise<!Event>}\n */\nexport function listenOncePromise(\n  element,\n  eventType,\n  opt_evtListenerOpts,\n  opt_cancel\n) {\n  let unlisten;\n  const eventPromise = new Promise((resolve) => {\n    unlisten = listenOnce(element, eventType, resolve, opt_evtListenerOpts);\n  });\n  eventPromise.then(unlisten, unlisten);\n  if (opt_cancel) {\n    opt_cancel(unlisten);\n  }\n  return eventPromise;\n}\n\n/**\n * Whether the specified element/window has been loaded already.\n * @param {!Element|!Window} eleOrWindow\n * @return {boolean}\n */\nexport function isLoaded(eleOrWindow) {\n  return !!(\n    eleOrWindow.complete ||\n    eleOrWindow.readyState == 'complete' ||\n    (isHTMLMediaElement(eleOrWindow) && eleOrWindow.readyState > 0) ||\n    // If the passed in thing is a Window, infer loaded state from\n    //\n    (eleOrWindow.document && eleOrWindow.document.readyState == 'complete')\n  );\n}\n\n/**\n * Returns a promise that will resolve or fail based on the eleOrWindow's 'load'\n * and 'error' events. Optionally this method takes a timeout, which will reject\n * the promise if the resource has not loaded by then.\n * @param {T} eleOrWindow Supports both Elements and as a special case Windows.\n * @return {!Promise<T>}\n * @template T\n */\nexport function loadPromise(eleOrWindow) {\n  let unlistenLoad;\n  let unlistenError;\n  if (isLoaded(eleOrWindow)) {\n    return Promise.resolve(eleOrWindow);\n  }\n  const isMediaElement = isHTMLMediaElement(eleOrWindow);\n  if (\n    isMediaElement &&\n    eleOrWindow[MEDIA_LOAD_FAILURE_SRC_PROPERTY] === eleOrWindow.currentSrc\n  ) {\n    return Promise.reject(eleOrWindow);\n  }\n  const loadingPromise = new Promise((resolve, reject) => {\n    // Listen once since IE 5/6/7 fire the onload event continuously for\n    // animated GIFs.\n    if (isMediaElement) {\n      // The following event can be triggered by the media or one of its\n      // sources. Using capture is required as the media events do not bubble.\n      unlistenLoad = listenOnce(eleOrWindow, 'loadedmetadata', resolve, {\n        capture: true,\n      });\n    } else {\n      unlistenLoad = listenOnce(eleOrWindow, 'load', resolve);\n    }\n    // Don't unlisten on error for Windows.\n    if (!eleOrWindow.tagName) {\n      return;\n    }\n    let errorTarget = eleOrWindow;\n    // If the media element has no `src`, it will try to load the sources in\n    // document order. If the last source errors, then the media element\n    // loading errored.\n    if (isMediaElement && !eleOrWindow.hasAttribute('src')) {\n      errorTarget = lastChildElement(\n        eleOrWindow,\n        (child) => child.tagName === 'SOURCE'\n      );\n      if (!errorTarget) {\n        return reject(new Error('Media has no source.'));\n      }\n    }\n    unlistenError = listenOnce(errorTarget, 'error', reject);\n  });\n\n  return loadingPromise.then(\n    () => {\n      if (unlistenError) {\n        unlistenError();\n      }\n      return eleOrWindow;\n    },\n    () => {\n      if (unlistenLoad) {\n        unlistenLoad();\n      }\n      failedToLoad(eleOrWindow);\n    }\n  );\n}\n\n/**\n * Emit error on load failure.\n * @param {!Element|!Window} eleOrWindow Supports both Elements and as a special\n *     case Windows.\n */\nfunction failedToLoad(eleOrWindow) {\n  // Mark the element as errored since some elements - like HTMLMediaElement\n  // using HTMLSourceElement - do not provide any synchronous way to verify if\n  // they already errored, even though the error event was already dispatched.\n  if (isHTMLMediaElement(eleOrWindow)) {\n    eleOrWindow[MEDIA_LOAD_FAILURE_SRC_PROPERTY] =\n      eleOrWindow.currentSrc || true;\n  }\n\n  // Report failed loads as user errors so that they automatically go\n  // into the \"document error\" bucket.\n  let target = eleOrWindow;\n  if (target && target.src) {\n    target = target.src;\n  }\n  throw user().createError(LOAD_FAILURE_PREFIX, target);\n}\n\n/**\n * Returns true if the parameter is a HTMLMediaElement.\n * @param {!Element|!Window} eleOrWindow\n * @return {boolean}\n */\nfunction isHTMLMediaElement(eleOrWindow) {\n  return eleOrWindow.tagName === 'AUDIO' || eleOrWindow.tagName === 'VIDEO';\n}\n\n/**\n * Returns true if this error message is was created for a load error.\n * @param {string} message An error message\n * @return {boolean}\n */\nexport function isLoadErrorMessage(message) {\n  return message.indexOf(LOAD_FAILURE_PREFIX) != -1;\n}\n", "import {removeItem} from '#core/types/array';\n\n/**\n * This class helps to manage observers. Observers can be added, removed or\n * fired through and instance of this class.\n * @template TYPE\n */\nexport class Observable {\n  /**\n   * Creates an instance of Observable.\n   */\n  constructor() {\n    /** @type {?Array<function(TYPE)>} */\n    this.handlers_ = null;\n  }\n\n  /**\n   * Adds the observer to this instance.\n   * @param {function(TYPE)} handler Observer's handler.\n   * @return {!UnlistenDef}\n   */\n  add(handler) {\n    if (!this.handlers_) {\n      this.handlers_ = [];\n    }\n    this.handlers_.push(handler);\n    return () => {\n      this.remove(handler);\n    };\n  }\n\n  /**\n   * Removes the observer from this instance.\n   * @param {function(TYPE)} handler Observer's instance.\n   */\n  remove(handler) {\n    if (!this.handlers_) {\n      return;\n    }\n    removeItem(this.handlers_, handler);\n  }\n\n  /**\n   * Removes all observers.\n   */\n  removeAll() {\n    if (!this.handlers_) {\n      return;\n    }\n    this.handlers_.length = 0;\n  }\n\n  /**\n   * Fires an event. All observers are called.\n   * @param {TYPE=} opt_event\n   */\n  fire(opt_event) {\n    if (!this.handlers_) {\n      return;\n    }\n    for (const handler of this.handlers_) {\n      handler(opt_event);\n    }\n  }\n\n  /**\n   * Returns number of handlers. Mostly needed for tests.\n   * @return {number}\n   */\n  getHandlerCount() {\n    return this.handlers_?.length ?? 0;\n  }\n}\n", "import {Observable} from '#core/data-structures/observable';\n\nexport class VideoSessionManager {\n  /**\n   * Creates an instance of VideoSessionManager.\n   */\n  constructor() {\n    /** @private */\n    this.isSessionActive_ = false;\n\n    /** @private */\n    this.endSessionObservable_ = new Observable();\n  }\n\n  /**\n   * Register a listener to be notified when a session has ended\n   * @param {!Function} listener\n   */\n  onSessionEnd(listener) {\n    this.endSessionObservable_.add(listener);\n  }\n\n  /**\n   * Begin a session.\n   */\n  beginSession() {\n    this.isSessionActive_ = true;\n  }\n\n  /**\n   * End a session.\n   */\n  endSession() {\n    if (this.isSessionActive_) {\n      this.endSessionObservable_.fire();\n    }\n    this.isSessionActive_ = false;\n  }\n\n  /**\n   * Get the current session state.\n   * @return {*} TODO(#23582): Specify return type\n   */\n  isSessionActive() {\n    return this.isSessionActive_;\n  }\n}\n", "import {devAssert} from '#core/assert';\nimport {map} from '#core/types/object';\n\nlet htmlContainer;\nlet svgContainer;\n\n/**\n * Creates the html helper for the doc.\n *\n * @param {!Element|!Document} nodeOrDoc\n * @return {function(!Array<string>):!Element}\n */\nexport function htmlFor(nodeOrDoc) {\n  const doc = nodeOrDoc.ownerDocument || nodeOrDoc;\n  if (!htmlContainer || htmlContainer.ownerDocument !== doc) {\n    htmlContainer = doc.createElement('div');\n  }\n\n  return html;\n}\n\n/**\n * Creates the svg helper for the doc.\n *\n * @param {!Element|!Document} nodeOrDoc\n * @return {function(!Array<string>):!Element}\n */\nexport function svgFor(nodeOrDoc) {\n  const doc = nodeOrDoc.ownerDocument || nodeOrDoc;\n  if (!svgContainer || svgContainer.ownerDocument !== svgContainer) {\n    svgContainer = doc.createElementNS('http://www.w3.org/2000/svg', 'svg');\n  }\n\n  return svg;\n}\n\n/**\n * A tagged template literal helper to generate static SVG trees.\n * This must be used as a tagged template, ie\n *\n * ```\n * const circle = svg`<circle cx=\"60\" cy=\"60\" r=\"22\"></circle>`;\n * ```\n *\n * Only the root element and its subtree will be returned. DO NOT use this to\n * render subtree's with dynamic content, it WILL result in an error!\n *\n * @param {!Array<string>} strings\n * @return {!Element}\n */\nfunction svg(strings) {\n  return createNode(svgContainer, strings);\n}\n\n/**\n * A tagged template literal helper to generate static DOM trees.\n * This must be used as a tagged template, ie\n *\n * ```\n * const div = html`<div><span></span></div>`;\n * ```\n *\n * Only the root element and its subtree will be returned. DO NOT use this to\n * render subtree's with dynamic content, it WILL result in an error!\n *\n * @param {!Array<string>} strings\n * @return {!Element}\n */\nfunction html(strings) {\n  return createNode(htmlContainer, strings);\n}\n\n/**\n * Helper used by html and svg string literal functions.\n * @param {!Element} container\n * @param {!Array<string>} strings\n * @return {!Element}\n */\nfunction createNode(container, strings) {\n  devAssert(strings.length === 1, 'Improper html template tag usage.');\n  container./*OK*/ innerHTML = strings[0];\n\n  const el = container.firstElementChild;\n  devAssert(el, 'No elements in template');\n  devAssert(!el.nextElementSibling, 'Too many root elements in template');\n\n  // Clear to free memory.\n  container.removeChild(el);\n\n  return el;\n}\n\n/**\n * Queries an element for all elements with a \"ref\" attribute, removing\n * the attribute afterwards.\n * Returns a named map of all ref elements.\n *\n * @param {!Element} root\n * @return {!Object<string, !Element>}\n */\nexport function htmlRefs(root) {\n  const elements = root.querySelectorAll('[ref]');\n  const refs = map();\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    const ref = devAssert(element.getAttribute('ref'), 'Empty ref attr');\n    element.removeAttribute('ref');\n    devAssert(refs[ref] === undefined, 'Duplicate ref');\n    refs[ref] = element;\n  }\n\n  return refs;\n}\n", "import {removeElement} from '#core/dom';\nimport {htmlFor} from '#core/dom/static-template';\n\nimport {dev} from '#utils/log';\n\n/**\n * @param {!Element} node\n * @return {!Element}\n */\nfunction cloneDeep(node) {\n  return dev().assertElement(node.cloneNode(/* deep */ true));\n}\n\n/**\n * @param {!Element|!Document} elOrDoc\n * @param {?{title: (string|undefined)}=} metadata\n * @return {!Element}\n */\nexport function renderInteractionOverlay(elOrDoc, metadata) {\n  const html = htmlFor(elOrDoc);\n  const element = html`\n    <button\n      aria-label=\"Unmute video\"\n      class=\"i-amphtml-video-mask i-amphtml-fill-content\"\n      tabindex=\"0\"\n    ></button>\n  `;\n  if (metadata && metadata.title) {\n    element.setAttribute('aria-label', metadata.title);\n  }\n  return element;\n}\n\n/**\n * @param {!Window} win\n * @param {!Element|!Document} elOrDoc\n * @return {!Element}\n */\nexport function renderIcon(win, elOrDoc) {\n  const html = htmlFor(elOrDoc);\n  const icon = html`\n    <i-amphtml-video-icon class=\"amp-video-eq\">\n      <div class=\"amp-video-eq-col\">\n        <div class=\"amp-video-eq-filler\"></div>\n        <div class=\"amp-video-eq-filler\"></div>\n      </div>\n    </i-amphtml-video-icon>\n  `;\n\n  // Copy equalizer column 4x and annotate filler positions for animation.\n  const firstCol = dev().assertElement(icon.firstElementChild);\n  for (let i = 0; i < 4; i++) {\n    const col = cloneDeep(firstCol);\n    const fillers = col.children;\n    for (let j = 0; j < fillers.length; j++) {\n      const filler = fillers[j];\n      filler.classList.add(`amp-video-eq-${i + 1}-${j + 1}`);\n    }\n    icon.appendChild(col);\n  }\n\n  // Remove seed column.\n  removeElement(firstCol);\n\n  return icon;\n}\n", "export const cssText = \".i-amphtml-video-mask{display:block;z-index:1;-webkit-appearance:none;appearance:none;background:transparent;border:none}.amp-video-eq{display:none}.i-amphtml-video-interface:not(amp-video) .amp-video-eq,amp-story .amp-video-eq,amp-video[controls] .amp-video-eq{display:-ms-flexbox;display:flex}[noaudio] .amp-video-eq{display:none!important}.amp-video-eq{pointer-events:none!important;-ms-flex-align:end;align-items:flex-end;bottom:7px;height:12px;opacity:0.8;overflow:hidden;position:absolute;right:7px;width:20px;z-index:1}.amp-video-eq-col{-ms-flex:1;flex:1;height:100%;margin-right:1px;position:relative}.amp-video-eq-col div{animation-name:amp-video-eq-animation;animation-timing-function:linear;animation-iteration-count:infinite;animation-direction:alternate;background-color:#fafafa;height:100%;position:absolute;width:100%;will-change:transform;animation-play-state:paused}.amp-video-eq-play .amp-video-eq-col div{animation-play-state:running}.amp-video-eq-1-1{animation-duration:0.3s;transform:translateY(60%)}.amp-video-eq-1-2{animation-duration:0.45s;transform:translateY(60%)}.amp-video-eq-2-1{animation-duration:0.5s;transform:translateY(30%)}.amp-video-eq-2-2{animation-duration:0.4s;transform:translateY(30%)}.amp-video-eq-3-1{animation-duration:0.3s;transform:translateY(70%)}.amp-video-eq-3-2{animation-duration:0.35s;transform:translateY(70%)}.amp-video-eq-4-1{animation-duration:0.4s;transform:translateY(50%)}.amp-video-eq-4-2{animation-duration:0.25s;transform:translateY(50%)}@keyframes amp-video-eq-animation{0%{transform:translateY(100%)}to{transform:translateY(0)}}\\n/*# sourceURL=/css/video-autoplay.css*/\"", "import {CommonSignals} from '#core/constants/common-signals';\nimport {TickLabel} from '#core/constants/enums';\nimport {insertAfterOrAtStart, waitForBodyOpenPromise} from '#core/dom';\nimport {setStyles} from '#core/dom/style';\nimport {rethrowAsync} from '#core/error';\nimport {map} from '#core/types/object';\n\nimport {Services} from '#service';\n\nimport {dev, devAssert} from '#utils/log';\n\nimport {waitForServices} from './render-delaying-services';\nimport {getAmpdoc} from './service-helpers';\n\nconst TRANSFORMER_PROP = '__AMP_CSS_TR';\nconst STYLE_MAP_PROP = '__AMP_CSS_SM';\n\n/**\n * Adds the given css text to the given ampdoc.\n *\n * The style tags will be at the beginning of the head before all author\n * styles. One element can be the main runtime CSS. This is guaranteed\n * to always be the first stylesheet in the doc.\n *\n * @param {!./service/ampdoc-impl.AmpDoc} ampdoc The ampdoc that should get the new styles.\n * @param {string} cssText\n * @param {?function(!Element)|undefined} cb Called when the new styles are available.\n *     Not using a promise, because this is synchronous when possible.\n *     for better performance.\n * @param {boolean=} opt_isRuntimeCss If true, this style tag will be inserted\n *     as the first element in head and all style elements will be positioned\n *     after.\n * @param {string=} opt_ext\n * @return {!Element}\n */\nexport function installStylesForDoc(\n  ampdoc,\n  cssText,\n  cb,\n  opt_isRuntimeCss,\n  opt_ext\n) {\n  const cssRoot = ampdoc.getHeadNode();\n  const style = insertStyleElement(\n    cssRoot,\n    maybeTransform(cssRoot, cssText),\n    opt_isRuntimeCss || false,\n    opt_ext || null\n  );\n\n  if (cb) {\n    const rootNode = ampdoc.getRootNode();\n    // Styles aren't always available synchronously. E.g. if there is a\n    // pending style download, it will have to finish before the new\n    // style is visible.\n    // For this reason we poll until the style becomes available.\n    // Sync case.\n    if (styleLoaded(rootNode, style)) {\n      cb(style);\n      return style;\n    }\n    // Poll until styles are available.\n    const interval = setInterval(() => {\n      if (styleLoaded(rootNode, style)) {\n        clearInterval(interval);\n        cb(style);\n      }\n    }, 4);\n  }\n  return style;\n}\n\n/**\n * Creates the properly configured style element.\n * @param {!Element|!ShadowRoot} cssRoot\n * @param {string} cssText\n * @param {boolean} isRuntimeCss\n * @param {?string} ext\n * @return {!Element}\n */\nfunction insertStyleElement(cssRoot, cssText, isRuntimeCss, ext) {\n  let styleMap = cssRoot[STYLE_MAP_PROP];\n  if (!styleMap) {\n    styleMap = cssRoot[STYLE_MAP_PROP] = map();\n  }\n\n  const isExtCss =\n    !isRuntimeCss && ext && ext != 'amp-custom' && ext != 'amp-keyframes';\n  const key = isRuntimeCss\n    ? 'amp-runtime'\n    : isExtCss\n    ? `amp-extension=${ext}`\n    : null;\n\n  // Check if it has already been created or discovered.\n  if (key) {\n    const existing = getExistingStyleElement(cssRoot, styleMap, key);\n    if (existing) {\n      if (existing.textContent !== cssText) {\n        existing.textContent = cssText;\n      }\n      return existing;\n    }\n  }\n\n  // Create the new style element and append to cssRoot.\n  const doc = cssRoot.ownerDocument || cssRoot;\n  const style = doc.createElement('style');\n  style./*OK*/ textContent = cssText;\n  let afterElement = null;\n  // Make sure that we place style tags after the main runtime CSS. Otherwise\n  // the order is random.\n  if (isRuntimeCss) {\n    style.setAttribute('amp-runtime', '');\n  } else if (isExtCss) {\n    style.setAttribute('amp-extension', ext || '');\n    afterElement = dev().assertElement(\n      getExistingStyleElement(cssRoot, styleMap, 'amp-runtime')\n    );\n  } else {\n    if (ext) {\n      style.setAttribute(ext, '');\n    }\n    afterElement = cssRoot.lastChild;\n  }\n  insertAfterOrAtStart(cssRoot, style, afterElement);\n  if (key) {\n    styleMap[key] = style;\n  }\n  return style;\n}\n\n/**\n * @param {!Element|!ShadowRoot} cssRoot\n * @param {!Object<string, !Element>} styleMap\n * @param {string} key\n * @return {?Element}\n */\nfunction getExistingStyleElement(cssRoot, styleMap, key) {\n  // Already cached.\n  if (styleMap[key]) {\n    return styleMap[key];\n  }\n  // Check if the style has already been added by the server layout.\n  const existing = cssRoot./*OK*/ querySelector(`style[${key}]`);\n  if (existing) {\n    styleMap[key] = existing;\n    return existing;\n  }\n  // Nothing found.\n  return null;\n}\n\n/**\n * Applies a transformer to the CSS text if it has been registered.\n * @param {!Element|!ShadowRoot} cssRoot\n * @param {function(string):string} transformer\n */\nexport function installCssTransformer(cssRoot, transformer) {\n  cssRoot[TRANSFORMER_PROP] = transformer;\n}\n\n/**\n * Applies a transformer to the CSS text if it has been registered.\n * @param {!Element|!ShadowRoot} cssRoot\n * @param {string} cssText\n * @return {string}\n */\nfunction maybeTransform(cssRoot, cssText) {\n  const transformer = cssRoot[TRANSFORMER_PROP];\n  return transformer ? transformer(cssText) : cssText;\n}\n\n/** @private {boolean} */\nlet bodyMadeVisible = false;\n\n/**\n * @param {boolean} value\n * @visibleForTesting\n */\nexport function setBodyMadeVisibleForTesting(value) {\n  bodyMadeVisible = value;\n}\n\n/**\n * Sets the document's body opacity to 1.\n * If the body is not yet available (because our script was loaded\n * synchronously), polls until it is.\n * @param {!Document} doc The document who's body we should make visible.\n */\nexport function makeBodyVisible(doc) {\n  devAssert(doc.defaultView, 'Passed in document must have a defaultView');\n  const win = /** @type {!Window} */ (doc.defaultView);\n  waitForBodyOpenPromise(doc)\n    .then(() => {\n      return waitForServices(win);\n    })\n    .catch((reason) => {\n      rethrowAsync(reason);\n      return [];\n    })\n    .then((services) => {\n      bodyMadeVisible = true;\n      if (INI_LOAD_INOB) {\n        // Force sync measurement to ensure that style recalc is complete\n        // before showing body, which would trigger FCP. This should reduce\n        // make it less likely that a CLS would be triggered after FCP.\n        doc.body./*OK*/ getBoundingClientRect();\n      }\n      setBodyVisibleStyles(doc);\n      const ampdoc = getAmpdoc(doc);\n      ampdoc.signals().signal(CommonSignals.RENDER_START);\n      if (services.length > 0) {\n        const resources = Services.resourcesForDoc(doc.documentElement);\n        resources./*OK*/ schedulePass(1, /* relayoutAll */ true);\n      }\n      try {\n        const perf = Services.performanceFor(win);\n        perf.tick(TickLabel.MAKE_BODY_VISIBLE);\n        perf.flush();\n      } catch (e) {}\n    });\n}\n\n/**\n * Set the document's body opacity to 1. Called in error cases.\n * @param {!Document} doc The document who's body we should make visible.\n */\nexport function makeBodyVisibleRecovery(doc) {\n  devAssert(doc.defaultView, 'Passed in document must have a defaultView');\n  if (bodyMadeVisible) {\n    return;\n  }\n  bodyMadeVisible = true;\n  setBodyVisibleStyles(doc);\n}\n\n/**\n * Make sure that body exists, and make it visible.\n * @param {!Document} doc\n */\nfunction setBodyVisibleStyles(doc) {\n  setStyles(dev().assertElement(doc.body), {\n    opacity: 1,\n    visibility: 'visible',\n    'animation': 'none',\n  });\n}\n\n/**\n * Indicates that the body is always visible. For instance, in case of PWA.\n * This check is on a module level variable, and could be problematic if you are\n * relying on this function across different binaries.\n * @param {!Window} unusedWin\n */\nexport function bodyAlwaysVisible(unusedWin) {\n  bodyMadeVisible = true;\n}\n\n/**\n * Checks whether a style element was registered in the DOM.\n * @param {!Document|!ShadowRoot} doc\n * @param {!Element} style\n * @return {boolean}\n */\nfunction styleLoaded(doc, style) {\n  const sheets = doc.styleSheets;\n  for (let i = 0; i < sheets.length; i++) {\n    const sheet = sheets[i];\n    if (sheet.ownerNode == style) {\n      return true;\n    }\n  }\n  return false;\n}\n", "import {cssText} from '../../../build/video-autoplay.css';\nimport {installStylesForDoc} from '../../style-installer';\n// Source for this constant is css/video-autoplay.css\n\n/**\n * @param  {!../ampdoc-impl.AmpDoc} ampdoc\n */\nexport function installAutoplayStylesForDoc(ampdoc) {\n  installStylesForDoc(\n    ampdoc,\n    cssText,\n    /* callback */ null,\n    /* opt_isRuntimeCss */ false,\n    /* opt_ext */ 'amp-video-autoplay'\n  );\n}\n", "import {isArray, isObject} from '#core/types';\nimport {tryParseJson} from '#core/types/object/json';\n\nimport {Services} from '#service';\n\nimport {devAssert, userAssert} from '#utils/log';\n\n/**\n * @typedef {{\n *   artwork: Array,\n *   title: string,\n *   album: string,\n *   artist: string,\n * }}\n */\nexport let MetadataDef;\n\n/** @const {MetadataDef} Dummy metadata used to fix a bug */\nexport const EMPTY_METADATA = {\n  'title': '',\n  'artist': '',\n  'album': '',\n  'artwork': [{'src': ''}],\n};\n\n/**\n * Updates the Media Session API's metadata\n * @param {!Window} win\n * @param {!MetadataDef} metadata\n * @param {function()=} playHandler\n * @param {function()=} pauseHandler\n */\nexport function setMediaSession(win, metadata, playHandler, pauseHandler) {\n  const {navigator} = win;\n  if ('mediaSession' in navigator && win.MediaMetadata) {\n    // Clear mediaSession (required to fix a bug when switching between two\n    // videos)\n    navigator.mediaSession.metadata = new win.MediaMetadata(EMPTY_METADATA);\n\n    navigator.mediaSession.metadata = new win.MediaMetadata(metadata);\n\n    navigator.mediaSession.setActionHandler('play', playHandler);\n    navigator.mediaSession.setActionHandler('pause', pauseHandler);\n\n    // TODO(@wassgha) Implement seek & next/previous\n  }\n}\n\n/**\n * Parses the schema.org json-ld formatted meta-data, looks for the page's\n * featured image and returns it\n * @param {!Document} doc\n * @return {string|undefined}\n */\nexport function parseSchemaImage(doc) {\n  const schema = doc.querySelector('script[type=\"application/ld+json\"]');\n  if (!schema) {\n    // No schema element found\n    return;\n  }\n  const schemaJson = tryParseJson(schema.textContent);\n  if (!schemaJson || !schemaJson['image']) {\n    // No image found in the schema\n    return;\n  }\n\n  // Image definition in schema could be one of :\n  if (typeof schemaJson['image'] === 'string') {\n    // 1. \"image\": \"http://..\",\n    return schemaJson['image'];\n  } else if (\n    schemaJson['image']['@list'] &&\n    typeof schemaJson['image']['@list'][0] === 'string'\n  ) {\n    // 2. \"image\": {.., \"@list\": [\"http://..\"], ..}\n    return schemaJson['image']['@list'][0];\n  } else if (typeof schemaJson['image']['url'] === 'string') {\n    // 3. \"image\": {.., \"url\": \"http://..\", ..}\n    return schemaJson['image']['url'];\n  } else if (typeof schemaJson['image'][0] === 'string') {\n    // 4. \"image\": [\"http://.. \"]\n    return schemaJson['image'][0];\n  } else {\n    return;\n  }\n}\n\n/**\n * Parses the og:image if it exists and returns it\n * @param {!Document} doc\n * @return {string|undefined}\n */\nexport function parseOgImage(doc) {\n  const metaTag = doc.querySelector('meta[property=\"og:image\"]');\n  if (metaTag) {\n    return metaTag.getAttribute('content');\n  } else {\n    return;\n  }\n}\n\n/**\n * Parses the website's Favicon and returns it\n * @param {!Document} doc\n * @return {string|undefined}\n */\nexport function parseFavicon(doc) {\n  const linkTag =\n    doc.querySelector('link[rel=\"shortcut icon\"]') ||\n    doc.querySelector('link[rel=\"icon\"]');\n  if (linkTag) {\n    return linkTag.getAttribute('href');\n  } else {\n    return;\n  }\n}\n\n/**\n * @param {!Element} element\n * @param {!MetadataDef} metadata\n */\nexport function validateMediaMetadata(element, metadata) {\n  const urlService = Services.urlForDoc(element);\n  // Ensure src of artwork has valid protocol\n  if (metadata && metadata.artwork) {\n    const {artwork} = metadata;\n    devAssert(isArray(artwork));\n    artwork.forEach((item) => {\n      if (item) {\n        const src = isObject(item) ? item.src : item;\n        userAssert(urlService.isProtocolValid(src));\n      }\n    });\n  }\n}\n", "import {devAssertElement} from '#core/assert';\nimport {whenUpgradedToCustomElement} from '#core/dom/amp-element-helpers';\n\nexport const MIN_VISIBILITY_RATIO_FOR_AUTOPLAY = 0.5;\n\n/**\n * VideoInterface defines a common video API which any AMP component that plays\n * videos is expected to implement.\n *\n * AMP runtime uses this common API to provide consistent video experience and\n * analytics across all video players.\n *\n * Components implementing this interface must also extend\n * {@link ./base-element.BaseElement} and register with the\n * Video Manager {@link ./service/video-manager-impl.VideoManager} during\n * their `builtCallback`.\n *\n * @interface\n */\nexport class VideoInterface {\n  /**\n   * See `BaseElement`.\n   * @return {!./utils/signals.Signals}\n   */\n  signals() {}\n\n  /**\n   * See `BaseElement`.\n   * @param {function()} unusedMutator\n   * @return {!Promise}\n   */\n  mutateElementSkipRemeasure(unusedMutator) {}\n\n  /**\n   * Whether the component supports video playback in the current platform.\n   * If false, component will be not treated as a video component.\n   * @return {boolean}\n   */\n  supportsPlatform() {}\n\n  /**\n   * Whether users can interact with the video such as pausing it.\n   * Example of non-interactive videos include design background videos where\n   * all controls are hidden from the user.\n   *\n   * @return {boolean}\n   */\n  isInteractive() {}\n\n  /**\n   * Current playback time in seconds at time of trigger.\n   *\n   * This is used for analytics metadata.\n   *\n   * @return {number}\n   */\n  getCurrentTime() {}\n\n  /**\n   * Total duration of the video in seconds\n   *\n   * This is used for analytics metadata.\n   *\n   * @return {number}\n   */\n  getDuration() {}\n\n  /**\n   * Get a 2d array of start and stop times that the user has watched.\n   * This is used for analytics metadata.\n   * @return {!Array<Array<number>>}\n   */\n  getPlayedRanges() {}\n\n  /**\n   * Plays the video.\n   *\n   * @param {boolean} unusedIsAutoplay Whether the call to the `play` method is\n   * triggered by the autoplay functionality. Video players can use this hint\n   * to make decisions such as not playing pre-roll video ads.\n   */\n  play(unusedIsAutoplay) {}\n\n  /**\n   * Pauses the video.\n   */\n  pause() {}\n\n  /**\n   * Mutes the video.\n   * Implementation is required for autoplay and mute/unmute controls on docked\n   * video.\n   */\n  mute() {}\n\n  /**\n   * Unmutes the video.\n   * Implementation is required for autoplay and mute/unmute controls on docked\n   * video.\n   */\n  unmute() {}\n\n  /**\n   * Makes the video UI controls visible.\n   *\n   * AMP will not call this method if `controls` attribute is not set.\n   *\n   * Implementation is required for docked video.\n   */\n  showControls() {}\n\n  /**\n   * Hides the video UI controls.\n   *\n   * AMP will not call this method if `controls` attribute is not set.\n   *\n   * Implementation is required for docked video.\n   */\n  hideControls() {}\n\n  /**\n   * Returns video's meta data (artwork, title, artist, album, etc.) for use\n   * with the Media Session API\n   * @return {!./mediasession-helper.MetadataDef|undefined} metadata\n   *   - artwork (Array): URL to the poster image (preferably a 512x512 PNG)\n   *   - title (string): Name of the video\n   *   - artist (string): Name of the video's author/artist\n   *   - album (string): Name of the video's album if it exists\n   */\n  getMetadata() {}\n\n  /**\n   * If returning true, it's assumed that the embedded video document internally\n   * implements a feature to enter fullscreen on device rotation, so that the\n   * VideoManager does not override it.\n   *\n   * Otherwise, the feature is implemented automatically when using the\n   * `rotate-to-fullscreen` attribute.\n   *\n   * @return {boolean}\n   */\n  preimplementsAutoFullscreen() {}\n\n  /**\n   * If returning true, it's assumed that the embedded video document internally\n   * implements the MediaSession API internally so that the VideoManager won't\n   * replace it.\n   *\n   * Otherwise provided and inferred metadata are used to update the video's\n   * Media Session.\n   *\n   * @return {boolean}\n   */\n  preimplementsMediaSessionAPI() {}\n\n  /**\n   * Enables fullscreen on the internal video element\n   * NOTE: While implementing, keep in mind that Safari/iOS do not allow taking\n   * any element other than <video> to fullscreen, if the player has an internal\n   * implementation of fullscreen (flash for example) then check\n   * if Services.platformFor(this.win).isSafari is true and use the internal\n   * implementation instead. If not, it is recommended to take the iframe\n   * to fullscreen using fullscreenEnter from src/core/dom/fullscreen.js\n   */\n  fullscreenEnter() {}\n\n  /**\n   * Quits fullscreen mode\n   */\n  fullscreenExit() {}\n\n  /**\n   * Returns whether the video is currently in fullscreen mode or not.\n   * @return {boolean}\n   */\n  isFullscreen() {}\n\n  /**\n   * Seeks the video to a specified time.\n   * @param {number} unusedTimeSeconds\n   */\n  seekTo(unusedTimeSeconds) {}\n}\n\n/** @type {!AmpElement} */\nVideoInterface.prototype.element;\n\n/** @type {!Window} */\nVideoInterface.prototype.win;\n\n/**\n * Attributes\n *\n * Components implementing the VideoInterface are expected to support\n * the following attributes.\n *\n * @enum {string}\n */\nexport const VideoAttributes = {\n  /**\n   * autoplay\n   *\n   * Whether the developer has configured autoplay on the component.\n   * This is normally done by setting `autoplay` attribute on the component.\n   *\n   * AMP runtime manages autoplay behavior itself using methods such as `play`,\n   * `pause`, `showControls`, `hideControls`, `mute`, etc.. therefore components\n   * should not propagate the autoplay attribute to the underlying player\n   * implementation.\n   *\n   * When a video is requested to autoplay, AMP will automatically\n   * mute and hide the controls for the video, when video is 75% visible in\n   * the viewport, AMP will play the video and later pauses it when 25%\n   * or more of the video exits the viewport. If an auto-playing video also has\n   * controls, AMP will install a tap\n   * handler on the video, and when an end-user taps the video, AMP will show\n   * the controls.\n   *\n   */\n  AUTOPLAY: 'autoplay',\n  /**\n   * dock\n   *\n   * Setting the `dock` attribute on the component makes the video minimize\n   * to the corner when scrolled out of view and has been interacted with.\n   */\n  DOCK: 'dock',\n  /**\n   * rotate-to-fullscreen\n   *\n   * If enabled, this automatically expands the currently visible video and\n   * playing to fullscreen when the user changes the device's orientation to\n   * landscape if the video was started following a user interaction\n   * (not autoplay)\n   *\n   * Dependent upon browser support of\n   * http://caniuse.com/#feat=screen-orientation\n   * and http://caniuse.com/#feat=fullscreen\n   */\n  ROTATE_TO_FULLSCREEN: 'rotate-to-fullscreen',\n  /**\n   * noaudio\n   *\n   * If set and autoplay, the equalizer icon will not be displayed.\n   */\n  NO_AUDIO: 'noaudio',\n};\n\n/**\n * Events\n *\n * Components implementing the VideoInterface are expected to dispatch\n * the following DOM events.\n *\n * @enum {string}\n */\nexport const VideoEvents = {\n  /**\n   * registered\n   *\n   * Fired when the video player element is built and has been registered with\n   * the video manager.\n   *\n   * @event registered\n   */\n  REGISTERED: 'registered',\n\n  /**\n   * load\n   *\n   * Fired when the video player is loaded and calls to methods such as `play()`\n   * are allowed.\n   *\n   * @event load\n   */\n  LOAD: 'load',\n\n  /**\n   * loadedmetadata\n   *\n   * Fired when the video's metadata becomes available (e.g. duration).\n   *\n   * @event loadedmetadata\n   */\n  LOADEDMETADATA: 'loadedmetadata',\n\n  /**\n   * loadeddata\n   *\n   * Fired when the user agent can render the media for the first time.\n   *\n   * @event loadeddata\n   */\n  LOADEDDATA: 'loadeddata',\n\n  /**\n   * play\n   *\n   * Fired when the video plays (either because of autoplay or the play method).\n   *\n   * Note: Because this event was not originally present in this interface, we\n   * cannot rely on all all implementations to emit it.\n   *\n   * @event play\n   */\n  PLAY: 'play',\n\n  /**\n   * playing\n   *\n   * Fired when the video begins playing.\n   *\n   * @event playing\n   */\n  PLAYING: 'playing',\n\n  /**\n   * pause\n   *\n   * Fired when the video pauses.\n   *\n   * @event pause\n   */\n  PAUSE: 'pause',\n\n  /**\n   * ended\n   *\n   * Fired when the video ends.\n   *\n   * This event should be fired in addition to `pause` when video ends.\n   *\n   * @event ended\n   */\n  ENDED: 'ended',\n\n  /**\n   * muted\n   *\n   * Fired when the video is muted.\n   *\n   * @event muted\n   */\n  MUTED: 'muted',\n\n  /**\n   * unmuted\n   *\n   * Fired when the video is unmuted.\n   *\n   * @event unmuted\n   */\n  UNMUTED: 'unmuted',\n\n  /**\n   * amp:video:visibility\n   *\n   * Fired when the video's visibility changes.\n   *\n   * @event amp:video:visibility\n   * @property {boolean} visible Whether the video player is visible or not.\n   */\n  VISIBILITY: 'amp:video:visibility',\n\n  /**\n   * reload\n   *\n   * Fired when the video's src changes.\n   *\n   * @event reloaded\n   */\n  RELOAD: 'reloaded',\n\n  /**\n   * pre/mid/post Ad start\n   *\n   * Fired when an Ad starts playing.\n   *\n   * This is used to remove any overlay shims during Ad play during autoplay\n   * or minimized-to-corner version of the player.\n   *\n   * @event ad_start\n   */\n  AD_START: 'ad_start',\n\n  /**\n   * pre/mid/post Ad ends\n   *\n   * Fired when an Ad ends playing.\n   *\n   * This is used to restore any overlay shims during Ad play during autoplay\n   * or minimized-to-corner version of the player.\n   *\n   * @event ad_end\n   */\n  AD_END: 'ad_end',\n\n  /**\n   * A 3p video player can send signals for analytics whose meaning doesn't\n   * fit for other events. In this case, a `tick` event is sent with additional\n   * information in its data property.\n   *\n   * @event amp:video:tick\n   */\n  CUSTOM_TICK: 'amp:video:tick',\n};\n\n/** @typedef {string} */\nexport let PlayingStateDef;\n\n/**\n * Playing States\n *\n * Internal playing states used to distinguish between video playing on user's\n * command and videos playing automatically\n *\n * @enum {string}\n */\nexport const PlayingStates = {\n  /**\n   * playing_manual\n   *\n   * When the video user manually interacted with the video and the video\n   * is now playing\n   *\n   * @event playing_manual\n   */\n  PLAYING_MANUAL: 'playing_manual',\n\n  /**\n   * playing_auto\n   *\n   * When the video has autoplay and the user hasn't interacted with it yet\n   *\n   * @event playing_auto\n   */\n  PLAYING_AUTO: 'playing_auto',\n\n  /**\n   * paused\n   *\n   * When the video is paused.\n   *\n   * @event paused\n   */\n  PAUSED: 'paused',\n};\n\n/** @enum {string} */\nexport const VideoAnalyticsEvents = {\n  /**\n   * video-ended\n   *\n   * Indicates that a video ended.\n   * @property {!VideoAnalyticsDetailsDef} details\n   * @event video-ended\n   */\n  ENDED: 'video-ended',\n\n  /**\n   * video-pause\n   *\n   * Indicates that a video paused.\n   * @property {!VideoAnalyticsDetailsDef} details\n   * @event video-pause\n   */\n  PAUSE: 'video-pause',\n\n  /**\n   * video-play\n   *\n   * Indicates that a video began to play.\n   * @property {!VideoAnalyticsDetailsDef} details\n   * @event video-play\n   */\n  PLAY: 'video-play',\n\n  /**\n   * video-session\n   *\n   * Indicates that some segment of the video played.\n   * @property {!VideoAnalyticsDetailsDef} details\n   * @event video-session\n   */\n  SESSION: 'video-session',\n\n  /**\n   * video-session-visible\n   *\n   * Indicates that some segment of the video played in the viewport.\n   * @property {!VideoAnalyticsDetailsDef} details\n   * @event video-session-visible\n   */\n  SESSION_VISIBLE: 'video-session-visible',\n\n  /**\n   * video-seconds-played\n   *\n   * Indicates that a video was playing when the\n   * video-seconds-played interval fired.\n   * @property {!VideoAnalyticsDetailsDef} details\n   * @event video-session-visible\n   */\n  SECONDS_PLAYED: 'video-seconds-played',\n\n  /**\n   * video-hosted-custom\n   *\n   * Indicates that a custom event incoming from a 3p frame is to be logged.\n   * @property {!VideoAnalyticsDetailsDef} details\n   * @event video-custom\n   */\n  CUSTOM: 'video-hosted-custom',\n\n  /**\n   * video-percentage-played\n   *\n   * Indicates that a percentage interval has been played.\n   * @property {!VideoAnalyticsDetailsDef} details\n   * @event video-custom\n   */\n  PERCENTAGE_PLAYED: 'video-percentage-played',\n\n  /**\n   * video-ad-start\n   *\n   * Indicates that an ad begins to play.\n   * @property {!VideoAnalyticsDetailsDef} details\n   * @event video-ad-start\n   */\n  AD_START: 'video-ad-start',\n\n  /**\n   * video-ad-end\n   *\n   * Indicates that an ad ended.\n   * @property {!VideoAnalyticsDetailsDef} details\n   * @event video-ad-end\n   */\n  AD_END: 'video-ad-end',\n};\n\n/**\n * This key can't predictably collide with custom var names as defined in\n * analytics user configuration.\n * @type {string}\n */\nexport const videoAnalyticsCustomEventTypeKey = '__amp:eventType';\n\n/**\n * Helper union type to be used internally, so that the compiler treats\n * `VideoInterface` objects as `BaseElement`s, which they should be anyway.\n *\n * WARNING: Don't use to `register` at the Service level. Registering should\n * only allow `VideoInterface` as a guarding measure.\n *\n * @typedef {!VideoInterface|!./base-element.BaseElement}\n */\nexport let VideoOrBaseElementDef;\n\n/**\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isDockable(element) {\n  return element.hasAttribute(VideoAttributes.DOCK);\n}\n\n/** @enum {string} */\nexport const VideoServiceSignals = {\n  USER_INTERACTED: 'user-interacted',\n  PLAYBACK_DELEGATED: 'playback-delegated',\n};\n\n/** @param {!AmpElement|!VideoOrBaseElementDef} video */\nexport function delegateAutoplay(video) {\n  whenUpgradedToCustomElement(devAssertElement(video)).then((el) => {\n    el.signals().signal(VideoServiceSignals.PLAYBACK_DELEGATED);\n  });\n}\n\n/** @param {!AmpElement|!VideoOrBaseElementDef} video */\nexport function userInteractedWith(video) {\n  video.signals().signal(VideoServiceSignals.USER_INTERACTED);\n}\n\n/**\n * Classname that media components should annotate themselves with.\n * This applies to all video and audio playback components, regardless of\n * whether they implement a common interface or not.\n *\n * TODO(go.amp.dev/issue/26984): This isn't exclusive to video, but there's no\n * better place to put this now due to OWNERShip. Move.\n */\nexport const MEDIA_COMPONENT_CLASSNAME = 'i-amphtml-media-component';\n\n/**\n * Annotates media component element with a common classname.\n * This applies to all video and audio playback components, regardless of\n * whether they implement a common interface or not.\n * @param {!Element} element\n *\n * TODO(go.amp.dev/issue/26984): This isn't exclusive to video, but there's no\n * better place to put this now due to OWNERShip. Move.\n */\nexport function setIsMediaComponent(element) {\n  element.classList.add(MEDIA_COMPONENT_CLASSNAME);\n}\n", "import {ActionTrust} from '#core/constants/action-constants';\nimport {dispatchCustomEvent, removeElement} from '#core/dom';\nimport {measureIntersection} from '#core/dom/layout/intersection';\nimport {createViewportObserver} from '#core/dom/layout/viewport-observer';\nimport {toggle} from '#core/dom/style';\nimport {\n  getInternalVideoElementFor,\n  isAutoplaySupported,\n  tryPlay,\n} from '#core/dom/video';\nimport {clamp} from '#core/math';\nimport {isFiniteNumber} from '#core/types';\nimport {once} from '#core/types/function';\nimport {dict, map} from '#core/types/object';\n\nimport {Services} from '#service';\n\nimport {\n  createCustomEvent,\n  getData,\n  listen,\n  listenOnce,\n} from '#utils/event-helper';\nimport {dev, devAssert, user, userAssert} from '#utils/log';\n\nimport {VideoSessionManager} from './video-session-manager';\nimport {renderIcon, renderInteractionOverlay} from './video/autoplay';\nimport {installAutoplayStylesForDoc} from './video/install-autoplay-styles';\n\nimport {\n  EMPTY_METADATA,\n  parseFavicon,\n  parseOgImage,\n  parseSchemaImage,\n  setMediaSession,\n  validateMediaMetadata,\n} from '../mediasession-helper';\nimport {registerServiceBuilderForDoc} from '../service-helpers';\nimport {\n  MIN_VISIBILITY_RATIO_FOR_AUTOPLAY,\n  PlayingStates,\n  VideoAnalyticsEvents,\n  VideoAttributes,\n  VideoEvents,\n  VideoServiceSignals,\n  setIsMediaComponent,\n  userInteractedWith,\n  videoAnalyticsCustomEventTypeKey,\n} from '../video-interface';\n\n/** @private @const {string} */\nconst TAG = 'video-manager';\n\n/**\n * @private {number} The minimum number of milliseconds to wait between each\n * video-seconds-played analytics event.\n */\nconst SECONDS_PLAYED_MIN_DELAY = 1000;\n\n/**\n * VideoManager keeps track of all AMP video players that implement\n * the common Video API {@see ../video-interface.VideoInterface}.\n *\n * It is responsible for providing a unified user experience and analytics for\n * all videos within a document.\n *\n * @implements {../service.Disposable}\n */\nexport class VideoManager {\n  /**\n   * @param {!./ampdoc-impl.AmpDoc} ampdoc\n   */\n  constructor(ampdoc) {\n    /** @const {!./ampdoc-impl.AmpDoc}  */\n    this.ampdoc = ampdoc;\n\n    /** @const */\n    this.installAutoplayStyles = once(() =>\n      installAutoplayStylesForDoc(this.ampdoc)\n    );\n\n    /** @private {?Array<!VideoEntry>} */\n    this.entries_ = null;\n\n    /** @private {IntersectionObserver} */\n    this.viewportObserver_ = null;\n\n    /**\n     * Keeps last found entry as a small optimization for multiple state calls\n     * during one task.\n     * @private {?VideoEntry}\n     */\n    this.lastFoundEntry_ = null;\n\n    /** @private @const */\n    this.timer_ = Services.timerFor(ampdoc.win);\n\n    /** @private @const */\n    this.actions_ = Services.actionServiceForDoc(ampdoc.getHeadNode());\n\n    /**\n     * @private\n     * @const\n     * @return {undefined}\n     */\n    this.boundSecondsPlaying_ = () => this.secondsPlaying_();\n\n    /** @private @const {function():!AutoFullscreenManager} */\n    this.getAutoFullscreenManager_ = once(\n      () => new AutoFullscreenManager(this.ampdoc, this)\n    );\n\n    // TODO(cvializ, #10599): It would be nice to only create the timer\n    // if video analytics are present, since the timer is not needed if\n    // video analytics are not present.\n    this.timer_.delay(this.boundSecondsPlaying_, SECONDS_PLAYED_MIN_DELAY);\n  }\n\n  /** @override */\n  dispose() {\n    this.getAutoFullscreenManager_().dispose();\n    this.viewportObserver_.disconnect();\n    this.viewportObserver_ = null;\n\n    if (!this.entries_) {\n      return;\n    }\n    for (let i = 0; i < this.entries_.length; i++) {\n      const entry = this.entries_[i];\n      entry.dispose();\n    }\n  }\n\n  /**\n   * Each second, trigger video-seconds-played for videos that are playing\n   * at trigger time.\n   * @private\n   */\n  secondsPlaying_() {\n    for (let i = 0; i < this.entries_.length; i++) {\n      const entry = this.entries_[i];\n      if (entry.getPlayingState() !== PlayingStates.PAUSED) {\n        analyticsEvent(entry, VideoAnalyticsEvents.SECONDS_PLAYED);\n        this.timeUpdateActionEvent_(entry);\n      }\n    }\n    this.timer_.delay(this.boundSecondsPlaying_, SECONDS_PLAYED_MIN_DELAY);\n  }\n\n  /**\n   * Triggers a LOW-TRUST timeupdate event consumable by AMP actions.\n   * Frequency of this event is controlled by SECONDS_PLAYED_MIN_DELAY and is\n   * every 1 second for now.\n   * @param {!VideoEntry} entry\n   * @private\n   */\n  timeUpdateActionEvent_(entry) {\n    const name = 'timeUpdate';\n    const currentTime = entry.video.getCurrentTime();\n    const duration = entry.video.getDuration();\n    if (\n      isFiniteNumber(currentTime) &&\n      isFiniteNumber(duration) &&\n      duration > 0\n    ) {\n      const perc = currentTime / duration;\n      const event = createCustomEvent(\n        this.ampdoc.win,\n        `${TAG}.${name}`,\n        dict({'time': currentTime, 'percent': perc})\n      );\n      this.actions_.trigger(entry.video.element, name, event, ActionTrust.LOW);\n    }\n  }\n\n  // TODO(#30723): create unregister() for cleanup.\n  /** @param {!../video-interface.VideoInterface} video */\n  register(video) {\n    devAssert(video);\n    const videoBE = /** @type {!AMP.BaseElement} */ (video);\n\n    this.registerCommonActions_(video);\n\n    if (!video.supportsPlatform()) {\n      return;\n    }\n\n    if (this.getEntryOrNull_(video)) {\n      // already registered\n      return;\n    }\n\n    if (!this.viewportObserver_) {\n      const viewportCallback = (\n        /** @type {!Array<!IntersectionObserverEntry>} */ records\n      ) =>\n        records.forEach(({isIntersecting, target}) => {\n          this.getEntry_(target).updateVisibility(\n            /* isVisible */ isIntersecting\n          );\n        });\n      this.viewportObserver_ = createViewportObserver(\n        viewportCallback,\n        this.ampdoc.win,\n        {threshold: MIN_VISIBILITY_RATIO_FOR_AUTOPLAY}\n      );\n    }\n    this.viewportObserver_.observe(videoBE.element);\n    listen(videoBE.element, VideoEvents.RELOAD, () => entry.videoLoaded());\n\n    this.entries_ = this.entries_ || [];\n    const entry = new VideoEntry(this, video);\n    this.entries_.push(entry);\n\n    const {element} = entry.video;\n    dispatchCustomEvent(element, VideoEvents.REGISTERED);\n\n    setIsMediaComponent(element);\n\n    // Unlike events, signals are permanent. We can wait for `REGISTERED` at any\n    // moment in the element's lifecycle and the promise will resolve\n    // appropriately each time.\n    const signals = /** @type {!../base-element.BaseElement} */ (\n      video\n    ).signals();\n\n    signals.signal(VideoEvents.REGISTERED);\n\n    // Add a class to element to indicate it implements the video interface.\n    element.classList.add('i-amphtml-video-interface');\n  }\n\n  /**\n   * Register common actions such as play, pause, etc... on the video element\n   * so they can be called using AMP Actions.\n   * For example: <button on=\"tap:myVideo.play\">\n   *\n   * @param {!../video-interface.VideoOrBaseElementDef} video\n   * @private\n   */\n  registerCommonActions_(video) {\n    // Only require ActionTrust.LOW for video actions to defer to platform\n    // specific handling (e.g. user gesture requirement for unmuted playback).\n    const trust = ActionTrust.LOW;\n\n    registerAction('play', () => tryPlay(video, /* isAutoplay */ false));\n    registerAction('pause', () => video.pause());\n    registerAction('mute', () => video.mute());\n    registerAction('unmute', () => video.unmute());\n\n    // fullscreen/fullscreenenter are a special case.\n    // - fullscreenenter is kept as a standard name for symmetry with internal\n    //   internal interfaces\n    // - fullscreen is an undocumented alias for backwards compatibility.\n    const fullscreenEnter = () => video.fullscreenEnter();\n    registerAction('fullscreenenter', fullscreenEnter);\n    registerAction('fullscreen', fullscreenEnter);\n\n    /**\n     * @param {string} action\n     * @param {function()} fn\n     */\n    function registerAction(action, fn) {\n      const videoBE = /** @type {!AMP.BaseElement} */ (video);\n      videoBE.registerAction(\n        action,\n        () => {\n          userInteractedWith(video);\n          fn();\n        },\n        trust\n      );\n    }\n  }\n\n  /**\n   * Returns the entry in the video manager corresponding to the video or\n   * element provided, or null if unavailable.\n   * @param {!../video-interface.VideoOrBaseElementDef|!Element} videoOrElement\n   * @return {?VideoEntry} entry\n   */\n  getEntryOrNull_(videoOrElement) {\n    if (isEntryFor(this.lastFoundEntry_, videoOrElement)) {\n      return this.lastFoundEntry_;\n    }\n\n    for (let i = 0; this.entries_ && i < this.entries_.length; i++) {\n      const entry = this.entries_[i];\n      if (isEntryFor(entry, videoOrElement)) {\n        this.lastFoundEntry_ = entry;\n        return entry;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns the entry in the video manager corresponding to the video or\n   * element provided\n   * @param {!../video-interface.VideoOrBaseElementDef|!Element} videoOrElement\n   * @return {VideoEntry} entry\n   */\n  getEntry_(videoOrElement) {\n    return devAssert(\n      this.getEntryOrNull_(videoOrElement),\n      '%s not registered to VideoManager',\n      videoOrElement.element || videoOrElement\n    );\n  }\n\n  /** @param {!VideoEntry} entry */\n  registerForAutoFullscreen(entry) {\n    this.getAutoFullscreenManager_().register(entry);\n  }\n\n  /**\n   * @return {!AutoFullscreenManager}\n   * @visibleForTesting\n   */\n  getAutoFullscreenManagerForTesting_() {\n    return this.getAutoFullscreenManager_();\n  }\n\n  /**\n   * Gets the current analytics details property for the given video.\n   * Fails silently if the video is not registered.\n   * @param {string} id\n   * @param {string} property\n   * @return {!Promise<string>}\n   */\n  getVideoStateProperty(id, property) {\n    const root = this.ampdoc.getRootNode();\n    const videoElement = user().assertElement(\n      root.getElementById(/** @type {string} */ (id)),\n      `Could not find an element with id=\"${id}\" for VIDEO_STATE`\n    );\n    const entry = this.getEntry_(videoElement);\n    return (entry ? entry.getAnalyticsDetails() : Promise.resolve()).then(\n      (details) => (details ? details[property] : '')\n    );\n  }\n\n  // TODO(go.amp.dev/issue/27010): For getters below, let's expose VideoEntry\n  // instead and use directly. This is better for size and sanity. Users can\n  // also then keep the entry reference for their own use.\n  // (Can't expose yet due to package-level methods to be restructured, e.g\n  // videoLoaded(). See issue)\n\n  /**\n   * Returns whether the video is paused or playing after the user interacted\n   * with it or playing through autoplay\n   *\n   * @param {!../video-interface.VideoOrBaseElementDef|!Element} videoOrElement\n   * @return {!../video-interface.PlayingStateDef}\n   */\n  getPlayingState(videoOrElement) {\n    return this.getEntry_(videoOrElement).getPlayingState();\n  }\n\n  /**\n   * @param {!../video-interface.VideoOrBaseElementDef|!Element} videoOrElement\n   * @return {boolean}\n   */\n  isMuted(videoOrElement) {\n    return this.getEntry_(videoOrElement).isMuted();\n  }\n\n  /**\n   * @param {!../video-interface.VideoOrBaseElementDef|!Element} videoOrElement\n   * @return {boolean}\n   */\n  userInteracted(videoOrElement) {\n    return this.getEntry_(videoOrElement).userInteracted();\n  }\n\n  /**\n   * @param {!../video-interface.VideoOrBaseElementDef|!Element} videoOrElement\n   * @return {boolean}\n   */\n  isRollingAd(videoOrElement) {\n    return this.getEntry_(videoOrElement).isRollingAd();\n  }\n\n  /**\n   * @param {!VideoEntry} entryBeingPlayed\n   */\n  pauseOtherVideos(entryBeingPlayed) {\n    this.entries_.forEach((entry) => {\n      if (\n        entry.isPlaybackManaged() &&\n        entry !== entryBeingPlayed &&\n        entry.getPlayingState() == PlayingStates.PLAYING_MANUAL\n      ) {\n        entry.video.pause();\n      }\n    });\n  }\n}\n\n/**\n * @param {?VideoEntry=} entry\n * @param {?../video-interface.VideoOrBaseElementDef|!Element=} videoOrElement\n * @return {boolean}\n */\nconst isEntryFor = (entry, videoOrElement) =>\n  !!entry &&\n  (entry.video === videoOrElement || entry.video.element === videoOrElement);\n\n/**\n * VideoEntry represents an entry in the VideoManager's list.\n */\nclass VideoEntry {\n  /**\n   * @param {!VideoManager} manager\n   * @param {!../video-interface.VideoOrBaseElementDef} video\n   */\n  constructor(manager, video) {\n    /** @private @const {!VideoManager} */\n    this.manager_ = manager;\n\n    /** @private @const {!./ampdoc-impl.AmpDoc}  */\n    this.ampdoc_ = manager.ampdoc;\n\n    /** @package @const {!../video-interface.VideoOrBaseElementDef} */\n    this.video = video;\n\n    /** @private {boolean} */\n    this.managePlayback_ = true;\n\n    /** @private {boolean} */\n    this.loaded_ = false;\n\n    /** @private {boolean} */\n    this.isPlaying_ = false;\n\n    /** @private {boolean} */\n    this.isRollingAd_ = false;\n\n    /** @private {boolean} */\n    this.isVisible_ = false;\n\n    /** @private @const */\n    this.actionSessionManager_ = new VideoSessionManager();\n\n    this.actionSessionManager_.onSessionEnd(() =>\n      analyticsEvent(this, VideoAnalyticsEvents.SESSION)\n    );\n\n    /** @private @const */\n    this.visibilitySessionManager_ = new VideoSessionManager();\n\n    this.visibilitySessionManager_.onSessionEnd(() =>\n      analyticsEvent(this, VideoAnalyticsEvents.SESSION_VISIBLE)\n    );\n\n    /** @private @const {function(): !AnalyticsPercentageTracker} */\n    this.getAnalyticsPercentageTracker_ = once(\n      () => new AnalyticsPercentageTracker(this.ampdoc_.win, this)\n    );\n\n    // Autoplay Variables\n\n    /** @private {boolean} */\n    this.playCalledByAutoplay_ = false;\n\n    /** @private {boolean} */\n    this.pauseCalledByAutoplay_ = false;\n\n    /** @private {?Element} */\n    this.internalElement_ = null;\n\n    /** @private {boolean} */\n    this.muted_ = false;\n\n    /** @private {boolean} */\n    this.hasSeenPlayEvent_ = false;\n\n    this.hasAutoplay = video.element.hasAttribute(VideoAttributes.AUTOPLAY);\n\n    if (this.hasAutoplay) {\n      this.manager_.installAutoplayStyles();\n    }\n\n    // Media Session API Variables\n\n    /** @private {!../mediasession-helper.MetadataDef} */\n    this.metadata_ = EMPTY_METADATA;\n\n    /** @private @const {function()} */\n    this.boundMediasessionPlay_ = () => {\n      tryPlay(this.video, /* isAutoplay */ false);\n    };\n\n    /** @private @const {function()} */\n    this.boundMediasessionPause_ = () => {\n      this.video.pause();\n    };\n\n    listen(video.element, VideoEvents.LOAD, () => this.videoLoaded());\n    listen(video.element, VideoEvents.PAUSE, () => this.videoPaused_());\n    listen(video.element, VideoEvents.PLAY, () => {\n      this.hasSeenPlayEvent_ = true;\n      analyticsEvent(this, VideoAnalyticsEvents.PLAY);\n    });\n    listen(video.element, VideoEvents.PLAYING, () => this.videoPlayed_());\n    listen(video.element, VideoEvents.MUTED, () => (this.muted_ = true));\n    listen(video.element, VideoEvents.UNMUTED, () => {\n      this.muted_ = false;\n      this.manager_.pauseOtherVideos(this);\n    });\n\n    listen(video.element, VideoEvents.CUSTOM_TICK, (e) => {\n      const data = getData(e);\n      const eventType = data['eventType'];\n      if (!eventType) {\n        // CUSTOM_TICK is a generic event for 3p players whose semantics\n        // don't fit with other video events.\n        // If `eventType` is unset, it's not meant for analytics.\n        return;\n      }\n      this.logCustomAnalytics_(eventType, data['vars']);\n    });\n\n    listen(video.element, VideoEvents.ENDED, () => {\n      this.isRollingAd_ = false;\n      analyticsEvent(this, VideoAnalyticsEvents.ENDED);\n    });\n\n    listen(video.element, VideoEvents.AD_START, () => {\n      this.isRollingAd_ = true;\n      analyticsEvent(this, VideoAnalyticsEvents.AD_START);\n    });\n\n    listen(video.element, VideoEvents.AD_END, () => {\n      this.isRollingAd_ = false;\n      analyticsEvent(this, VideoAnalyticsEvents.AD_END);\n    });\n\n    video\n      .signals()\n      .whenSignal(VideoEvents.REGISTERED)\n      .then(() => this.onRegister_());\n\n    /**\n     * Trigger event for first manual play.\n     * @private @const {!function()}\n     */\n    this.firstPlayEventOrNoop_ = once(() => {\n      const firstPlay = 'firstPlay';\n      const trust = ActionTrust.LOW;\n      const event = createCustomEvent(\n        this.ampdoc_.win,\n        firstPlay,\n        /* detail */ dict({})\n      );\n      const {element} = this.video;\n      const actions = Services.actionServiceForDoc(element);\n      actions.trigger(element, firstPlay, event, trust);\n    });\n\n    this.listenForPlaybackDelegation_();\n  }\n\n  /** @public */\n  dispose() {\n    this.getAnalyticsPercentageTracker_().stop();\n  }\n\n  /**\n   * @param {string} eventType\n   * @param {!Object<string, string>} vars\n   */\n  logCustomAnalytics_(eventType, vars) {\n    const prefixedVars = {[videoAnalyticsCustomEventTypeKey]: eventType};\n\n    Object.keys(vars).forEach((key) => {\n      prefixedVars[`custom_${key}`] = vars[key];\n    });\n\n    analyticsEvent(this, VideoAnalyticsEvents.CUSTOM, prefixedVars);\n  }\n\n  /** Listens for signals to delegate playback to a different module. */\n  listenForPlaybackDelegation_() {\n    const signals = this.video.signals();\n    signals.whenSignal(VideoServiceSignals.PLAYBACK_DELEGATED).then(() => {\n      this.managePlayback_ = false;\n\n      if (this.isPlaying_) {\n        this.video.pause();\n      }\n    });\n  }\n\n  /** @return {boolean} */\n  isMuted() {\n    return this.muted_;\n  }\n\n  /** @return {boolean} */\n  isPlaybackManaged() {\n    return this.managePlayback_;\n  }\n\n  /** @private */\n  onRegister_() {\n    if (this.requiresAutoFullscreen_()) {\n      this.manager_.registerForAutoFullscreen(this);\n    }\n\n    if (this.hasAutoplay) {\n      this.autoplayVideoBuilt_();\n    }\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  requiresAutoFullscreen_() {\n    const {element} = this.video;\n    if (\n      this.video.preimplementsAutoFullscreen() ||\n      !element.hasAttribute(VideoAttributes.ROTATE_TO_FULLSCREEN)\n    ) {\n      return false;\n    }\n    return userAssert(\n      this.video.isInteractive(),\n      'Only interactive videos are allowed to enter fullscreen on rotate. ' +\n        'Set the `controls` attribute on %s to enable.',\n      element\n    );\n  }\n\n  /**\n   * Callback for when the video starts playing\n   * @private\n   */\n  videoPlayed_() {\n    this.isPlaying_ = true;\n\n    if (this.getPlayingState() == PlayingStates.PLAYING_MANUAL) {\n      this.firstPlayEventOrNoop_();\n      this.manager_.pauseOtherVideos(this);\n    }\n\n    const {video} = this;\n    const {element} = video;\n\n    if (\n      !video.preimplementsMediaSessionAPI() &&\n      !element.classList.contains('i-amphtml-disable-mediasession')\n    ) {\n      validateMediaMetadata(element, this.metadata_);\n      setMediaSession(\n        this.ampdoc_.win,\n        this.metadata_,\n        this.boundMediasessionPlay_,\n        this.boundMediasessionPause_\n      );\n    }\n\n    this.actionSessionManager_.beginSession();\n    if (this.isVisible_) {\n      this.visibilitySessionManager_.beginSession();\n    }\n\n    // The PLAY event was omitted from the original VideoInterface. Thus\n    // not every implementation emits it. It should always happen before\n    // PLAYING. Hence we treat the PLAYING as an indication to emit the\n    // Analytics PLAY event if we haven't seen PLAY.\n    if (!this.hasSeenPlayEvent_) {\n      analyticsEvent(this, VideoAnalyticsEvents.PLAY);\n    }\n  }\n\n  /**\n   * Callback for when the video has been paused\n   * @private\n   */\n  videoPaused_() {\n    analyticsEvent(this, VideoAnalyticsEvents.PAUSE);\n    this.isPlaying_ = false;\n\n    // Prevent double-trigger of session if video is autoplay and the video\n    // is paused by a the user scrolling the video out of view.\n    if (!this.pauseCalledByAutoplay_) {\n      this.actionSessionManager_.endSession();\n    } else {\n      // reset the flag\n      this.pauseCalledByAutoplay_ = false;\n    }\n  }\n  /**\n   * Called when the video is loaded and can play.\n   */\n  videoLoaded() {\n    this.loaded_ = true;\n\n    this.internalElement_ = getInternalVideoElementFor(this.video.element);\n\n    this.fillMediaSessionMetadata_();\n\n    this.getAnalyticsPercentageTracker_().start();\n\n    if (this.isVisible_) {\n      // Handles the case when the video becomes visible before loading\n      this.loadedVideoVisibilityChanged_();\n    }\n  }\n\n  /**\n   * Gets the provided metadata and fills in missing fields\n   * @private\n   */\n  fillMediaSessionMetadata_() {\n    if (this.video.preimplementsMediaSessionAPI()) {\n      return;\n    }\n\n    if (this.video.getMetadata()) {\n      this.metadata_ = map(\n        /** @type {!../mediasession-helper.MetadataDef} */\n        (this.video.getMetadata())\n      );\n    }\n\n    const doc = this.ampdoc_.win.document;\n\n    if (!this.metadata_.artwork || this.metadata_.artwork.length == 0) {\n      const posterUrl =\n        parseSchemaImage(doc) || parseOgImage(doc) || parseFavicon(doc);\n\n      if (posterUrl) {\n        this.metadata_.artwork = [\n          {\n            'src': posterUrl,\n          },\n        ];\n      }\n    }\n\n    if (!this.metadata_.title) {\n      const title =\n        this.video.element.getAttribute('title') ||\n        this.video.element.getAttribute('aria-label') ||\n        this.internalElement_.getAttribute('title') ||\n        this.internalElement_.getAttribute('aria-label') ||\n        doc.title;\n      if (title) {\n        this.metadata_.title = title;\n      }\n    }\n  }\n\n  /**\n   * Called when visibility of a video changes.\n   * @private\n   */\n  videoVisibilityChanged_() {\n    if (this.loaded_) {\n      this.loadedVideoVisibilityChanged_();\n    }\n  }\n\n  /**\n   * Only called when visibility of a loaded video changes.\n   * @private\n   */\n  loadedVideoVisibilityChanged_() {\n    if (!this.ampdoc_.isVisible()) {\n      return;\n    }\n    isAutoplaySupported(this.ampdoc_.win).then((isAutoplaySupported) => {\n      const canAutoplay = this.hasAutoplay && !this.userInteracted();\n\n      if (canAutoplay && isAutoplaySupported) {\n        this.autoplayLoadedVideoVisibilityChanged_();\n      } else {\n        this.nonAutoplayLoadedVideoVisibilityChanged_();\n      }\n    });\n  }\n\n  /* Autoplay Behavior */\n\n  /**\n   * Called when an autoplay video is built.\n   * @private\n   */\n  autoplayVideoBuilt_() {\n    // Hide controls until we know if autoplay is supported, otherwise hiding\n    // and showing the controls quickly becomes a bad user experience for the\n    // common case where autoplay is supported.\n    if (this.video.isInteractive()) {\n      this.video.hideControls();\n    }\n\n    isAutoplaySupported(this.ampdoc_.win).then((isAutoplaySupported) => {\n      if (!isAutoplaySupported && this.video.isInteractive()) {\n        // Autoplay is not supported, show the controls so user can manually\n        // initiate playback.\n        this.video.showControls();\n        return;\n      }\n\n      // Only muted videos are allowed to autoplay\n      this.video.mute();\n\n      this.installAutoplayElements_();\n    });\n  }\n\n  /**\n   * Installs autoplay animation and interaction mask when interactive.\n   * The animated icon is appended always, but only displayed by CSS when\n   * `controls` is set. See `video-autoplay.css`.\n   * @private\n   */\n  installAutoplayElements_() {\n    const {video} = this;\n    const {element, win} = this.video;\n\n    if (\n      element.hasAttribute(VideoAttributes.NO_AUDIO) ||\n      element.signals().get(VideoServiceSignals.USER_INTERACTED)\n    ) {\n      return;\n    }\n\n    const animation = renderIcon(win, element);\n    const children = [animation];\n\n    /** @param {boolean} shouldDisplay */\n    function toggleElements(shouldDisplay) {\n      video.mutateElementSkipRemeasure(() => {\n        children.forEach((child) => {\n          toggle(child, shouldDisplay);\n        });\n      });\n    }\n\n    /** @param {boolean} isPlaying */\n    function toggleAnimation(isPlaying) {\n      video.mutateElementSkipRemeasure(() =>\n        animation.classList.toggle('amp-video-eq-play', isPlaying)\n      );\n    }\n\n    const unlisteners = [\n      listen(element, VideoEvents.PAUSE, () => toggleAnimation(false)),\n      listen(element, VideoEvents.PLAYING, () => toggleAnimation(true)),\n      listen(element, VideoEvents.AD_START, () => {\n        toggleElements(false);\n        video.showControls();\n      }),\n      listen(element, VideoEvents.AD_END, () => {\n        toggleElements(true);\n        video.hideControls();\n      }),\n      listen(element, VideoEvents.UNMUTED, () => userInteractedWith(video)),\n    ];\n\n    if (video.isInteractive()) {\n      video.hideControls();\n\n      const mask = renderInteractionOverlay(element, this.metadata_);\n      children.push(mask);\n      unlisteners.push(listen(mask, 'click', () => userInteractedWith(video)));\n    }\n\n    video.mutateElementSkipRemeasure(() => {\n      children.forEach((child) => {\n        element.appendChild(child);\n      });\n    });\n\n    if (this.isRollingAd_) {\n      toggleElements(false);\n    }\n\n    video\n      .signals()\n      .whenSignal(VideoServiceSignals.USER_INTERACTED)\n      .then(() => {\n        this.firstPlayEventOrNoop_();\n        if (video.isInteractive()) {\n          video.showControls();\n        }\n        video.unmute();\n        unlisteners.forEach((unlistener) => {\n          unlistener();\n        });\n        video.mutateElementSkipRemeasure(() => {\n          children.forEach((child) => {\n            removeElement(child);\n          });\n        });\n      });\n  }\n\n  /**\n   * Called when visibility of a loaded autoplay video changes.\n   * @private\n   */\n  autoplayLoadedVideoVisibilityChanged_() {\n    if (!this.managePlayback_) {\n      return;\n    }\n    if (this.isVisible_) {\n      this.visibilitySessionManager_.beginSession();\n      tryPlay(this.video, /*autoplay*/ true);\n      this.playCalledByAutoplay_ = true;\n    } else {\n      if (this.isPlaying_) {\n        this.visibilitySessionManager_.endSession();\n      }\n      this.video.pause();\n      this.pauseCalledByAutoplay_ = true;\n    }\n  }\n\n  /**\n   * Called when visibility of a loaded non-autoplay video changes.\n   * @private\n   */\n  nonAutoplayLoadedVideoVisibilityChanged_() {\n    if (this.isVisible_) {\n      this.visibilitySessionManager_.beginSession();\n    } else if (this.isPlaying_) {\n      this.visibilitySessionManager_.endSession();\n    }\n  }\n\n  /**\n   * Called by an IntersectionObserver.\n   * @param {boolean} isVisible\n   * @package\n   */\n  updateVisibility(isVisible) {\n    const wasVisible = this.isVisible_;\n    this.isVisible_ = isVisible;\n    if (isVisible != wasVisible) {\n      this.videoVisibilityChanged_();\n    }\n  }\n\n  /**\n   * Returns whether the video is paused or playing after the user interacted\n   * with it or playing through autoplay\n   * @return {!../video-interface.PlayingStateDef}\n   */\n  getPlayingState() {\n    if (!this.isPlaying_) {\n      return PlayingStates.PAUSED;\n    }\n\n    if (\n      this.isPlaying_ &&\n      this.playCalledByAutoplay_ &&\n      !this.userInteracted()\n    ) {\n      return PlayingStates.PLAYING_AUTO;\n    }\n\n    return PlayingStates.PLAYING_MANUAL;\n  }\n\n  /** @return {boolean} */\n  isRollingAd() {\n    return this.isRollingAd_;\n  }\n\n  /**\n   * Returns whether the video was interacted with or not\n   * @return {boolean}\n   */\n  userInteracted() {\n    return (\n      this.video.signals().get(VideoServiceSignals.USER_INTERACTED) != null\n    );\n  }\n\n  /**\n   * Collects a snapshot of the current video state for video analytics\n   * @return {!Promise<!VideoAnalyticsDetailsDef>}\n   */\n  getAnalyticsDetails() {\n    const {video} = this;\n    return Promise.all([\n      isAutoplaySupported(this.ampdoc_.win),\n      measureIntersection(video.element),\n    ]).then((responses) => {\n      const isAutoplaySupported = /** @type {boolean} */ (responses[0]);\n      const intersection = /** @type {!IntersectionObserverEntry} */ (\n        responses[1]\n      );\n      const {height, width} = intersection.boundingClientRect;\n      const autoplay = this.hasAutoplay && isAutoplaySupported;\n      const playedRanges = video.getPlayedRanges();\n      const playedTotal = playedRanges.reduce(\n        (acc, range) => acc + range[1] - range[0],\n        0\n      );\n\n      return {\n        'autoplay': autoplay,\n        'currentTime': video.getCurrentTime(),\n        'duration': video.getDuration(),\n        // TODO(cvializ): add fullscreen\n        'height': height,\n        'id': video.element.id,\n        'muted': this.muted_,\n        'playedTotal': playedTotal,\n        'playedRangesJson': JSON.stringify(playedRanges),\n        'state': this.getPlayingState(),\n        'width': width,\n      };\n    });\n  }\n}\n\n/**\n * @param {!AmpElement} video\n * @return {boolean}\n * @restricted\n */\nfunction supportsFullscreenViaApi(video) {\n  // TODO(alanorozco): Determine this via a flag in the component itself.\n  return !!{\n    'amp-dailymotion': true,\n    'amp-ima-video': true,\n  }[video.tagName.toLowerCase()];\n}\n\n/** Manages rotate-to-fullscreen video. */\nexport class AutoFullscreenManager {\n  /**\n   * @param {!./ampdoc-impl.AmpDoc} ampdoc\n   * @param {!VideoManager} manager\n   */\n  constructor(ampdoc, manager) {\n    /** @private @const {!VideoManager} */\n    this.manager_ = manager;\n\n    /** @private @const {!./ampdoc-impl.AmpDoc} */\n    this.ampdoc_ = ampdoc;\n\n    /** @private {?../video-interface.VideoOrBaseElementDef} */\n    this.currentlyInFullscreen_ = null;\n\n    /** @private {?../video-interface.VideoOrBaseElementDef} */\n    this.currentlyCentered_ = null;\n\n    /** @private @const {!Array<!../video-interface.VideoOrBaseElementDef>} */\n    this.entries_ = [];\n\n    /**\n     * Unlisteners for global objects\n     * @private {!Array<!UnlistenDef>}\n     */\n    this.unlisteners_ = [];\n\n    // eslint-disable-next-line jsdoc/require-returns\n    /** @private @const {function()} */\n    this.boundSelectBestCentered_ = () => this.selectBestCenteredInPortrait_();\n\n    /**\n     * @param {!../video-interface.VideoOrBaseElementDef} video\n     * @return {boolean}\n     */\n    this.boundIncludeOnlyPlaying_ = (video) =>\n      this.getPlayingState_(video) == PlayingStates.PLAYING_MANUAL;\n\n    /**\n     * @param {!IntersectionObserverEntry} a\n     * @param {!IntersectionObserverEntry} b\n     * @return {number}\n     */\n    this.boundCompareEntries_ = (a, b) => this.compareEntries_(a, b);\n\n    this.installOrientationObserver_();\n    this.installFullscreenListener_();\n  }\n\n  /** @public */\n  dispose() {\n    this.unlisteners_.forEach((unlisten) => unlisten());\n    this.unlisteners_.length = 0;\n  }\n\n  /** @param {!VideoEntry} entry */\n  register(entry) {\n    const {video} = entry;\n    const {element} = video;\n\n    if (!this.canFullscreen_(element)) {\n      return;\n    }\n\n    this.entries_.push(video);\n\n    listen(element, VideoEvents.PAUSE, this.boundSelectBestCentered_);\n    listen(element, VideoEvents.PLAYING, this.boundSelectBestCentered_);\n    listen(element, VideoEvents.ENDED, this.boundSelectBestCentered_);\n\n    video\n      .signals()\n      .whenSignal(VideoServiceSignals.USER_INTERACTED)\n      .then(this.boundSelectBestCentered_);\n\n    // Set always\n    this.selectBestCenteredInPortrait_();\n  }\n\n  /** @private */\n  installFullscreenListener_() {\n    const root = this.ampdoc_.getRootNode();\n    const exitHandler = () => this.onFullscreenExit_();\n    this.unlisteners_.push(\n      listen(root, 'webkitfullscreenchange', exitHandler),\n      listen(root, 'mozfullscreenchange', exitHandler),\n      listen(root, 'fullscreenchange', exitHandler),\n      listen(root, 'MSFullscreenChange', exitHandler)\n    );\n  }\n\n  /**\n   * @return {boolean}\n   * @visibleForTesting\n   */\n  isInLandscape() {\n    return isLandscape(this.ampdoc_.win);\n  }\n\n  /**\n   * @param {!AmpElement} video\n   * @return {boolean}\n   * @private\n   */\n  canFullscreen_(video) {\n    // Safari and iOS can only fullscreen <video> elements directly. In cases\n    // where the player component is implemented via an <iframe>, we need to\n    // rely on a postMessage API to fullscreen. Such an API is not necessarily\n    // provided by every player.\n    const internalElement = getInternalVideoElementFor(video);\n    if (internalElement.tagName.toLowerCase() == 'video') {\n      return true;\n    }\n    const platform = Services.platformFor(this.ampdoc_.win);\n    if (!(platform.isIos() || platform.isSafari())) {\n      return true;\n    }\n    return supportsFullscreenViaApi(video);\n  }\n\n  /** @private */\n  onFullscreenExit_() {\n    this.currentlyInFullscreen_ = null;\n  }\n\n  /** @private */\n  installOrientationObserver_() {\n    // TODO(alanorozco) Update based on support\n    const {win} = this.ampdoc_;\n    const {screen} = win;\n    // Chrome considers 'orientationchange' to be an untrusted event, but\n    // 'change' on screen.orientation is considered a user interaction.\n    // We still need to listen to 'orientationchange' on Chrome in order to\n    // exit fullscreen since 'change' does not fire in this case.\n    if (screen && 'orientation' in screen) {\n      const orient = /** @type {!ScreenOrientation} */ (screen.orientation);\n      this.unlisteners_.push(\n        listen(orient, 'change', () => this.onRotation_())\n      );\n    }\n    // iOS Safari does not have screen.orientation but classifies\n    // 'orientationchange' as a user interaction.\n    this.unlisteners_.push(\n      listen(win, 'orientationchange', () => this.onRotation_())\n    );\n  }\n\n  /** @private */\n  onRotation_() {\n    if (this.isInLandscape()) {\n      if (this.currentlyCentered_ != null) {\n        this.enter_(this.currentlyCentered_);\n      }\n      return;\n    }\n    if (this.currentlyInFullscreen_) {\n      this.exit_(this.currentlyInFullscreen_);\n    }\n  }\n\n  /**\n   * @param {!../video-interface.VideoOrBaseElementDef} video\n   * @private\n   */\n  enter_(video) {\n    const platform = Services.platformFor(this.ampdoc_.win);\n\n    this.currentlyInFullscreen_ = video;\n\n    if (platform.isAndroid() && platform.isChrome()) {\n      // Chrome on Android somehow knows what we're doing and executes a nice\n      // transition by default. Delegating to browser.\n      video.fullscreenEnter();\n      return;\n    }\n\n    this.scrollIntoIfNotVisible_(video).then(() => video.fullscreenEnter());\n  }\n\n  /**\n   * @param {!../video-interface.VideoOrBaseElementDef} video\n   * @private\n   */\n  exit_(video) {\n    this.currentlyInFullscreen_ = null;\n\n    this.scrollIntoIfNotVisible_(video, 'center').then(() =>\n      video.fullscreenExit()\n    );\n  }\n\n  /**\n   * Scrolls to a video if it's not in view.\n   * @param {!../video-interface.VideoOrBaseElementDef} video\n   * @param {?string=} optPos\n   * @return {!Promise}\n   * @private\n   */\n  scrollIntoIfNotVisible_(video, optPos = null) {\n    const {element} = video;\n    const viewport = this.getViewport_();\n\n    return this.onceOrientationChanges_()\n      .then(() => measureIntersection(element))\n      .then(({boundingClientRect}) => {\n        const {bottom, top} = boundingClientRect;\n        const vh = viewport.getSize().height;\n        const fullyVisible = top >= 0 && bottom <= vh;\n        if (fullyVisible) {\n          return Promise.resolve();\n        }\n        const pos = optPos\n          ? dev().assertString(optPos)\n          : bottom > vh\n          ? 'bottom'\n          : 'top';\n        return viewport.animateScrollIntoView(element, pos);\n      });\n  }\n\n  /**\n   * @private\n   * @return {./viewport/viewport-interface.ViewportInterface}\n   */\n  getViewport_() {\n    return Services.viewportForDoc(this.ampdoc_);\n  }\n\n  /**\n   * @private\n   * @return {!Promise}\n   */\n  onceOrientationChanges_() {\n    const magicNumber = 330;\n    return Services.timerFor(this.ampdoc_.win).promise(magicNumber);\n  }\n\n  /**\n   * @private\n   * @return {!Promise<?../video-interface.VideoOrBaseElementDef>}\n   */\n  selectBestCenteredInPortrait_() {\n    if (this.isInLandscape()) {\n      return Promise.resolve(this.currentlyCentered_);\n    }\n\n    this.currentlyCentered_ = null;\n\n    const intersectionsPromise = this.entries_\n      .filter(this.boundIncludeOnlyPlaying_)\n      .map((e) => measureIntersection(e.element));\n\n    return Promise.all(intersectionsPromise).then((intersections) => {\n      const selected = intersections.sort(this.boundCompareEntries_)[0];\n\n      if (\n        selected &&\n        selected.intersectionRatio > MIN_VISIBILITY_RATIO_FOR_AUTOPLAY\n      ) {\n        return selected.target\n          .getImpl()\n          .then((video) => (this.currentlyCentered_ = video));\n      }\n\n      return this.currentlyCentered_;\n    });\n  }\n\n  /**\n   * Compares two videos in order to sort them by \"best centered\".\n   * @param {!IntersectionObserverEntry} a\n   * @param {!IntersectionObserverEntry} b\n   * @return {number}\n   */\n  compareEntries_(a, b) {\n    const {boundingClientRect: rectA, intersectionRatio: ratioA} = a;\n    const {boundingClientRect: rectB, intersectionRatio: ratioB} = b;\n\n    // Prioritize by how visible they are, with a tolerance of 10%\n    const ratioTolerance = 0.1;\n    const ratioDelta = ratioA - ratioB;\n    if (Math.abs(ratioDelta) > ratioTolerance) {\n      return ratioDelta;\n    }\n\n    // Prioritize by distance from center.\n    const viewport = Services.viewportForDoc(this.ampdoc_);\n    const centerA = centerDist(viewport, rectA);\n    const centerB = centerDist(viewport, rectB);\n    if (centerA < centerB || centerA > centerB) {\n      return centerA - centerB;\n    }\n\n    // Everything else failing, choose the highest element.\n    return rectA.top - rectB.top;\n  }\n\n  /**\n   * @param {!../video-interface.VideoOrBaseElementDef} video\n   * @return {!../video-interface.PlayingStateDef}\n   * @private\n   */\n  getPlayingState_(video) {\n    return this.manager_.getPlayingState(\n      /** @type {!../video-interface.VideoInterface} */ (video)\n    );\n  }\n}\n\n/**\n * @param {!./viewport/viewport-interface.ViewportInterface} viewport\n * @param {{top: number, height: number}} rect\n * @return {number}\n */\nfunction centerDist(viewport, rect) {\n  const centerY = rect.top + rect.height / 2;\n  const centerViewport = viewport.getSize().height / 2;\n  return Math.abs(centerY - centerViewport);\n}\n\n/**\n * @param {!Window} win\n * @return {boolean}\n */\nfunction isLandscape(win) {\n  if (win.screen && 'orientation' in win.screen) {\n    return win.screen.orientation.type.startsWith('landscape');\n  }\n  return Math.abs(win.orientation) == 90;\n}\n\n/** @visibleForTesting */\nexport const PERCENTAGE_INTERVAL = 5;\n\n/** @visibleForTesting */\nexport const PERCENTAGE_FREQUENCY_WHEN_PAUSED_MS = 500;\n\n/** @private */\nconst PERCENTAGE_FREQUENCY_MIN_MS = 250;\n\n/** @private */\nconst PERCENTAGE_FREQUENCY_MAX_MS = 4000;\n\n/**\n * Calculates the \"ideal\" analytics check frequency from playback start, e.g.\n * the amount of ms after each PERCENTAGE_INTERVAL.\n * @param {number} durationSeconds\n * @return {number}\n */\nfunction calculateIdealPercentageFrequencyMs(durationSeconds) {\n  return durationSeconds * 10 * PERCENTAGE_INTERVAL;\n}\n\n/**\n * Calculates the \"actual\" analytics check frequency by calculating the ideal\n * frequency and clamping it between MIN and MAX.\n * @param {number} durationSeconds\n * @return {number}\n */\nfunction calculateActualPercentageFrequencyMs(durationSeconds) {\n  return clamp(\n    calculateIdealPercentageFrequencyMs(durationSeconds),\n    PERCENTAGE_FREQUENCY_MIN_MS,\n    PERCENTAGE_FREQUENCY_MAX_MS\n  );\n}\n\n/**\n * Handle cases such as livestreams or videos with no duration information is\n * available, where 1 second is the default duration for some video players.\n * @param {?number=} duration\n * @return {boolean}\n */\nconst isDurationFiniteNonZero = (duration) =>\n  !!duration && !isNaN(duration) && duration > 1;\n\n/** @visibleForTesting */\nexport class AnalyticsPercentageTracker {\n  /**\n   * @param {!Window} win\n   * @param {!VideoEntry} entry\n   */\n  constructor(win, entry) {\n    // This is destructured in `calculate_()`, but the linter thinks it's unused\n    /** @private @const {!./timer-impl.Timer} */\n    this.timer_ = Services.timerFor(win);\n\n    /** @private @const {!VideoEntry} */\n    this.entry_ = entry;\n\n    /** @private {?Array<!UnlistenDef>} */\n    this.unlisteners_ = null;\n\n    /** @private {number} */\n    this.last_ = 0;\n\n    /**\n     * Counter for each trigger `start`. This is to prevent duplicate events if\n     * two consecutive triggers take place, or to prevent events firing once\n     * the tracker is stopped.\n     * @private {number}\n     */\n    this.triggerId_ = 0;\n  }\n\n  /** @public */\n  start() {\n    const {element} = this.entry_.video;\n\n    this.stop();\n\n    this.unlisteners_ = this.unlisteners_ || [];\n\n    // If the video has already emitted LOADEDMETADATA, the event below\n    // will never fire, so we check if it's already available here.\n    if (this.hasDuration_()) {\n      this.calculate_(this.triggerId_);\n    } else {\n      this.unlisteners_.push(\n        listenOnce(element, VideoEvents.LOADEDMETADATA, () => {\n          if (this.hasDuration_()) {\n            this.calculate_(this.triggerId_);\n          }\n        })\n      );\n    }\n\n    this.unlisteners_.push(\n      listen(element, VideoEvents.ENDED, () => {\n        if (this.hasDuration_()) {\n          this.maybeTrigger_(/* normalizedPercentage */ 100);\n        }\n      })\n    );\n  }\n\n  /** @public */\n  stop() {\n    if (!this.unlisteners_) {\n      return;\n    }\n    while (this.unlisteners_.length > 0) {\n      this.unlisteners_.pop()();\n    }\n    this.triggerId_++;\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  hasDuration_() {\n    const {video} = this.entry_;\n    const duration = video.getDuration();\n\n    if (!isDurationFiniteNonZero(duration)) {\n      return false;\n    }\n\n    if (\n      calculateIdealPercentageFrequencyMs(duration) <\n      PERCENTAGE_FREQUENCY_MIN_MS\n    ) {\n      const bestResultLength = Math.ceil(\n        (PERCENTAGE_FREQUENCY_MIN_MS * (100 / PERCENTAGE_INTERVAL)) / 1000\n      );\n\n      this.warnForTesting_(\n        'This video is too short for `video-percentage-played`. ' +\n          'Reports may be innacurate. For best results, use videos over',\n        bestResultLength,\n        'seconds long.',\n        video.element\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * @param  {...*} args\n   * @private\n   */\n  warnForTesting_(...args) {\n    user().warn.apply(user(), [TAG].concat(args));\n  }\n\n  /**\n   * @param {number=} triggerId\n   * @private\n   */\n  calculate_(triggerId) {\n    if (triggerId != this.triggerId_) {\n      return;\n    }\n\n    const {entry_: entry, timer_: timer} = this;\n    const {video} = entry;\n\n    const calculateAgain = () => this.calculate_(triggerId);\n\n    if (entry.getPlayingState() == PlayingStates.PAUSED) {\n      timer.delay(calculateAgain, PERCENTAGE_FREQUENCY_WHEN_PAUSED_MS);\n      return;\n    }\n\n    const duration = video.getDuration();\n    // TODO(#25954): Further investigate root cause and remove this protection\n    // if appropriate.\n    if (!isDurationFiniteNonZero(duration)) {\n      timer.delay(calculateAgain, PERCENTAGE_FREQUENCY_WHEN_PAUSED_MS);\n      return;\n    }\n\n    const frequencyMs = calculateActualPercentageFrequencyMs(duration);\n\n    const percentage = (video.getCurrentTime() / duration) * 100;\n    const normalizedPercentage =\n      Math.floor(percentage / PERCENTAGE_INTERVAL) * PERCENTAGE_INTERVAL;\n\n    devAssert(isFiniteNumber(normalizedPercentage));\n\n    this.maybeTrigger_(normalizedPercentage);\n\n    timer.delay(calculateAgain, frequencyMs);\n  }\n\n  /**\n   * @param {number} normalizedPercentage\n   * @private\n   */\n  maybeTrigger_(normalizedPercentage) {\n    if (normalizedPercentage <= 0) {\n      return;\n    }\n\n    if (this.last_ == normalizedPercentage) {\n      return;\n    }\n\n    this.last_ = normalizedPercentage;\n\n    this.analyticsEventForTesting_(normalizedPercentage);\n  }\n\n  /**\n   * @param {number} normalizedPercentage\n   * @private\n   */\n  analyticsEventForTesting_(normalizedPercentage) {\n    analyticsEvent(this.entry_, VideoAnalyticsEvents.PERCENTAGE_PLAYED, {\n      'normalizedPercentage': normalizedPercentage.toString(),\n    });\n  }\n}\n\n/**\n * @param {!VideoEntry} entry\n * @param {!VideoAnalyticsEvents} eventType\n * @param {!Object<string, string>=} opt_vars A map of vars and their values.\n * @private\n */\nfunction analyticsEvent(entry, eventType, opt_vars) {\n  const {video} = entry;\n\n  entry.getAnalyticsDetails().then((details) => {\n    if (opt_vars) {\n      Object.assign(details, opt_vars);\n    }\n    dispatchCustomEvent(video.element, eventType, details);\n  });\n}\n\n/** @param {!Node|!./ampdoc-impl.AmpDoc} nodeOrDoc */\nexport function installVideoManagerForDoc(nodeOrDoc) {\n  registerServiceBuilderForDoc(nodeOrDoc, 'video-manager', VideoManager);\n}\n", "import {arrayOrSingleItemToArray} from '#core/types/array';\n\n/**\n * Utility method that propagates attributes from a source element\n * to an updateable element.\n * If `opt_removeMissingAttrs` is true, then also removes any specified\n * attributes that are missing on the source element from the updateable element.\n * @param {string|!Array<string>} attributes\n * @param {!Element} sourceElement\n * @param {!Element} updateElement\n * @param {boolean=} opt_removeMissingAttrs\n */\nexport function propagateAttributes(\n  attributes,\n  sourceElement,\n  updateElement,\n  opt_removeMissingAttrs\n) {\n  const attrs = arrayOrSingleItemToArray(attributes);\n  for (const attr of attrs) {\n    const val = sourceElement.getAttribute(attr);\n    if (null !== val) {\n      updateElement.setAttribute(attr, val);\n    } else if (opt_removeMissingAttrs) {\n      updateElement.removeAttribute(attr);\n    }\n  }\n}\n", "import {dispatchCustomEvent} from '#core/dom';\nimport {applyFillContent} from '#core/dom/layout';\nimport {propagateAttributes} from '#core/dom/propagate-attributes';\nimport {htmlFor} from '#core/dom/static-template';\nimport {isArray, isObject} from '#core/types';\nimport {tryParseJson} from '#core/types/object/json';\n\nimport {Services} from '#service';\n\nimport {dev} from '#utils/log';\n\nimport {VideoEvents} from './video-interface';\n\n/** @enum {string} */\nexport const SandboxOptions = {\n  ALLOW_SCRIPTS: 'allow-scripts',\n  ALLOW_SAME_ORIGIN: 'allow-same-origin',\n  ALLOW_POPUPS: 'allow-popups',\n  ALLOW_POPUPS_TO_ESCAPE_SANDBOX: 'allow-popups-to-escape-sandbox',\n  ALLOW_TOP_NAVIGATION_BY_USER_ACTIVATION:\n    'allow-top-navigation-by-user-activation',\n};\n\n/**\n * @param {!Event} event\n * @param {?Element} iframe\n * @param {string|!RegExp} host\n * @return {boolean}\n */\nexport function originMatches(event, iframe, host) {\n  if (!iframe || event.source != iframe.contentWindow) {\n    return false;\n  }\n  if (typeof host === 'string') {\n    return host == event.origin;\n  }\n  return host.test(event.origin);\n}\n\n/**\n * Re-dispatches an event received from postMessage as an event in the host\n * document.\n *\n * @param {!AmpElement} element\n * @param {string} event\n * @param {!Object<string, (string|?Array<string>)>} events\n * @return {boolean}\n */\nexport function redispatch(element, event, events) {\n  if (events[event] == null) {\n    return false;\n  }\n  const dispatchEvent = events[event];\n  (isArray(dispatchEvent) ? dispatchEvent : [dispatchEvent]).forEach((e) => {\n    dispatchCustomEvent(element, dev().assertString(e));\n  });\n  return true;\n}\n\n/**\n * @param {!./base-element.BaseElement} video\n * @param {string} src\n * @param {string=} opt_name\n * @param {!Array<!SandboxOptions>=} opt_sandbox\n * @return {!Element}\n */\nexport function createFrameFor(video, src, opt_name, opt_sandbox) {\n  const {element} = video;\n  const frame = htmlFor(\n    element\n  )`<iframe frameborder=0 allowfullscreen></iframe>`;\n\n  if (opt_name) {\n    frame.setAttribute('name', opt_name);\n  }\n\n  if (opt_sandbox) {\n    frame.setAttribute('sandbox', opt_sandbox.join(' '));\n  }\n\n  // Will propagate for every component, but only validation rules will actually\n  // allow the attribute to be set.\n  propagateAttributes(['referrerpolicy'], video.element, frame);\n\n  frame.src = Services.urlForDoc(element).assertHttpsUrl(src, element);\n\n  applyFillContent(frame);\n  element.appendChild(frame);\n\n  return frame;\n}\n\n/**\n * @param {?} anything\n * @return {boolean}\n */\nexport function isJsonOrObj(anything) {\n  if (!anything) {\n    return false;\n  }\n  return isObject(anything) || /** @type {string} */ (anything).startsWith('{');\n}\n\n/**\n * @param {?JsonObject|string|undefined} objOrStr\n * @return {?JsonObject|undefined}\n */\nexport function objOrParseJson(objOrStr) {\n  if (isObject(objOrStr)) {\n    return /** @type {!JsonObject} */ (objOrStr);\n  }\n  return tryParseJson(objOrStr);\n}\n\n/**\n * @param {boolean} isMuted\n * @return {string}\n */\nexport function mutedOrUnmutedEvent(isMuted) {\n  return isMuted ? VideoEvents.MUTED : VideoEvents.UNMUTED;\n}\n\n/**\n * TEMPORARY workaround for M72-M74 user-activation breakage.\n * If this method is still here in May 2019, please ping @aghassemi\n * Only used by trusted video players: IMA and YouTube.\n * See https://github.com/ampproject/amphtml/issues/21242 for details.\n * TODO(aghassemi, #21247)\n * @param {Element} iframe\n */\nexport function addUnsafeAllowAutoplay(iframe) {\n  let val = iframe.getAttribute('allow') || '';\n  val += 'autoplay;';\n  iframe.setAttribute('allow', val);\n}\n\n/**\n * @param {?HTMLIFrameElement=} iframe\n * @param {*} message\n */\nexport function postMessageWhenAvailable(iframe, message) {\n  iframe?.contentWindow?./*OK*/ postMessage(message, '*');\n}\n", "import {LruCache} from '#core/data-structures/lru-cache';\nimport * as mode from '#core/mode';\nimport {arrayOrSingleItemToArray} from '#core/types/array';\nimport {dict, hasOwn} from '#core/types/object';\nimport {endsWith} from '#core/types/string';\nimport {parseQueryString} from '#core/types/string/url';\n\nimport {userAssert} from '#utils/log';\n\nimport {urls} from './config';\n\nconst SERVING_TYPE_PREFIX = new Set([\n  // No viewer\n  'c',\n  // In viewer\n  'v',\n  // Ad landing page\n  'a',\n  // Ad\n  'ad',\n]);\n\n/**\n * Cached a-tag to avoid memory allocation during URL parsing.\n * @type {HTMLAnchorElement}\n */\nlet cachedAnchorEl;\n\n/**\n * We cached all parsed URLs. As of now there are no use cases\n * of AMP docs that would ever parse an actual large number of URLs,\n * but we often parse the same one over and over again.\n * @type {LruCache}\n */\nlet urlCache;\n\n// eslint-disable-next-line no-script-url\nconst INVALID_PROTOCOLS = ['javascript:', 'data:', 'vbscript:'];\n\n/** @const {string} */\nexport const SOURCE_ORIGIN_PARAM = '__amp_source_origin';\n\n/**\n * Coerces a url into a location;\n * @function\n * @param {string|!Location} url\n * @return {!Location}\n */\nconst urlAsLocation = (url) =>\n  typeof url == 'string' ? parseUrlDeprecated(url) : url;\n\n/**\n * Returns the correct origin for a given window.\n * TODO(rcebulko): This really belongs under #core/window somewhere, not in url\n * @param {!Window} win\n * @return {string} origin\n */\nexport function getWinOrigin(win) {\n  return win.origin || parseUrlDeprecated(win.location.href).origin;\n}\n\n/**\n * Returns a Location-like object for the given URL. If it is relative,\n * the URL gets resolved.\n * Consider the returned object immutable. This is enforced during\n * testing by freezing the object.\n * TODO(#34453): The URL constructor isn't supported in IE11, but is supported\n * everywhere else. There's a lot of code paths (and all uses of the LruCache)\n * that are built around this polyfill. Once we can drop IE11 support and just\n * use the URL constructor, we can clear out all of parseWithA, all the URL\n * cache logic (incl. additional caches in other call-sites). Most is guarded by\n * isEsm() and is only included in nomodule builds, but still.\n * @param {string} url\n * @param {boolean=} opt_nocache\n *   Cache is always ignored on ESM builds, see https://go.amp.dev/pr/31594\n * @return {!Location}\n */\nexport function parseUrlDeprecated(url, opt_nocache) {\n  if (!cachedAnchorEl) {\n    cachedAnchorEl = /** @type {!HTMLAnchorElement} */ (\n      self.document.createElement('a')\n    );\n    urlCache = mode.isEsm()\n      ? null\n      : self.__AMP_URL_CACHE || (self.__AMP_URL_CACHE = new LruCache(100));\n  }\n\n  return parseUrlWithA(\n    cachedAnchorEl,\n    url,\n    mode.isEsm() || opt_nocache ? null : urlCache\n  );\n}\n\n/**\n * Returns a Location-like object for the given URL. If it is relative,\n * the URL gets resolved.\n * Consider the returned object immutable. This is enforced during\n * testing by freezing the object.\n * @param {!HTMLAnchorElement} anchorEl\n * @param {string} url\n * @param {LruCache=} opt_cache\n *   Cache is always ignored on ESM builds, see https://go.amp.dev/pr/31594\n * @return {!Location}\n * @restricted\n */\nexport function parseUrlWithA(anchorEl, url, opt_cache) {\n  if (mode.isEsm()) {\n    // Doing this causes the <a> to auto-set its own href to the resolved path,\n    // which would be the baseUrl for the URL constructor.\n    anchorEl.href = '';\n    return /** @type {?} */ (new URL(url, anchorEl.href));\n  }\n\n  if (opt_cache && opt_cache.has(url)) {\n    return opt_cache.get(url);\n  }\n\n  anchorEl.href = url;\n\n  // IE11 doesn't provide full URL components when parsing relative URLs.\n  // Assigning to itself again does the trick #3449.\n  if (!anchorEl.protocol) {\n    anchorEl.href = anchorEl.href;\n  }\n\n  const info = /** @type {!Location} */ ({\n    href: anchorEl.href,\n    protocol: anchorEl.protocol,\n    host: anchorEl.host,\n    hostname: anchorEl.hostname,\n    port: anchorEl.port == '0' ? '' : anchorEl.port,\n    pathname: anchorEl.pathname,\n    search: anchorEl.search,\n    hash: anchorEl.hash,\n    origin: null, // Set below.\n  });\n\n  // Some IE11 specific polyfills.\n  // 1) IE11 strips out the leading '/' in the pathname.\n  if (info.pathname[0] !== '/') {\n    info.pathname = '/' + info.pathname;\n  }\n\n  // 2) For URLs with implicit ports, IE11 parses to default ports while\n  // other browsers leave the port field empty.\n  if (\n    (info.protocol == 'http:' && info.port == 80) ||\n    (info.protocol == 'https:' && info.port == 443)\n  ) {\n    info.port = '';\n    info.host = info.hostname;\n  }\n\n  // For data URI anchorEl.origin is equal to the string 'null' which is not useful.\n  // We instead return the actual origin which is the full URL.\n  let origin;\n  if (anchorEl.origin && anchorEl.origin != 'null') {\n    origin = anchorEl.origin;\n  } else if (info.protocol == 'data:' || !info.host) {\n    origin = info.href;\n  } else {\n    origin = info.protocol + '//' + info.host;\n  }\n  info.origin = origin;\n\n  // Freeze during testing to avoid accidental mutation.\n  const frozen = mode.isTest() && Object.freeze ? Object.freeze(info) : info;\n\n  if (opt_cache) {\n    opt_cache.put(url, frozen);\n  }\n\n  return frozen;\n}\n\n/**\n * Appends the string just before the fragment part (or optionally\n * to the front of the query string) of the URL.\n * @param {string} url\n * @param {string} paramString\n * @param {boolean=} opt_addToFront\n * @return {string}\n */\nexport function appendEncodedParamStringToUrl(\n  url,\n  paramString,\n  opt_addToFront\n) {\n  if (!paramString) {\n    return url;\n  }\n  const mainAndFragment = url.split('#', 2);\n  const mainAndQuery = mainAndFragment[0].split('?', 2);\n\n  let newUrl =\n    mainAndQuery[0] +\n    (mainAndQuery[1]\n      ? opt_addToFront\n        ? `?${paramString}&${mainAndQuery[1]}`\n        : `?${mainAndQuery[1]}&${paramString}`\n      : `?${paramString}`);\n  newUrl += mainAndFragment[1] ? `#${mainAndFragment[1]}` : '';\n  return newUrl;\n}\n\n/**\n * @param {string} key\n * @param {string} value\n * @return {string}\n */\nfunction urlEncodeKeyValue(key, value) {\n  return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n}\n\n/**\n * Appends a query string field and value to a url. `key` and `value`\n * will be ran through `encodeURIComponent` before appending.\n * @param {string} url\n * @param {string} key\n * @param {string} value\n * @param {boolean=} opt_addToFront\n * @return {string}\n */\nexport function addParamToUrl(url, key, value, opt_addToFront) {\n  return appendEncodedParamStringToUrl(\n    url,\n    urlEncodeKeyValue(key, value),\n    opt_addToFront\n  );\n}\n\n/**\n * Appends query string fields and values to a url. The `params` objects'\n * `key`s and `value`s will be transformed into query string keys/values.\n * @param {string} url\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\nexport function addParamsToUrl(url, params) {\n  return appendEncodedParamStringToUrl(url, serializeQueryString(params));\n}\n\n/**\n * Append query string fields and values to a url, only if the key does not\n * exist in current query string.\n * @param {string} url\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\nexport function addMissingParamsToUrl(url, params) {\n  const location = parseUrlDeprecated(url);\n  const existingParams = parseQueryString(location.search);\n  const paramsToAdd = dict({});\n  const keys = Object.keys(params);\n  for (let i = 0; i < keys.length; i++) {\n    if (!hasOwn(existingParams, keys[i])) {\n      paramsToAdd[keys[i]] = params[keys[i]];\n    }\n  }\n  return addParamsToUrl(url, paramsToAdd);\n}\n\n/**\n * Serializes the passed parameter map into a query string with both keys\n * and values encoded.\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\nexport function serializeQueryString(params) {\n  const s = [];\n  for (const k in params) {\n    let v = params[k];\n    if (v == null) {\n      continue;\n    }\n\n    v = arrayOrSingleItemToArray(v);\n    for (let i = 0; i < v.length; i++) {\n      s.push(urlEncodeKeyValue(k, v[i]));\n    }\n  }\n  return s.join('&');\n}\n\n/**\n * Returns `true` if the URL is secure: either HTTPS or localhost (for testing).\n * @param {string|!Location} url\n * @return {boolean}\n */\nexport function isSecureUrlDeprecated(url) {\n  url = urlAsLocation(url);\n  return (\n    url.protocol == 'https:' ||\n    url.hostname == 'localhost' ||\n    url.hostname == '127.0.0.1' ||\n    endsWith(url.hostname, '.localhost')\n  );\n}\n\n/**\n * Asserts that a given url is HTTPS or protocol relative. It's a user-level\n * assert.\n *\n * Provides an exception for localhost.\n *\n * @param {?string|undefined} urlString\n * @param {!Element|string} elementContext Element where the url was found.\n * @param {string=} sourceName Used for error messages.\n * @return {string}\n */\nexport function assertHttpsUrl(\n  urlString,\n  elementContext,\n  sourceName = 'source'\n) {\n  userAssert(\n    urlString != null,\n    '%s %s must be available',\n    elementContext,\n    sourceName\n  );\n  userAssert(\n    isSecureUrlDeprecated(urlString) || /^\\/\\//.test(urlString),\n    '%s %s must start with ' +\n      '\"https://\" or \"//\" or be relative and served from ' +\n      'either https or from localhost. Invalid value: %s',\n    elementContext,\n    sourceName,\n    urlString\n  );\n  return urlString;\n}\n\n/**\n * Asserts that a given url is an absolute HTTP or HTTPS URL.\n * @param {string} urlString\n * @return {string}\n */\nexport function assertAbsoluteHttpOrHttpsUrl(urlString) {\n  userAssert(\n    /^https?\\:/i.test(urlString),\n    'URL must start with \"http://\" or \"https://\". Invalid value: %s',\n    urlString\n  );\n  return parseUrlDeprecated(urlString).href;\n}\n\n/**\n * Returns the URL without fragment. If URL doesn't contain fragment, the same\n * string is returned.\n * @param {string} url\n * @return {string}\n */\nexport function removeFragment(url) {\n  const index = url.indexOf('#');\n  if (index == -1) {\n    return url;\n  }\n  return url.substring(0, index);\n}\n\n/**\n * Returns the fragment from the URL. If the URL doesn't contain fragment,\n * the empty string is returned.\n * @param {string} url\n * @return {string}\n */\nexport function getFragment(url) {\n  const index = url.indexOf('#');\n  if (index == -1) {\n    return '';\n  }\n  return url.substring(index);\n}\n\n/**\n * Returns whether the URL has the origin of a proxy.\n * @param {string|!Location} url URL of an AMP document.\n * @return {boolean}\n */\nexport function isProxyOrigin(url) {\n  return urls.cdnProxyRegex.test(urlAsLocation(url).origin);\n}\n\n/**\n * Returns whether the URL origin is localhost.\n * @param {string|!Location} url URL of an AMP document.\n * @return {boolean}\n */\nexport function isLocalhostOrigin(url) {\n  return urls.localhostRegex.test(urlAsLocation(url).origin);\n}\n\n/**\n * @param {string} uri\n * @return {boolean}\n */\nexport function isAmpScriptUri(uri) {\n  return uri.startsWith('amp-script:');\n}\n\n/**\n * For proxy-origin URLs, returns the serving type. Otherwise, returns null.\n * E.g., 'https://amp-com.cdn.ampproject.org/a/s/amp.com/amp_document.html'\n * returns 'a'.\n * @param {string|!Location} url URL of an AMP document.\n * @return {?string}\n */\nexport function getProxyServingType(url) {\n  url = urlAsLocation(url);\n  if (!isProxyOrigin(url)) {\n    return null;\n  }\n  const path = url.pathname.split('/', 2);\n  return path[1];\n}\n\n/**\n * Returns whether the URL has valid protocol.\n * Deep link protocol is valid, but not javascript etc.\n * @param {string|!Location} url\n * @return {boolean}\n */\nexport function isProtocolValid(url) {\n  return !(url && INVALID_PROTOCOLS.includes(urlAsLocation(url).protocol));\n}\n\n/**\n * Returns a URL without AMP JS parameters.\n * @param {string} url\n * @return {string}\n */\nexport function removeAmpJsParamsFromUrl(url) {\n  const {hash, origin, pathname, search} = parseUrlDeprecated(url);\n  const searchRemoved = removeAmpJsParamsFromSearch(search);\n  return origin + pathname + searchRemoved + hash;\n}\n\n/**\n * Returns a URL without a query string.\n * @param {string} url\n * @return {string}\n */\nexport function removeSearch(url) {\n  const index = url.indexOf('?');\n  if (index == -1) {\n    return url;\n  }\n  const fragment = getFragment(url);\n  return url.substring(0, index) + fragment;\n}\n\n/**\n * Removes parameters that start with amp js parameter pattern and returns the\n * new search string.\n * @param {string} urlSearch\n * @return {string}\n */\nfunction removeAmpJsParamsFromSearch(urlSearch) {\n  // The below regex is a combo of these original patterns. Combining these,\n  // removing the corresponding `.replace` calls, and reusing\n  // removeParamsFromSearch saves ~175B. Matches params in query string:\n  // - /[?&]amp_js[^&]*/   amp_js_*\n  // - /[?&]amp_gsa[^&]*/  amp_gsa\n  // - /[?&]amp_r[^&]*/    amp_r\n  // - /[?&]amp_kit[^&]*/  amp_kit\n  // - /[?&]usqp[^&]*/     usqp (from goog experiment)\n  return removeParamsFromSearch(urlSearch, '(amp_(js[^&=]*|gsa|r|kit)|usqp)');\n}\n\n/**\n * Removes parameters with param name and returns the new search string.\n * @param {string} urlSearch\n * @param {string} paramName\n * @return {string}\n */\nexport function removeParamsFromSearch(urlSearch, paramName) {\n  // TODO: Accept paramNames as an array.\n  if (!urlSearch || urlSearch == '?') {\n    return '';\n  }\n  const paramRegex = new RegExp(`[?&]${paramName}\\\\b[^&]*`, 'g');\n  const search = urlSearch.replace(paramRegex, '').replace(/^[?&]/, '');\n  return search ? '?' + search : '';\n}\n\n/**\n * Returns the source URL of an AMP document for documents served\n * on a proxy origin or directly.\n * @param {string|!Location} url URL of an AMP document.\n * @return {string}\n */\nexport function getSourceUrl(url) {\n  url = urlAsLocation(url);\n\n  // Not a proxy URL - return the URL itself.\n  if (!isProxyOrigin(url)) {\n    return url.href;\n  }\n\n  // A proxy URL.\n  // Example path that is being matched here.\n  // https://cdn.ampproject.org/c/s/www.origin.com/foo/\n  // The /s/ is optional and signals a secure origin.\n  const path = url.pathname.split('/');\n  const prefix = path[1];\n  userAssert(\n    SERVING_TYPE_PREFIX.has(prefix),\n    'Unknown path prefix in url %s',\n    url.href\n  );\n  const domainOrHttpsSignal = path[2];\n  const origin =\n    domainOrHttpsSignal == 's'\n      ? 'https://' + decodeURIComponent(path[3])\n      : 'http://' + decodeURIComponent(domainOrHttpsSignal);\n  // Sanity test that what we found looks like a domain.\n  userAssert(origin.indexOf('.') > 0, 'Expected a . in origin %s', origin);\n  path.splice(1, domainOrHttpsSignal == 's' ? 3 : 2);\n  return (\n    origin +\n    path.join('/') +\n    removeAmpJsParamsFromSearch(url.search) +\n    (url.hash || '')\n  );\n}\n\n/**\n * Returns the source origin of an AMP document for documents served\n * on a proxy origin or directly.\n * @param {string|!Location} url URL of an AMP document.\n * @return {string} The source origin of the URL.\n */\nexport function getSourceOrigin(url) {\n  return parseUrlDeprecated(getSourceUrl(url)).origin;\n}\n\n/**\n * Returns absolute URL resolved based on the relative URL and the base.\n * @param {string} relativeUrlString\n * @param {string|!Location} baseUrl\n * @return {string}\n */\nexport function resolveRelativeUrl(relativeUrlString, baseUrl) {\n  baseUrl = urlAsLocation(baseUrl);\n  if (mode.isEsm() || typeof URL == 'function') {\n    return new URL(relativeUrlString, baseUrl.href).toString();\n  }\n  return resolveRelativeUrlFallback_(relativeUrlString, baseUrl);\n}\n\n/**\n * Fallback for URL resolver when URL class is not available.\n * @param {string} relativeUrlString\n * @param {string|!Location} baseUrl\n * @return {string}\n * @private @visibleForTesting\n */\nexport function resolveRelativeUrlFallback_(relativeUrlString, baseUrl) {\n  baseUrl = urlAsLocation(baseUrl);\n  relativeUrlString = relativeUrlString.replace(/\\\\/g, '/');\n  const relativeUrl = parseUrlDeprecated(relativeUrlString);\n\n  // Absolute URL.\n  if (relativeUrlString.toLowerCase().startsWith(relativeUrl.protocol)) {\n    return relativeUrl.href;\n  }\n\n  // Protocol-relative URL.\n  if (relativeUrlString.startsWith('//')) {\n    return baseUrl.protocol + relativeUrlString;\n  }\n\n  // Absolute path.\n  if (relativeUrlString.startsWith('/')) {\n    return baseUrl.origin + relativeUrlString;\n  }\n\n  // Relative path.\n  return (\n    baseUrl.origin +\n    baseUrl.pathname.replace(/\\/[^/]*$/, '/') +\n    relativeUrlString\n  );\n}\n\n/**\n * Add \"__amp_source_origin\" query parameter to the URL.\n * @param {!Window} win\n * @param {string} url\n * @return {string}\n */\nexport function getCorsUrl(win, url) {\n  checkCorsUrl(url);\n  const sourceOrigin = getSourceOrigin(win.location.href);\n  return addParamToUrl(url, SOURCE_ORIGIN_PARAM, sourceOrigin);\n}\n\n/**\n * Checks if the url has __amp_source_origin and throws if it does.\n * @param {string} url\n */\nexport function checkCorsUrl(url) {\n  const parsedUrl = parseUrlDeprecated(url);\n  const query = parseQueryString(parsedUrl.search);\n  userAssert(\n    !(SOURCE_ORIGIN_PARAM in query),\n    'Source origin is not allowed in %s',\n    url\n  );\n}\n\n/**\n * Adds the path to the given url.\n *\n * @param {!Location} url\n * @param {string} path\n * @return {string}\n */\nexport function appendPathToUrl(url, path) {\n  const pathname = url.pathname.replace(/\\/?$/, '/') + path.replace(/^\\//, '');\n  return url.origin + pathname + url.search + url.hash;\n}\n", "import {dict} from '#core/types/object';\n\nimport {postMessageWhenAvailable} from '../../src/iframe-video';\nimport {addParamsToUrl} from '../../src/url';\nimport {VideoEvents} from '../../src/video-interface';\n\n/**\n * @fileoverview\n * Definitions of messages and other utilities to talk to Vimeo embed iframes.\n * See https://developer.vimeo.com/player/js-api\n */\n\n// \u26A0\uFE0F This module should not have side-effects.\n\nexport const getVimeoOriginRegExp = () =>\n  /^(https?:)?\\/\\/((player|www)\\.)?vimeo.com(?=$|\\/)/;\n\n/**\n * Maps events coming from the Vimeo frame to events to be dispatched from the\n * component element.\n *\n * If the item does not have a value, the event will not be forwarded 1:1, but\n * it will be listened to.\n *\n * @const {!Object<string, ?string>}\n */\nexport const VIMEO_EVENTS = {\n  'play': VideoEvents.PLAYING,\n  'pause': VideoEvents.PAUSE,\n  'ended': VideoEvents.ENDED,\n  'volumechange': null,\n};\n\n/**\n * @param {string} videoid\n * @param {?boolean=} autoplay\n * @param {?boolean=} doNotTrack\n * @return {string}\n */\nexport function getVimeoIframeSrc(videoid, autoplay, doNotTrack) {\n  return addParamsToUrl(\n    `https://player.vimeo.com/video/${encodeURIComponent(videoid)}`,\n    dict({\n      'dnt': doNotTrack ? '1' : undefined,\n      'muted': autoplay ? '1' : undefined,\n    })\n  );\n}\n\n/**\n * @param {string} method\n * @param {?Object|string=} params\n * @return {string}\n */\nexport function makeVimeoMessage(method, params = '') {\n  return JSON.stringify(\n    dict({\n      'method': method,\n      'value': params,\n    })\n  );\n}\n\n/**\n * Sends a set of messages to the Vimeo iframe to listen to events.\n * We need to explicitly listen to these so that we receive incoming event\n * messages.\n * @param {!HTMLIFrameElement} iframe\n */\nexport function listenToVimeoEvents(iframe) {\n  Object.keys(VIMEO_EVENTS).forEach((event) => {\n    postMessageWhenAvailable(\n      iframe,\n      makeVimeoMessage('addEventListener', event)\n    );\n  });\n}\n", "import {dispatchCustomEvent, removeElement} from '#core/dom';\nimport {isLayoutSizeDefined} from '#core/dom/layout';\nimport {isAutoplaySupported} from '#core/dom/video';\nimport {PauseHelper} from '#core/dom/video/pause-helper';\nimport {once} from '#core/types/function';\n\nimport {Services} from '#service';\nimport {installVideoManagerForDoc} from '#service/video-manager-impl';\n\nimport {getData, listen} from '#utils/event-helper';\nimport {userAssert} from '#utils/log';\n\nimport {\n  createFrameFor,\n  isJsonOrObj,\n  mutedOrUnmutedEvent,\n  objOrParseJson,\n  originMatches,\n  postMessageWhenAvailable,\n  redispatch,\n} from '../../../src/iframe-video';\nimport {VideoAttributes, VideoEvents} from '../../../src/video-interface';\nimport {\n  VIMEO_EVENTS,\n  getVimeoIframeSrc,\n  getVimeoOriginRegExp,\n  listenToVimeoEvents,\n  makeVimeoMessage,\n} from '../vimeo-api';\n\nconst TAG = 'amp-vimeo';\n\n/** @implements {../../../src/video-interface.VideoInterface} */\nclass AmpVimeo extends AMP.BaseElement {\n  /** @param {!AmpElement} element */\n  constructor(element) {\n    super(element);\n\n    /** @private {?Element} */\n    this.iframe_ = null;\n\n    /** @private {function()} */\n    this.onReadyOnce_ = once(() => this.onReady_());\n\n    /** @private {boolean} */\n    this.muted_ = false;\n\n    /**\n     * @param {!Event} e\n     * @return {*} TODO(#23582): Specify return type\n     * @private\n     */\n    this.boundOnMessage_ = (e) => this.onMessage_(e);\n\n    /** @private {!UnlistenDef|null} */\n    this.unlistenFrame_ = null;\n\n    /** @private @const */\n    this.pauseHelper_ = new PauseHelper(this.element);\n  }\n\n  /** @override */\n  preconnectCallback(onLayout = false) {\n    const preconnect = Services.preconnectFor(this.win);\n    const ampdoc = this.getAmpDoc();\n    preconnect.url(ampdoc, 'https://player.vimeo.com', onLayout);\n    // Host that Vimeo uses to serve poster frames needed by player.\n    preconnect.url(ampdoc, 'https://i.vimeocdn.com', onLayout);\n    // Host that Vimeo uses to serve JS, CSS and other assets needed.\n    preconnect.url(ampdoc, 'https://f.vimeocdn.com', onLayout);\n  }\n\n  /** @override */\n  isLayoutSupported(layout) {\n    return isLayoutSizeDefined(layout);\n  }\n\n  /** @override */\n  buildCallback() {\n    installVideoManagerForDoc(this.getAmpDoc());\n  }\n\n  /** @override */\n  layoutCallback() {\n    const {element} = this;\n    const videoid = userAssert(\n      element.getAttribute('data-videoid'),\n      'The data-videoid attribute is required for <amp-vimeo> %s',\n      element\n    );\n    return this.isAutoplay_().then((isAutoplay) =>\n      this.buildIframe_(\n        getVimeoIframeSrc(\n          videoid,\n          isAutoplay,\n          this.element.hasAttribute('do-not-track')\n        )\n      )\n    );\n  }\n\n  /**\n   * @param {string} src\n   * @return {!Promise}\n   * @private\n   */\n  buildIframe_(src) {\n    const iframe = createFrameFor(this, src);\n\n    this.iframe_ = iframe;\n    this.unlistenFrame_ = listen(this.win, 'message', this.boundOnMessage_);\n\n    this.sendCommand_('ping');\n\n    return this.loadPromise(iframe);\n  }\n\n  /** @override */\n  unlayoutCallback() {\n    this.removeIframe_();\n    this.pauseHelper_.updatePlaying(false);\n    return true; // layout again.\n  }\n\n  /** @private */\n  removeIframe_() {\n    if (this.iframe_) {\n      removeElement(this.iframe_);\n      this.iframe_ = null;\n    }\n    if (this.unlistenFrame_) {\n      this.unlistenFrame_();\n      this.unlistenFrame_ = null;\n    }\n  }\n\n  /**\n   * @return {!Promise<boolean>}\n   * @private\n   */\n  isAutoplay_() {\n    if (!this.element.hasAttribute(VideoAttributes.AUTOPLAY)) {\n      return Promise.resolve(false);\n    }\n    return isAutoplaySupported(this.win);\n  }\n\n  /** @private */\n  onReady_() {\n    const {element} = this;\n\n    listenToVimeoEvents(this.iframe_);\n\n    Services.videoManagerForDoc(element).register(this);\n\n    dispatchCustomEvent(element, VideoEvents.LOAD);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  onMessage_(event) {\n    if (!originMatches(event, this.iframe_, getVimeoOriginRegExp())) {\n      return;\n    }\n\n    const eventData = getData(event);\n    if (!isJsonOrObj(eventData)) {\n      return;\n    }\n\n    const data = objOrParseJson(eventData);\n\n    if (data == null) {\n      return; // we only process valid json\n    }\n\n    if (data['event'] == 'ready' || data['method'] == 'ping') {\n      this.onReadyOnce_();\n      return;\n    }\n\n    const {element} = this;\n\n    switch (data['event']) {\n      case 'play':\n        this.pauseHelper_.updatePlaying(true);\n        break;\n      case 'pause':\n      case 'ended':\n        this.pauseHelper_.updatePlaying(false);\n        break;\n    }\n\n    if (redispatch(element, data['event'], VIMEO_EVENTS)) {\n      return;\n    }\n\n    if (data['event'] == 'volumechange') {\n      const volume = data['data'] && data['data']['volume'];\n      if (!volume) {\n        return;\n      }\n      const muted = volume <= 0;\n      if (muted == this.muted_) {\n        return;\n      }\n      this.muted_ = muted;\n      dispatchCustomEvent(element, mutedOrUnmutedEvent(muted));\n      return;\n    }\n  }\n\n  /** @override */\n  pauseCallback() {\n    this.pause();\n  }\n\n  /** @override */\n  pause() {\n    this.sendCommand_('pause');\n  }\n\n  /** @override */\n  play() {\n    this.sendCommand_('play');\n  }\n\n  /** @override */\n  mute() {\n    if (this.muted_) {\n      // We need to check if already muted to prevent an initial mute() call\n      // that would disable autoplay on iOS.\n      return;\n    }\n    this.sendCommand_('setVolume', '0');\n  }\n\n  /** @override */\n  unmute() {\n    // TODO(alanorozco): Set based on volume before unmuting.\n    this.sendCommand_('setVolume', '1');\n  }\n\n  /** @override */\n  isInteractive() {\n    return true;\n  }\n\n  /** @override */\n  supportsPlatform() {\n    return true;\n  }\n\n  /** @override */\n  preimplementsMediaSessionAPI() {\n    // The Vimeo player embedded in the frame hooks into the API directly.\n    return true;\n  }\n\n  /** @override */\n  preimplementsAutoFullscreen() {\n    return false;\n  }\n\n  /** @override */\n  fullscreenEnter() {\n    // NOOP. Not implemented by Vimeo.\n  }\n\n  /** @override */\n  fullscreenExit() {\n    // NOOP. Not implemented by Vimeo.\n  }\n\n  /** @override */\n  isFullscreen() {\n    return false;\n  }\n\n  /** @override */\n  showControls() {\n    // NOOP. Not implemented by Vimeo.\n  }\n\n  /** @override */\n  hideControls() {\n    // NOOP. Not implemented by Vimeo.\n  }\n\n  /** @override */\n  getMetadata() {\n    // TODO(alanorozco)\n  }\n\n  /** @override */\n  getDuration() {\n    // TODO(alanorozco)\n    return 0;\n  }\n\n  /** @override */\n  getCurrentTime() {\n    // TODO(alanorozco)\n    return 0;\n  }\n\n  /** @override */\n  getPlayedRanges() {\n    // TODO(alanorozco)\n    return [];\n  }\n\n  /**\n   * @param {string} method\n   * @param {?Object|string=} params\n   * @private\n   */\n  sendCommand_(method, params) {\n    postMessageWhenAvailable(this.iframe_, makeVimeoMessage(method, params));\n  }\n\n  /** @override */\n  seekTo(unusedTimeSeconds) {\n    this.user().error(TAG, '`seekTo` not supported.');\n  }\n}\n\nAMP.extension(TAG, '0.1', (AMP) => {\n  AMP.registerElement(TAG, AmpVimeo);\n});\n"],
  "mappings": "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",
  "names": []
}
