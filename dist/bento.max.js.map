{
  "version": 3,
  "sources": ["../src/core/data-structures/promise.js", "../src/core/error/index.js", "../src/core/mode/prod.js", "../src/core/mode/esm.js", "../src/core/types/object/index.js", "../src/polyfills/custom-elements.js", "../src/bento.js"],
  "sourcesContent": ["let resolved;\n\n/**\n * Returns a cached resolved promise.\n * Babel converts direct calls to Promise.resolve() (with no arguments) into\n * calls to this.\n *\n * @return {!Promise<undefined>}\n */\nexport function resolvedPromise() {\n  if (resolved) {\n    return resolved;\n  }\n\n  // It's important that we call with `undefined` here, to prevent a transform\n  // recursion. If we didn't pass an arg, then the transformer would replace\n  // this callsite with a call to `resolvedPromise()`.\n  resolved = Promise.resolve(undefined);\n  return resolved;\n}\n\n/**\n * Returns a Deferred struct, which holds a pending promise and its associated\n * resolve and reject functions.\n *\n * This is preferred instead of creating a Promise instance to extract the\n * resolve/reject functions yourself:\n *\n * ```\n * // Avoid doing\n * let resolve;\n * const promise = new Promise(res => {\n *   resolve = res;\n * });\n *\n * // Good\n * const deferred = new Deferred();\n * const { promise, resolve } = deferred;\n * ```\n *\n * @template T\n */\nexport class Deferred {\n  /** Constructor. */\n  constructor() {\n    /** @const {!Promise<T>} */\n    this.promise = new /*OK*/ Promise((res, rej) => {\n      /** @const {function(T=)} */\n      this.resolve = res;\n      /** @const {function(*=)} */\n      this.reject = rej;\n    });\n  }\n}\n\n/**\n * Creates a promise resolved to the return value of fn.\n * If fn sync throws, it will cause the promise to reject.\n *\n * @param {function():T} fn\n * @return {!Promise<T>}\n * @template T\n */\nexport function tryResolve(fn) {\n  return new Promise((resolve) => {\n    resolve(fn());\n  });\n}\n\n/**\n * Resolves with the result of the last promise added.\n * @implements {IThenable}\n */\nexport class LastAddedResolver {\n  /**\n   * @param {!Array<!IThenable>=} opt_promises\n   */\n  constructor(opt_promises) {\n    /** @private @const {!Deferred} */\n    this.deferred_ = new Deferred();\n\n    /** @private */\n    this.count_ = 0;\n\n    if (opt_promises) {\n      for (const promise of opt_promises) {\n        this.add(promise);\n      }\n    }\n  }\n\n  /**\n   * Add a promise to possibly be resolved.\n   * @param {!IThenable} promise\n   * @return {!Promise}\n   */\n  add(promise) {\n    const countAtAdd = ++this.count_;\n    promise.then(\n      (result) => {\n        if (this.count_ === countAtAdd) {\n          this.deferred_.resolve(result);\n        }\n      },\n      (error) => {\n        // Don't follow behavior of Promise.all and Promise.race error so that\n        // this will only reject when most recently added promise fails.\n        if (this.count_ === countAtAdd) {\n          this.deferred_.reject(error);\n        }\n      }\n    );\n    return this.deferred_.promise;\n  }\n\n  /** @override */\n  then(opt_resolve, opt_reject) {\n    return this.deferred_.promise.then(opt_resolve, opt_reject);\n  }\n}\n", "/**\n * Some exceptions (DOMException, namely) have read-only message.\n * @param {!Error} error\n * @return {!Error}\n */\nexport function duplicateErrorIfNecessary(error) {\n  const messageProperty = Object.getOwnPropertyDescriptor(error, 'message');\n  if (messageProperty?.writable) {\n    return error;\n  }\n\n  const {message, stack} = error;\n  const e = new Error(message);\n  // Copy all the extraneous things we attach.\n  for (const prop in error) {\n    e[prop] = error[prop];\n  }\n  // Ensure these are copied.\n  e.stack = stack;\n  return e;\n}\n\n/**\n * Creates an error object.\n * @param {...*} var_args\n * @return {!Error}\n */\nexport function createError(var_args) {\n  let error = null;\n  let message = '';\n  for (const arg of arguments) {\n    if (arg instanceof Error && !error) {\n      error = duplicateErrorIfNecessary(arg);\n    } else {\n      if (message) {\n        message += ' ';\n      }\n      message += arg;\n    }\n  }\n\n  if (!error) {\n    error = new Error(message);\n  } else if (message) {\n    error.message = message + ': ' + error.message;\n  }\n  return error;\n}\n\n/**\n * Reports an error, if the global error reporting function is defined.\n * @param {!Error} error\n */\nfunction maybeReportError(error) {\n  self.__AMP_REPORT_ERROR?.(error);\n}\n\n/**\n * Constructs and throws an error without terminating the current context. This\n * preserves whether the original error designation is a user error or a dev\n * error.\n * @param {...*} var_args\n */\nexport function rethrowAsync(var_args) {\n  const error = createError.apply(null, arguments);\n  setTimeout(() => {\n    // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n    // It may not exist for Bento components without the runtime.\n    maybeReportError(error);\n    throw error;\n  });\n}\n\n/**\n * Executes the provided callback in a try/catch and rethrows any errors\n * asynchronously.\n *\n * @param {function(S):T} callback\n * @param {S} args\n * @return {T}\n * @template T\n * @template S\n */\nexport function tryCallback(callback, ...args) {\n  try {\n    return callback.apply(null, args);\n  } catch (e) {\n    rethrowAsync(e);\n  }\n}\n\n/**\n * Creates an error object with its expected property set to true.\n * @param {...*} var_args\n * @return {!Error}\n */\nexport function createExpectedError(var_args) {\n  const error = createError.apply(null, arguments);\n  error.expected = true;\n  return error;\n}\n\n/**\n * Reports an error message.\n * @param {string} tag\n * @param {...*} args\n */\nexport function devError(tag, ...args) {\n  const error = createError.apply(null, args);\n  // TODO(rcebulko): Determine if/how this Error#name property is used.\n  error.name = tag || error.name;\n  maybeReportError(error);\n}\n\n/**\n * Reports an error message and marks with an expected property. If the\n * logging is disabled, the error is rethrown asynchronously.\n * @param {string} unusedTag\n * @param {...*} args\n */\nexport function devExpectedError(unusedTag, ...args) {\n  maybeReportError(createExpectedError.apply(null, args));\n}\n", "/**\n * Returns true when the build is meant for distribution.\n * This means `amp dist` was called _without_ the --fortesting flag.\n *\n * This is a magic constant replaced by babel.\n *\n * Calls are DCE'd when compiled.\n * @return {boolean}\n */\nexport function isProd() {\n  return IS_PROD;\n}\n", "/**\n * Copyright 2021 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {isProd} from './prod';\n\n/**\n * Returns true when compiling an esm binary.\n * This is a magic constant that is replaced by babel.\n *\n * @return {boolean}\n */\nexport function isEsm() {\n  if (isProd()) {\n    return IS_ESM;\n  }\n\n  return self?.__AMP_MODE?.esm ?? IS_ESM;\n}\n", "/* @const */\nconst {hasOwnProperty: hasOwn_, toString: toString_} = Object.prototype;\n\n/**\n * Determines if value is actually an Object.\n * @param {*} value\n * @return {boolean}\n */\nexport function isObject(value) {\n  return toString_.call(value) === '[object Object]';\n}\n\n/**\n * Returns a map-like object.\n * If opt_initial is provided, copies its own properties into the\n * newly created object.\n * @param {T=} opt_initial This should typically be an object literal.\n * @return {T}\n * @template T\n */\nexport function map(opt_initial) {\n  const obj = Object.create(null);\n  if (opt_initial) {\n    Object.assign(obj, opt_initial);\n  }\n  return obj;\n}\n\n/**\n * Return an empty JsonObject or makes the passed in object literal\n * an JsonObject.\n * The JsonObject type is just a simple object that is at-dict.\n * See\n * https://github.com/google/closure-compiler/wiki/@struct-and-@dict-Annotations\n * for what a dict is type-wise.\n * The linter enforces that the argument is, in fact, at-dict like.\n * @param {!Object=} opt_initial\n * @return {!JsonObject}\n */\nexport function dict(opt_initial) {\n  // We do not copy. The linter enforces that the passed in object is a literal\n  // and thus the caller cannot have a reference to it.\n  return /** @type {!JsonObject} */ (opt_initial || {});\n}\n\n/**\n * Checks if the given key is a property in the map.\n *\n * @param {T}  obj a map like property.\n * @param {string}  key\n * @return {boolean}\n * @template T\n */\nexport function hasOwn(obj, key) {\n  return hasOwn_.call(obj, key);\n}\n\n/**\n * Returns obj[key] iff key is obj's own property (is not inherited).\n * Otherwise, returns undefined.\n *\n * @param {Object} obj\n * @param {string} key\n * @return {*}\n */\nexport function ownProperty(obj, key) {\n  if (hasOwn(obj, key)) {\n    return obj[key];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Deep merges source into target.\n *\n * @param {!Object} target\n * @param {!Object} source\n * @param {number} depth The maximum merge depth. If exceeded, Object.assign\n *                       will be used instead.\n * @return {!Object}\n * @throws {Error} If source contains a circular reference.\n * Note: Only nested objects are deep-merged, primitives and arrays are not.\n */\nexport function deepMerge(target, source, depth = 10) {\n  // Keep track of seen objects to detect recursive references.\n  const seen = [];\n\n  /** @type {!Array<{t: !Object, s: !Object, d: number}>} */\n  const queue = [];\n  queue.push({t: target, s: source, d: 0});\n\n  // BFS to ensure objects don't have recursive references at shallower depths.\n  while (queue.length > 0) {\n    const {d, s, t} = queue.shift();\n    if (seen.includes(s)) {\n      throw new Error('Source object has a circular reference.');\n    }\n    seen.push(s);\n    if (t === s) {\n      continue;\n    }\n    if (d > depth) {\n      Object.assign(t, s);\n      continue;\n    }\n    for (const key of Object.keys(s)) {\n      const newValue = s[key];\n      // Perform a deep merge IFF both target and source have the same key\n      // whose corresponding values are objects.\n      if (hasOwn(t, key)) {\n        const oldValue = t[key];\n        if (isObject(newValue) && isObject(oldValue)) {\n          queue.push({t: oldValue, s: newValue, d: d + 1});\n          continue;\n        }\n      }\n      t[key] = newValue;\n    }\n  }\n  return target;\n}\n\n/**\n * @param {!Object} o An object to remove properties from\n * @param {!Array<string>} props A list of properties to remove from the Object\n * @return {!Object} An object with the given properties removed\n */\nexport function omit(o, props) {\n  return Object.keys(o).reduce((acc, key) => {\n    if (!props.includes(key)) {\n      acc[key] = o[key];\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * @param {!Object|null|undefined} o1\n * @param {!Object|null|undefined} o2\n * @return {boolean}\n */\nexport function objectsEqualShallow(o1, o2) {\n  if (o1 == null || o2 == null) {\n    // Null is only equal to null, and undefined to undefined.\n    return o1 === o2;\n  }\n\n  for (const k in o1) {\n    if (o1[k] !== o2[k]) {\n      return false;\n    }\n  }\n  for (const k in o2) {\n    if (o2[k] !== o1[k]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @param {T} obj\n * @param {string} prop\n * @param {function(T, string):R} factory\n * @return {R}\n * @template T,R\n */\nexport function memo(obj, prop, factory) {\n  let result = /** @type {?R} */ (obj[prop]);\n  if (result === undefined) {\n    result = factory(obj, prop);\n    obj[prop] = result;\n  }\n  return result;\n}\n\n/**\n * Recreates objects with prototype-less copies.\n * @param {!JsonObject} obj\n * @return {!JsonObject}\n */\nexport function recreateNonProtoObject(obj) {\n  const copy = map();\n  for (const k in obj) {\n    if (!hasOwn(obj, k)) {\n      continue;\n    }\n    const v = obj[k];\n    copy[k] = isObject(v) ? recreateNonProtoObject(v) : v;\n  }\n  return /** @type {!JsonObject} */ (copy);\n}\n\n/**\n * Returns a value from an object for a field-based expression. The expression\n * is a simple nested dot-notation of fields, such as `field1.field2`. If any\n * field in a chain does not exist or is not an object or array, the returned\n * value will be `undefined`.\n *\n * @param {!JsonObject} obj\n * @param {string} expr\n * @return {*}\n */\nexport function getValueForExpr(obj, expr) {\n  // The `.` indicates \"the object itself\".\n  if (expr == '.') {\n    return obj;\n  }\n  // Otherwise, navigate via properties.\n  const parts = expr.split('.');\n  let value = obj;\n  for (const part of parts) {\n    if (\n      part &&\n      value &&\n      value[part] !== undefined &&\n      typeof value == 'object' &&\n      hasOwn(value, part)\n    ) {\n      value = value[part];\n      continue;\n    }\n    value = undefined;\n    break;\n  }\n  return value;\n}\n", "import {Deferred} from '#core/data-structures/promise';\nimport {rethrowAsync} from '#core/error';\nimport * as mode from '#core/mode';\nimport {map} from '#core/types/object';\n\n/**\n * For type anotations where Element is a local variable.\n * @typedef {!Element}\n */\nlet ElementOrigDef;\n\n/** @typedef {!typeof HTMLElement} */\nlet CustomElementConstructorDef;\n\n/**\n * @typedef {{\n *  name: string,\n *  ctor: !CustomElementConstructorDef,\n * }}\n */\nlet CustomElementDef;\n\n/**\n * Validates the custom element's name.\n * This intentionally ignores \"valid\" higher Unicode Code Points.\n * https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n */\nconst VALID_NAME = /^[a-z][a-z0-9._]*-[a-z0-9._-]*$/;\nconst INVALID_NAMES = [\n  'annotation-xml',\n  'color-profile',\n  'font-face',\n  'font-face-src',\n  'font-face-uri',\n  'font-face-format',\n  'font-face-name',\n  'missing-glyph',\n];\n\n/**\n * A MutationObserverInit dictionary to track subtree modifications.\n */\nconst TRACK_SUBTREE = {\n  'childList': true,\n  'subtree': true,\n};\n\n/**\n * Asserts that the custom element name conforms to the spec.\n *\n * @param {!typeof SyntaxError} SyntaxError\n * @param {string} name\n */\nfunction assertValidName(SyntaxError, name) {\n  if (!VALID_NAME.test(name) || INVALID_NAMES.includes(name)) {\n    throw new SyntaxError(`invalid custom element name \"${name}\"`);\n  }\n}\n\n/**\n * Does win have a full Custom Elements registry?\n *\n * @param {!Window} win\n * @return {boolean}\n */\nfunction hasCustomElements(win) {\n  const {customElements} = win;\n\n  return !!(\n    customElements &&\n    customElements.define &&\n    customElements.get &&\n    customElements.whenDefined\n  );\n}\n\n/**\n * Was HTMLElement already patched for this window?\n *\n * @param {!Window} win\n * @return {boolean}\n */\nfunction isPatched(win) {\n  const tag = win.HTMLElement.toString();\n  return tag.indexOf('[native code]') === -1;\n}\n\n/**\n * The public Custom Elements API.\n */\nclass CustomElementRegistry {\n  /**\n   * @param {!Window} win\n   * @param {!Registry} registry\n   */\n  constructor(win, registry) {\n    /** @const @private */\n    this.win_ = win;\n\n    /** @const @private */\n    this.registry_ = registry;\n\n    /** @private @const @type {!Object<string, !Deferred>} */\n    this.pendingDefines_ = map();\n  }\n\n  /**\n   * Register the custom element.\n   *\n   * @param {string} name\n   * @param {!CustomElementConstructorDef} ctor\n   * @param {!Object=} options\n   */\n  define(name, ctor, options) {\n    this.registry_.define(name, ctor, options);\n\n    // If anyone is waiting for this custom element to be defined, resolve\n    // their promise.\n    const pending = this.pendingDefines_;\n    const deferred = pending[name];\n    if (deferred) {\n      deferred.resolve();\n      delete pending[name];\n    }\n  }\n\n  /**\n   * Get the constructor of the (already defined) custom element.\n   *\n   * @param {string} name\n   * @return {!CustomElementConstructorDef|undefined}\n   */\n  get(name) {\n    const def = this.registry_.getByName(name);\n    if (def) {\n      return def.ctor;\n    }\n  }\n\n  /**\n   * Returns a promise that waits until the custom element is defined.\n   * If the custom element is already defined, returns a resolved promise.\n   *\n   * @param {string} name\n   * @return {!Promise<undefined>}\n   */\n  whenDefined(name) {\n    const {Promise, SyntaxError} = this.win_;\n    assertValidName(SyntaxError, name);\n\n    if (this.registry_.getByName(name)) {\n      return Promise.resolve();\n    }\n\n    const pending = this.pendingDefines_;\n    let deferred = pending[name];\n    if (!deferred) {\n      deferred = new Deferred();\n      pending[name] = deferred;\n    }\n\n    return deferred.promise;\n  }\n\n  /**\n   * Upgrade all custom elements inside root.\n   *\n   * @param {!Node} root\n   */\n  upgrade(root) {\n    this.registry_.upgrade(root);\n  }\n}\n\n/**\n * This internal APIs necessary to run the CustomElementRegistry.\n * Since Registry is never exposed externally, all methods are actually\n * available on the instance.\n */\nclass Registry {\n  /**\n   * @param {!Window} win\n   */\n  constructor(win) {\n    /** @private @const */\n    this.win_ = win;\n\n    /** @private @const @type {!Object<string, !CustomElementDef>} */\n    this.definitions_ = map();\n\n    /**\n     * A up-to-date DOM selector for all custom elements.\n     * @type {string}\n     */\n    this.query_ = '';\n\n    /**\n     * The currently upgrading element.\n     * @private {?Element}\n     */\n    this.current_ = null;\n\n    /**\n     * Once started (after the first Custom Element definition), this tracks\n     * DOM append and removals.\n     *\n     * @private {?MutationObserver}\n     */\n    this.mutationObserver_ = null;\n\n    /**\n     * All the observed DOM trees, including shadow trees.\n     *\n     * @private @const {!Array<!Node>}\n     */\n    this.roots_ = [win.document];\n  }\n\n  /**\n   * The currently-being-upgraded custom element.\n   *\n   * When an already created (through the DOM parsing APIs, or innerHTML)\n   * custom element node is being upgraded, we can't just create a new node\n   * (it's illegal in the spec). But we still need to run the custom element's\n   * constructor code on the node. We avoid this conundrum by running the\n   * constructor while returning this current node in the HTMLElement\n   * class constructor (the base class of all custom elements).\n   *\n   * @return {?Element}\n   */\n  current() {\n    const current = this.current_;\n    this.current_ = null;\n    return current;\n  }\n\n  /**\n   * Finds the custom element definition by name.\n   *\n   * @param {string} name\n   * @return {!CustomElementDef|undefined}\n   */\n  getByName(name) {\n    const definition = this.definitions_[name];\n    if (definition) {\n      return definition;\n    }\n  }\n\n  /**\n   * Finds the custom element definition by constructor instance.\n   *\n   * @param {!CustomElementConstructorDef} ctor\n   * @return {!CustomElementDef|undefined}\n   */\n  getByConstructor(ctor) {\n    const definitions = this.definitions_;\n\n    for (const name in definitions) {\n      const def = definitions[name];\n      if (def.ctor === ctor) {\n        return def;\n      }\n    }\n  }\n\n  /**\n   * Registers the custom element definition, and upgrades all elements by that\n   * name in the root document.\n   *\n   * @param {string} name\n   * @param {!CustomElementConstructorDef} ctor\n   * @param {!Object|undefined} options\n   */\n  define(name, ctor, options) {\n    const {Error, SyntaxError} = this.win_;\n\n    if (options) {\n      throw new Error('Extending native custom elements is not supported');\n    }\n\n    assertValidName(SyntaxError, name);\n\n    if (this.getByName(name) || this.getByConstructor(ctor)) {\n      throw new Error(`duplicate definition \"${name}\"`);\n    }\n\n    // TODO(jridgewell): Record connectedCallback, disconnectedCallback,\n    // adoptedCallback, attributeChangedCallback, and observedAttributes.\n    // TODO(jridgewell): If attributeChangedCallback, gather observedAttributes\n    this.definitions_[name] = {\n      name,\n      ctor,\n    };\n\n    this.observe_(name);\n    for (const tree of this.roots_) {\n      this.upgrade(tree, name);\n    }\n  }\n\n  /**\n   * Upgrades custom elements descendants of root (but not including root).\n   *\n   * When called with an opt_query, it both upgrades and connects the custom\n   * elements (this is used during the custom element define algorithm).\n   *\n   * @param {!Node} root\n   * @param {string=} opt_query\n   */\n  upgrade(root, opt_query) {\n    // Only CustomElementRegistry.p.define provides a query (the newly defined\n    // custom element). In this case, we are both upgrading _and_ connecting\n    // the custom elements.\n    const newlyDefined = !!opt_query;\n    const query = opt_query || this.query_;\n    const upgradeCandidates = this.queryAll_(root, query);\n\n    for (const candidate of upgradeCandidates) {\n      if (newlyDefined) {\n        this.connectedCallback_(candidate);\n      } else {\n        this.upgradeSelf(candidate);\n      }\n    }\n  }\n\n  /**\n   * Upgrades the custom element node, if a custom element has been registered\n   * by this name.\n   *\n   * @param {!Node} node\n   */\n  upgradeSelf(node) {\n    const def = this.getByName(node.localName);\n    if (!def) {\n      return;\n    }\n\n    this.upgradeSelf_(/** @type {!Element} */ (node), def);\n  }\n\n  /**\n   * @param {!Node} root\n   * @param {string} query\n   * @return {!Array|!NodeList}\n   */\n  queryAll_(root, query) {\n    if (!query || !root.querySelectorAll) {\n      // Nothing to do...\n      return [];\n    }\n\n    return root.querySelectorAll(query);\n  }\n\n  /**\n   * Upgrades the (already created via DOM parsing) custom element.\n   *\n   * @param {!Element} node\n   * @param {!CustomElementDef} def\n   */\n  upgradeSelf_(node, def) {\n    const {ctor} = def;\n    if (node instanceof ctor) {\n      return;\n    }\n\n    // Despite how it looks, this is not a useless construction.\n    // HTMLElementPolyfill (the base class of all custom elements) will return\n    // the current node, allowing the custom element's subclass constructor to\n    // run on the node. The node itself is already constructed, so the return\n    // value is just the node.\n    this.current_ = node;\n    try {\n      const el = new ctor();\n\n      if (el !== node) {\n        throw new this.win_.Error(\n          'Constructor illegally returned a different instance.'\n        );\n      }\n    } catch (e) {\n      rethrowAsync(e);\n    }\n  }\n\n  /**\n   * Fires connectedCallback on the custom element, if it has one.\n   * This also upgrades the custom element, since it may not have been\n   * accessible via the root document before (a detached DOM tree).\n   *\n   * @param {!Node} node\n   */\n  connectedCallback_(node) {\n    const def = this.getByName(node.localName);\n    if (!def) {\n      return;\n    }\n    node = /** @type {!HTMLElement} */ (node);\n    this.upgradeSelf_(node, def);\n    // TODO(jridgewell): It may be appropriate to adoptCallback, if the node\n    // used to be in another doc.\n    // TODO(jridgewell): I should be calling the definitions connectedCallback\n    // with node as the context.\n    if (node.connectedCallback) {\n      try {\n        node.connectedCallback();\n      } catch (e) {\n        rethrowAsync(e);\n      }\n    }\n  }\n\n  /**\n   * Fires disconnectedCallback on the custom element, if it has one.\n   *\n   * @param {!Node} node\n   */\n  disconnectedCallback_(node) {\n    // TODO(jridgewell): I should be calling the definitions connectedCallback\n    // with node as the context.\n    node = /** @type {!HTMLElement} */ (node);\n    if (node.disconnectedCallback) {\n      try {\n        node.disconnectedCallback();\n      } catch (e) {\n        rethrowAsync(e);\n      }\n    }\n  }\n\n  /**\n   * Records name as a registered custom element to observe.\n   *\n   * Starts the Mutation Observer if this is the first registered custom\n   * element. This is deferred until the first custom element is defined to\n   * speed up initial rendering of the page.\n   *\n   * Mutation Observers are conveniently available in every browser we care\n   * about. When a node is connected to the root document, all custom\n   * elements (including that node iteself) will be upgraded and call\n   * connectedCallback. When a node is disconnectedCallback from the root\n   * document, all custom elements will call disconnectedCallback.\n   *\n   * @param {string} name\n   */\n  observe_(name) {\n    if (this.query_) {\n      this.query_ += `,${name}`;\n      return;\n    }\n\n    this.query_ = name;\n\n    // The first registered name starts the mutation observer.\n    const mo = new this.win_.MutationObserver((records) => {\n      if (records) {\n        this.handleRecords_(records);\n      }\n    });\n    this.mutationObserver_ = mo;\n\n    // I would love to not have to hold onto all of the roots, since it's a\n    // memory leak. Unfortunately, there's no way to iterate a list and hold\n    // onto its contents weakly.\n    for (const tree of this.roots_) {\n      mo.observe(tree, TRACK_SUBTREE);\n    }\n\n    installPatches(this.win_, this);\n  }\n\n  /**\n   * Adds the shadow tree to be observed by the polyfill.\n   *\n   * @param {!Node} tree\n   */\n  observe(tree) {\n    this.roots_.push(tree);\n    if (this.mutationObserver_) {\n      this.mutationObserver_.observe(tree, TRACK_SUBTREE);\n    }\n  }\n\n  /**\n   * This causes a synchronous handling of all the Mutation Observer's tracked\n   * mutations. This does nothing until the mutation observer is actually\n   * registered on the first Custom Element definition.\n   */\n  sync() {\n    if (this.mutationObserver_) {\n      this.handleRecords_(this.mutationObserver_.takeRecords());\n    }\n  }\n\n  /**\n   * Handle all the Mutation Observer's Mutation Records.\n   * All added custom elements will be upgraded (if not already) and call\n   * connectedCallback. All removed custom elements will call\n   * disconnectedCallback.\n   *\n   * @param {!Array<!MutationRecord>} records\n   */\n  handleRecords_(records) {\n    for (const record of records) {\n      if (!record) {\n        continue;\n      }\n\n      const {addedNodes, removedNodes} = record;\n      for (const node of addedNodes) {\n        const connectedCandidates = this.queryAll_(node, this.query_);\n        this.connectedCallback_(node);\n        for (const candidate of connectedCandidates) {\n          this.connectedCallback_(candidate);\n        }\n      }\n\n      for (const node of removedNodes) {\n        const disconnectedCandidates = this.queryAll_(node, this.query_);\n        this.disconnectedCallback_(node);\n        for (const candidate of disconnectedCandidates) {\n          this.disconnectedCallback_(candidate);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Patches the DOM APIs to support synchronous Custom Elements.\n * @param {!Window} win\n * @param {!Registry} registry\n */\nfunction installPatches(win, registry) {\n  const {Document, Element, Node, document} = win;\n  const docProto = Document.prototype;\n  const elProto = Element.prototype;\n  const nodeProto = Node.prototype;\n  const {createElement, importNode} = docProto;\n  const {appendChild, cloneNode, insertBefore, removeChild, replaceChild} =\n    nodeProto;\n\n  // Patch createElement to immediately upgrade the custom element.\n  // This has the added benefit that it avoids the \"already created but needs\n  // constructor code run\" chicken-and-egg problem.\n  docProto.createElement = function (name) {\n    const def = registry.getByName(name);\n    if (def) {\n      return new def.ctor();\n    }\n    return createElement.apply(this, arguments);\n  };\n\n  // Patch importNode to immediately upgrade custom elements.\n  // TODO(jridgewell): Can fire adoptedCallback for cross doc imports.\n  docProto.importNode = function () {\n    const imported = importNode.apply(this, arguments);\n\n    // Only upgrade elements if the document that the nodes were imported into\n    // is _this_ document. If it's another document, then that document's\n    // element registry must do the upgrade.\n    // Eg, when importing from a <template>, the cloned document fragment\n    // should be upgraded. But importing from document into the <template>\n    // should not.\n    if (imported && this === document) {\n      registry.upgradeSelf(imported);\n      registry.upgrade(imported);\n    }\n    return imported;\n  };\n\n  // Patch appendChild to upgrade custom elements before returning.\n  nodeProto.appendChild = function () {\n    const appended = appendChild.apply(this, arguments);\n    registry.sync();\n    return appended;\n  };\n\n  // Patch insertBefore to upgrade custom elements before returning.\n  nodeProto.insertBefore = function () {\n    const inserted = insertBefore.apply(this, arguments);\n    registry.sync();\n    return inserted;\n  };\n\n  // Patch removeChild to upgrade custom elements before returning.\n  nodeProto.removeChild = function () {\n    const removed = removeChild.apply(this, arguments);\n    registry.sync();\n    return removed;\n  };\n\n  // Patch replaceChild to upgrade and detach custom elements before returning.\n  nodeProto.replaceChild = function () {\n    const replaced = replaceChild.apply(this, arguments);\n    registry.sync();\n    return replaced;\n  };\n\n  // Patch cloneNode to immediately upgrade custom elements.\n  nodeProto.cloneNode = function () {\n    const cloned = cloneNode.apply(this, arguments);\n\n    // Only upgrade elements if the cloned node belonged to _this_ document.\n    // Eg, when cloning a <template>'s content, the cloned document fragment\n    // does not belong to this document.\n    if (cloned.ownerDocument === document) {\n      registry.upgradeSelf(cloned);\n      registry.upgrade(cloned);\n    }\n    return cloned;\n  };\n\n  // Patch the innerHTML setter to immediately upgrade custom elements.\n  // Note, this could technically fire connectedCallbacks if this node was\n  // connected, but we leave that to the Mutation Observer.\n  let innerHTMLProto = elProto;\n  let innerHTMLDesc = Object.getOwnPropertyDescriptor(\n    innerHTMLProto,\n    'innerHTML'\n  );\n  if (!innerHTMLDesc) {\n    // Sigh... IE11 puts innerHTML desciptor on HTMLElement. But, we've\n    // replaced HTMLElement with a polyfill wrapper, so have to get its proto.\n    innerHTMLProto = Object.getPrototypeOf(win.HTMLElement.prototype);\n    innerHTMLDesc = Object.getOwnPropertyDescriptor(\n      innerHTMLProto,\n      'innerHTML'\n    );\n  }\n  if (innerHTMLDesc?.configurable) {\n    const innerHTMLSetter = innerHTMLDesc.set;\n    innerHTMLDesc.set = function (html) {\n      innerHTMLSetter.call(this, html);\n      registry.upgrade(this);\n    };\n    Object.defineProperty(\n      /** @type {!Object} */ (innerHTMLProto),\n      'innerHTML',\n      innerHTMLDesc\n    );\n  }\n}\n\n/**\n * Does the polyfilling.\n * @param {!Window} win\n */\nfunction polyfill(win) {\n  const {Element, HTMLElement, document} = win;\n  const {createElement} = document;\n\n  const registry = new Registry(win);\n  const customElements = new CustomElementRegistry(win, registry);\n\n  // Expose the custom element registry.\n  // Object.getOwnPropertyDescriptor(window, 'customElements')\n  // {get: \u0192, set: undefined, enumerable: true, configurable: true}\n  Object.defineProperty(win, 'customElements', {\n    enumerable: true,\n    configurable: true,\n    // writable: false,\n    value: customElements,\n  });\n\n  // Have to patch shadow methods now, since there's no way to find shadow trees\n  // later.\n  const elProto = Element.prototype;\n  const {attachShadow, createShadowRoot} = elProto;\n  if (attachShadow) {\n    /**\n     * @param {{mode: string}} unused\n     * @return {!ShadowRoot}\n     */\n    elProto.attachShadow = function (unused) {\n      const shadow = attachShadow.apply(this, arguments);\n      registry.observe(shadow);\n      return shadow;\n    };\n    // Necessary for Shadow AMP\n    elProto.attachShadow.toString = function () {\n      return attachShadow.toString();\n    };\n  }\n  if (createShadowRoot) {\n    /** @return {!ShadowRoot} */\n    elProto.createShadowRoot = function () {\n      const shadow = createShadowRoot.apply(this, arguments);\n      registry.observe(shadow);\n      return shadow;\n    };\n    // Necessary for Shadow AMP\n    elProto.createShadowRoot.toString = function () {\n      return createShadowRoot.toString();\n    };\n  }\n\n  /**\n   * You can't use the real HTMLElement constructor, because you can't subclass\n   * it without using native classes. So, mock its approximation using\n   * createElement.\n   * @return {!ElementOrigDef}\n   */\n  function HTMLElementPolyfill() {\n    const {constructor} = this;\n\n    // If we're upgrading an already created custom element, we can't create\n    // another new node (by the spec, it must be the same node).\n    let el = registry.current();\n\n    // If there's not a already created custom element, we're being invoked via\n    // `new`ing the constructor.\n    //\n    // Technically, we could get here via createElement, but we patched that.\n    // If it the custom element was registered, the patch turned it into a\n    // `new` call.\n    // If it was not registered, the native createElement is used. And if\n    // native createElement is being used and we got to this code, we're really\n    // in an infinite loop (a native createElement call just below) so we've\n    // got bigger problems.\n    //\n    // So just take my word we got here via `new`.\n    if (!el) {\n      // The custom element definition is an invariant. If the custom element\n      // is registered, everything works. If it's not, it throws in the member\n      // property access (only defined custom elements can be directly\n      // constructed via `new`).\n      const def = registry.getByConstructor(constructor);\n      el = createElement.call(document, def.name);\n    }\n\n    // Finally, if the node was already constructed, we need to reset its\n    // prototype to the custom element prototype. And if it wasn't already\n    // constructed, we created a new node via native createElement, and we need\n    // to reset its prototype. Basically always reset the prototype.\n    setPrototypeOf(el, constructor.prototype);\n    return el;\n  }\n  subClass(HTMLElement, HTMLElementPolyfill);\n\n  // Expose the polyfilled HTMLElement constructor for everyone to extend from.\n  win.HTMLElementOrig = win.HTMLElement;\n  win.HTMLElement = HTMLElementPolyfill;\n\n  // When we transpile `super` in Custom Element subclasses, we change it to\n  // `superClass.call(this)` (where `superClass` is `HTMLElementPolyfill`).\n  // That `.call` value is inherited from `Function.prototype`.\n  // But, IE11's native HTMLElement hierarchy doesn't extend from Function!\n  // And because `HTMLElementPolyfill` extends from `HTMLElement`, it doesn't\n  // have a `.call`! So we need to manually install it.\n  if (!HTMLElementPolyfill.call) {\n    HTMLElementPolyfill.apply = win.Function.apply;\n    HTMLElementPolyfill.bind = win.Function.bind;\n    HTMLElementPolyfill.call = win.Function.call;\n  }\n}\n\n/**\n * Wraps HTMLElement in a Reflect.construct constructor, so that transpiled\n * classes can `_this = superClass.call(this)` during their construction.\n *\n * This is only used when Custom Elements v1 is already available _and_ we're\n * using transpiled classes (which use ES5 construction idioms).\n *\n * @param {!Window} win\n * @suppress {globalThis}\n */\nfunction wrapHTMLElement(win) {\n  const {HTMLElement, Reflect} = win;\n  /** @return {!Element} */\n  function HTMLElementWrapper() {\n    const ctor = /** @type {function(...?):?|undefined} */ (this.constructor);\n\n    // Reflect.construct allows us to construct a new HTMLElement without using\n    // `new` (which will always fail because native HTMLElement is a restricted\n    // constructor).\n    return Reflect.construct(HTMLElement, [], ctor);\n  }\n  subClass(HTMLElement, HTMLElementWrapper);\n\n  // Expose the wrapped HTMLElement constructor for everyone to extend from.\n  win.HTMLElementOrig = win.HTMLElement;\n  win.HTMLElement = HTMLElementWrapper;\n}\n\n/**\n * Setups up prototype inheritance\n *\n * @param {!SUPER} superClass\n * @param {!SUB} subClass\n * @template SUPER\n * @template SUB\n */\nfunction subClass(superClass, subClass) {\n  // Object.getOwnPropertyDescriptor(superClass.prototype, 'constructor')\n  // {value: \u0192, writable: true, enumerable: false, configurable: true}\n  subClass.prototype = Object.create(superClass.prototype, {\n    constructor: {\n      // enumerable: false,\n      configurable: true,\n      writable: true,\n      value: subClass,\n    },\n  });\n  setPrototypeOf(subClass, superClass);\n}\n\n/**\n * Tests whether setting '__proto__' will change the prototype chain of an\n * object. Only needed for old IE.\n * @return {boolean}\n */\nfunction supportsUnderProto() {\n  const proto = {'test': true};\n  const obj = {};\n  obj.__proto__ = proto;\n  return !!obj['test'];\n}\n\n/**\n * Sets the prototype chain of an object, with various fallbacks to support\n * old IE.\n * @param {!Object} obj\n * @param {!Object} prototype\n */\nfunction setPrototypeOf(obj, prototype) {\n  if (mode.isEsm() || Object.setPrototypeOf) {\n    // Every decent browser.\n    Object.setPrototypeOf(obj, prototype);\n  } else if (supportsUnderProto()) {\n    // IE11\n    obj.__proto__ = prototype;\n  } else {\n    // IE10 man. :sigh:\n    copyProperties(obj, prototype);\n  }\n}\n\n/**\n * Copies the property descriptors from prototype to obj. This is only\n * necessary for old IE, which can't properly set the prototype of an already\n * created object.\n * @param {!Object} obj\n * @param {!Object} prototype\n * @visibleForTesting\n */\nexport function copyProperties(obj, prototype) {\n  let current = prototype;\n  while (current !== null) {\n    if (Object.isPrototypeOf.call(current, obj)) {\n      break;\n    }\n\n    for (const prop of Object.getOwnPropertyNames(current)) {\n      if (Object.hasOwnProperty.call(obj, prop)) {\n        continue;\n      }\n\n      const desc = /** @type {!ObjectPropertyDescriptor<Object>} */ (\n        Object.getOwnPropertyDescriptor(current, prop)\n      );\n      Object.defineProperty(obj, prop, desc);\n    }\n\n    current = Object.getPrototypeOf(current);\n  }\n}\n\n/**\n * Polyfills Custom Elements v1 API. This has 5 modes:\n *\n * 1. Custom elements v1 already supported, using native classes\n * 2. Custom elements v1 already supported, using transpiled classes\n * 3. Custom elements v1 not supported, using native classes\n * 4. Custom elements v1 not supported, using transpiled classes\n * 5. No sample class constructor provided\n *\n * In mode 1, nothing is done. In mode 2, a minimal polyfill is used to support\n * extending the HTMLElement base class. In mode 3, 4, and 5 a full polyfill is\n * done.\n *\n * @param {!Window} win\n * @param {!Function=} ctor\n */\nexport function install(win, ctor) {\n  // Don't install in no-DOM environments e.g. worker.\n  const shouldInstall = win.document;\n  const hasCE = hasCustomElements(win);\n  if (!shouldInstall || (hasCE && isPatched(win))) {\n    return;\n  }\n\n  let install = true;\n  let installWrapper = false;\n\n  if (ctor && hasCE) {\n    // If ctor is constructable without new, it's a function. That means it was\n    // compiled down, and we need to do the minimal polyfill because all you\n    // cannot extend HTMLElement without native classes.\n    try {\n      const {Reflect} = win;\n\n      // \"Construct\" ctor using ES5 idioms\n      // I'm not sure why, but Closure will complain at the\n      // `Function.call.call()` below unless we cast to a Function instance\n      // here.\n      const instance = /** @type {!Function} */ (Object.create(ctor.prototype));\n\n      // This will throw an error unless we're in a transpiled environemnt.\n      // Native classes must be called as `new Ctor`, not `Ctor.call(instance)`.\n      // We use `Function.call.call` because Closure is too smart for regular\n      // `Ctor.call`.\n      Function.call.call(ctor, instance);\n\n      // If that didn't throw, we're transpiled.\n      // Let's find out if we can wrap HTMLElement and avoid a full patch.\n      installWrapper = !!Reflect?.construct;\n    } catch (e) {\n      // The ctor threw when we constructed it via ES5, so it's a real class.\n      // We're ok to not install the polyfill.\n      install = false;\n    }\n  }\n\n  if (installWrapper) {\n    wrapHTMLElement(win);\n  } else if (install) {\n    polyfill(win);\n  }\n}\n", "/**\n * @fileoverview\n * Entry point for `bento.js`\n */\n\nimport {install as installCustomElements} from './polyfills/custom-elements';\n\ninstallCustomElements(self);\n\nconst BENTO = self.BENTO || [];\n\nBENTO.push = (fn) => {\n  fn();\n};\n\n// eslint-disable-next-line local/window-property-name\nself.BENTO = BENTO;\n\nfor (let i = 0; i < BENTO.length; i++) {\n  BENTO.push(BENTO[i]);\n}\n"],
  "mappings": "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",
  "names": []
}
